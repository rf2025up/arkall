
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model badges
 * 
 */
export type badges = $Result.DefaultSelection<Prisma.$badgesPayload>
/**
 * Model challenge_participants
 * 
 */
export type challenge_participants = $Result.DefaultSelection<Prisma.$challenge_participantsPayload>
/**
 * Model challenges
 * 
 */
export type challenges = $Result.DefaultSelection<Prisma.$challengesPayload>
/**
 * Model habit_logs
 * 
 */
export type habit_logs = $Result.DefaultSelection<Prisma.$habit_logsPayload>
/**
 * Model habits
 * 
 */
export type habits = $Result.DefaultSelection<Prisma.$habitsPayload>
/**
 * Model lesson_plans
 * 
 */
export type lesson_plans = $Result.DefaultSelection<Prisma.$lesson_plansPayload>
/**
 * Model mistakes
 * 
 */
export type mistakes = $Result.DefaultSelection<Prisma.$mistakesPayload>
/**
 * Model pk_matches
 * 
 */
export type pk_matches = $Result.DefaultSelection<Prisma.$pk_matchesPayload>
/**
 * Model schools
 * 
 */
export type schools = $Result.DefaultSelection<Prisma.$schoolsPayload>
/**
 * Model student_badges
 * 
 */
export type student_badges = $Result.DefaultSelection<Prisma.$student_badgesPayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>
/**
 * Model student_checkins
 * 
 */
export type student_checkins = $Result.DefaultSelection<Prisma.$student_checkinsPayload>
/**
 * Model task_library
 * 
 */
export type task_library = $Result.DefaultSelection<Prisma.$task_libraryPayload>
/**
 * Model task_records
 * 
 */
export type task_records = $Result.DefaultSelection<Prisma.$task_recordsPayload>
/**
 * Model teachers
 * 
 */
export type teachers = $Result.DefaultSelection<Prisma.$teachersPayload>
/**
 * Model personalized_tutoring_plans
 * 
 */
export type personalized_tutoring_plans = $Result.DefaultSelection<Prisma.$personalized_tutoring_plansPayload>
/**
 * Model parents
 * 
 */
export type parents = $Result.DefaultSelection<Prisma.$parentsPayload>
/**
 * Model parent_student_bindings
 * 
 */
export type parent_student_bindings = $Result.DefaultSelection<Prisma.$parent_student_bindingsPayload>
/**
 * Model daily_summaries
 * 
 */
export type daily_summaries = $Result.DefaultSelection<Prisma.$daily_summariesPayload>
/**
 * Model campaigns
 * 
 */
export type campaigns = $Result.DefaultSelection<Prisma.$campaignsPayload>
/**
 * Model reward_configs
 * 
 */
export type reward_configs = $Result.DefaultSelection<Prisma.$reward_configsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ParticipantStatus: {
  JOINED: 'JOINED',
  WITHDRAWN: 'WITHDRAWN',
  DISQUALIFIED: 'DISQUALIFIED'
};

export type ParticipantStatus = (typeof ParticipantStatus)[keyof typeof ParticipantStatus]


export const ParticipantResult: {
  WINNER: 'WINNER',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ParticipantResult = (typeof ParticipantResult)[keyof typeof ParticipantResult]


export const ChallengeType: {
  PERSONAL: 'PERSONAL',
  GROUP: 'GROUP',
  CLASS: 'CLASS'
};

export type ChallengeType = (typeof ChallengeType)[keyof typeof ChallengeType]


export const ChallengeStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ChallengeStatus = (typeof ChallengeStatus)[keyof typeof ChallengeStatus]


export const MistakeStatus: {
  PENDING: 'PENDING',
  REVIEWING: 'REVIEWING',
  RESOLVED: 'RESOLVED',
  IGNORED: 'IGNORED'
};

export type MistakeStatus = (typeof MistakeStatus)[keyof typeof MistakeStatus]


export const PKStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PKStatus = (typeof PKStatus)[keyof typeof PKStatus]


export const PlanType: {
  FREE: 'FREE',
  PRO: 'PRO',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const TaskType: {
  HOMEWORK: 'HOMEWORK',
  QUIZ: 'QUIZ',
  PROJECT: 'PROJECT',
  CHALLENGE: 'CHALLENGE',
  DAILY: 'DAILY',
  QC: 'QC',
  TASK: 'TASK',
  SPECIAL: 'SPECIAL',
  BADGE: 'BADGE',
  PK: 'PK',
  PK_RESULT: 'PK_RESULT',
  HABIT: 'HABIT'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskStatus: {
  PENDING: 'PENDING',
  SUBMITTED: 'SUBMITTED',
  REVIEWED: 'REVIEWED',
  COMPLETED: 'COMPLETED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TaskCategory: {
  PROGRESS: 'PROGRESS',
  METHODOLOGY: 'METHODOLOGY',
  TASK: 'TASK',
  PERSONALIZED: 'PERSONALIZED',
  BADGE: 'BADGE',
  SPECIAL: 'SPECIAL',
  CHALLENGE: 'CHALLENGE',
  PK: 'PK',
  HABIT: 'HABIT',
  GROWTH: 'GROWTH'
};

export type TaskCategory = (typeof TaskCategory)[keyof typeof TaskCategory]


export const Role: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  PLATFORM_ADMIN: 'PLATFORM_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type ParticipantStatus = $Enums.ParticipantStatus

export const ParticipantStatus: typeof $Enums.ParticipantStatus

export type ParticipantResult = $Enums.ParticipantResult

export const ParticipantResult: typeof $Enums.ParticipantResult

export type ChallengeType = $Enums.ChallengeType

export const ChallengeType: typeof $Enums.ChallengeType

export type ChallengeStatus = $Enums.ChallengeStatus

export const ChallengeStatus: typeof $Enums.ChallengeStatus

export type MistakeStatus = $Enums.MistakeStatus

export const MistakeStatus: typeof $Enums.MistakeStatus

export type PKStatus = $Enums.PKStatus

export const PKStatus: typeof $Enums.PKStatus

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TaskCategory = $Enums.TaskCategory

export const TaskCategory: typeof $Enums.TaskCategory

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Badges
 * const badges = await prisma.badges.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Badges
   * const badges = await prisma.badges.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.badges`: Exposes CRUD operations for the **badges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badges.findMany()
    * ```
    */
  get badges(): Prisma.badgesDelegate<ExtArgs>;

  /**
   * `prisma.challenge_participants`: Exposes CRUD operations for the **challenge_participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenge_participants
    * const challenge_participants = await prisma.challenge_participants.findMany()
    * ```
    */
  get challenge_participants(): Prisma.challenge_participantsDelegate<ExtArgs>;

  /**
   * `prisma.challenges`: Exposes CRUD operations for the **challenges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenges.findMany()
    * ```
    */
  get challenges(): Prisma.challengesDelegate<ExtArgs>;

  /**
   * `prisma.habit_logs`: Exposes CRUD operations for the **habit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Habit_logs
    * const habit_logs = await prisma.habit_logs.findMany()
    * ```
    */
  get habit_logs(): Prisma.habit_logsDelegate<ExtArgs>;

  /**
   * `prisma.habits`: Exposes CRUD operations for the **habits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Habits
    * const habits = await prisma.habits.findMany()
    * ```
    */
  get habits(): Prisma.habitsDelegate<ExtArgs>;

  /**
   * `prisma.lesson_plans`: Exposes CRUD operations for the **lesson_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lesson_plans
    * const lesson_plans = await prisma.lesson_plans.findMany()
    * ```
    */
  get lesson_plans(): Prisma.lesson_plansDelegate<ExtArgs>;

  /**
   * `prisma.mistakes`: Exposes CRUD operations for the **mistakes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mistakes
    * const mistakes = await prisma.mistakes.findMany()
    * ```
    */
  get mistakes(): Prisma.mistakesDelegate<ExtArgs>;

  /**
   * `prisma.pk_matches`: Exposes CRUD operations for the **pk_matches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pk_matches
    * const pk_matches = await prisma.pk_matches.findMany()
    * ```
    */
  get pk_matches(): Prisma.pk_matchesDelegate<ExtArgs>;

  /**
   * `prisma.schools`: Exposes CRUD operations for the **schools** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.schools.findMany()
    * ```
    */
  get schools(): Prisma.schoolsDelegate<ExtArgs>;

  /**
   * `prisma.student_badges`: Exposes CRUD operations for the **student_badges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_badges
    * const student_badges = await prisma.student_badges.findMany()
    * ```
    */
  get student_badges(): Prisma.student_badgesDelegate<ExtArgs>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs>;

  /**
   * `prisma.student_checkins`: Exposes CRUD operations for the **student_checkins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_checkins
    * const student_checkins = await prisma.student_checkins.findMany()
    * ```
    */
  get student_checkins(): Prisma.student_checkinsDelegate<ExtArgs>;

  /**
   * `prisma.task_library`: Exposes CRUD operations for the **task_library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Task_libraries
    * const task_libraries = await prisma.task_library.findMany()
    * ```
    */
  get task_library(): Prisma.task_libraryDelegate<ExtArgs>;

  /**
   * `prisma.task_records`: Exposes CRUD operations for the **task_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Task_records
    * const task_records = await prisma.task_records.findMany()
    * ```
    */
  get task_records(): Prisma.task_recordsDelegate<ExtArgs>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.teachersDelegate<ExtArgs>;

  /**
   * `prisma.personalized_tutoring_plans`: Exposes CRUD operations for the **personalized_tutoring_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personalized_tutoring_plans
    * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findMany()
    * ```
    */
  get personalized_tutoring_plans(): Prisma.personalized_tutoring_plansDelegate<ExtArgs>;

  /**
   * `prisma.parents`: Exposes CRUD operations for the **parents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parents.findMany()
    * ```
    */
  get parents(): Prisma.parentsDelegate<ExtArgs>;

  /**
   * `prisma.parent_student_bindings`: Exposes CRUD operations for the **parent_student_bindings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parent_student_bindings
    * const parent_student_bindings = await prisma.parent_student_bindings.findMany()
    * ```
    */
  get parent_student_bindings(): Prisma.parent_student_bindingsDelegate<ExtArgs>;

  /**
   * `prisma.daily_summaries`: Exposes CRUD operations for the **daily_summaries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Daily_summaries
    * const daily_summaries = await prisma.daily_summaries.findMany()
    * ```
    */
  get daily_summaries(): Prisma.daily_summariesDelegate<ExtArgs>;

  /**
   * `prisma.campaigns`: Exposes CRUD operations for the **campaigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaigns.findMany()
    * ```
    */
  get campaigns(): Prisma.campaignsDelegate<ExtArgs>;

  /**
   * `prisma.reward_configs`: Exposes CRUD operations for the **reward_configs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reward_configs
    * const reward_configs = await prisma.reward_configs.findMany()
    * ```
    */
  get reward_configs(): Prisma.reward_configsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    badges: 'badges',
    challenge_participants: 'challenge_participants',
    challenges: 'challenges',
    habit_logs: 'habit_logs',
    habits: 'habits',
    lesson_plans: 'lesson_plans',
    mistakes: 'mistakes',
    pk_matches: 'pk_matches',
    schools: 'schools',
    student_badges: 'student_badges',
    students: 'students',
    student_checkins: 'student_checkins',
    task_library: 'task_library',
    task_records: 'task_records',
    teachers: 'teachers',
    personalized_tutoring_plans: 'personalized_tutoring_plans',
    parents: 'parents',
    parent_student_bindings: 'parent_student_bindings',
    daily_summaries: 'daily_summaries',
    campaigns: 'campaigns',
    reward_configs: 'reward_configs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "badges" | "challenge_participants" | "challenges" | "habit_logs" | "habits" | "lesson_plans" | "mistakes" | "pk_matches" | "schools" | "student_badges" | "students" | "student_checkins" | "task_library" | "task_records" | "teachers" | "personalized_tutoring_plans" | "parents" | "parent_student_bindings" | "daily_summaries" | "campaigns" | "reward_configs"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      badges: {
        payload: Prisma.$badgesPayload<ExtArgs>
        fields: Prisma.badgesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badgesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badgesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          findFirst: {
            args: Prisma.badgesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badgesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          findMany: {
            args: Prisma.badgesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>[]
          }
          create: {
            args: Prisma.badgesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          createMany: {
            args: Prisma.badgesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.badgesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>[]
          }
          delete: {
            args: Prisma.badgesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          update: {
            args: Prisma.badgesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          deleteMany: {
            args: Prisma.badgesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badgesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.badgesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgesPayload>
          }
          aggregate: {
            args: Prisma.BadgesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadges>
          }
          groupBy: {
            args: Prisma.badgesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgesGroupByOutputType>[]
          }
          count: {
            args: Prisma.badgesCountArgs<ExtArgs>
            result: $Utils.Optional<BadgesCountAggregateOutputType> | number
          }
        }
      }
      challenge_participants: {
        payload: Prisma.$challenge_participantsPayload<ExtArgs>
        fields: Prisma.challenge_participantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.challenge_participantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.challenge_participantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          findFirst: {
            args: Prisma.challenge_participantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.challenge_participantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          findMany: {
            args: Prisma.challenge_participantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>[]
          }
          create: {
            args: Prisma.challenge_participantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          createMany: {
            args: Prisma.challenge_participantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.challenge_participantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>[]
          }
          delete: {
            args: Prisma.challenge_participantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          update: {
            args: Prisma.challenge_participantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          deleteMany: {
            args: Prisma.challenge_participantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.challenge_participantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.challenge_participantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challenge_participantsPayload>
          }
          aggregate: {
            args: Prisma.Challenge_participantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge_participants>
          }
          groupBy: {
            args: Prisma.challenge_participantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Challenge_participantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.challenge_participantsCountArgs<ExtArgs>
            result: $Utils.Optional<Challenge_participantsCountAggregateOutputType> | number
          }
        }
      }
      challenges: {
        payload: Prisma.$challengesPayload<ExtArgs>
        fields: Prisma.challengesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.challengesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.challengesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          findFirst: {
            args: Prisma.challengesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.challengesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          findMany: {
            args: Prisma.challengesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>[]
          }
          create: {
            args: Prisma.challengesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          createMany: {
            args: Prisma.challengesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.challengesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>[]
          }
          delete: {
            args: Prisma.challengesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          update: {
            args: Prisma.challengesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          deleteMany: {
            args: Prisma.challengesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.challengesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.challengesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$challengesPayload>
          }
          aggregate: {
            args: Prisma.ChallengesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenges>
          }
          groupBy: {
            args: Prisma.challengesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengesGroupByOutputType>[]
          }
          count: {
            args: Prisma.challengesCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengesCountAggregateOutputType> | number
          }
        }
      }
      habit_logs: {
        payload: Prisma.$habit_logsPayload<ExtArgs>
        fields: Prisma.habit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.habit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.habit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          findFirst: {
            args: Prisma.habit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.habit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          findMany: {
            args: Prisma.habit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>[]
          }
          create: {
            args: Prisma.habit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          createMany: {
            args: Prisma.habit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.habit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>[]
          }
          delete: {
            args: Prisma.habit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          update: {
            args: Prisma.habit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          deleteMany: {
            args: Prisma.habit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.habit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.habit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habit_logsPayload>
          }
          aggregate: {
            args: Prisma.Habit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabit_logs>
          }
          groupBy: {
            args: Prisma.habit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Habit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.habit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Habit_logsCountAggregateOutputType> | number
          }
        }
      }
      habits: {
        payload: Prisma.$habitsPayload<ExtArgs>
        fields: Prisma.habitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.habitsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.habitsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          findFirst: {
            args: Prisma.habitsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.habitsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          findMany: {
            args: Prisma.habitsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>[]
          }
          create: {
            args: Prisma.habitsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          createMany: {
            args: Prisma.habitsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.habitsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>[]
          }
          delete: {
            args: Prisma.habitsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          update: {
            args: Prisma.habitsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          deleteMany: {
            args: Prisma.habitsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.habitsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.habitsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habitsPayload>
          }
          aggregate: {
            args: Prisma.HabitsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabits>
          }
          groupBy: {
            args: Prisma.habitsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.habitsCountArgs<ExtArgs>
            result: $Utils.Optional<HabitsCountAggregateOutputType> | number
          }
        }
      }
      lesson_plans: {
        payload: Prisma.$lesson_plansPayload<ExtArgs>
        fields: Prisma.lesson_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lesson_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lesson_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          findFirst: {
            args: Prisma.lesson_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lesson_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          findMany: {
            args: Prisma.lesson_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>[]
          }
          create: {
            args: Prisma.lesson_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          createMany: {
            args: Prisma.lesson_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lesson_plansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>[]
          }
          delete: {
            args: Prisma.lesson_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          update: {
            args: Prisma.lesson_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          deleteMany: {
            args: Prisma.lesson_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lesson_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lesson_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lesson_plansPayload>
          }
          aggregate: {
            args: Prisma.Lesson_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson_plans>
          }
          groupBy: {
            args: Prisma.lesson_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lesson_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.lesson_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Lesson_plansCountAggregateOutputType> | number
          }
        }
      }
      mistakes: {
        payload: Prisma.$mistakesPayload<ExtArgs>
        fields: Prisma.mistakesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mistakesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mistakesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          findFirst: {
            args: Prisma.mistakesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mistakesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          findMany: {
            args: Prisma.mistakesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>[]
          }
          create: {
            args: Prisma.mistakesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          createMany: {
            args: Prisma.mistakesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mistakesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>[]
          }
          delete: {
            args: Prisma.mistakesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          update: {
            args: Prisma.mistakesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          deleteMany: {
            args: Prisma.mistakesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mistakesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mistakesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mistakesPayload>
          }
          aggregate: {
            args: Prisma.MistakesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMistakes>
          }
          groupBy: {
            args: Prisma.mistakesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MistakesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mistakesCountArgs<ExtArgs>
            result: $Utils.Optional<MistakesCountAggregateOutputType> | number
          }
        }
      }
      pk_matches: {
        payload: Prisma.$pk_matchesPayload<ExtArgs>
        fields: Prisma.pk_matchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pk_matchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pk_matchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          findFirst: {
            args: Prisma.pk_matchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pk_matchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          findMany: {
            args: Prisma.pk_matchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>[]
          }
          create: {
            args: Prisma.pk_matchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          createMany: {
            args: Prisma.pk_matchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pk_matchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>[]
          }
          delete: {
            args: Prisma.pk_matchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          update: {
            args: Prisma.pk_matchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          deleteMany: {
            args: Prisma.pk_matchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pk_matchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pk_matchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pk_matchesPayload>
          }
          aggregate: {
            args: Prisma.Pk_matchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePk_matches>
          }
          groupBy: {
            args: Prisma.pk_matchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pk_matchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pk_matchesCountArgs<ExtArgs>
            result: $Utils.Optional<Pk_matchesCountAggregateOutputType> | number
          }
        }
      }
      schools: {
        payload: Prisma.$schoolsPayload<ExtArgs>
        fields: Prisma.schoolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schoolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schoolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          findFirst: {
            args: Prisma.schoolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schoolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          findMany: {
            args: Prisma.schoolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>[]
          }
          create: {
            args: Prisma.schoolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          createMany: {
            args: Prisma.schoolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schoolsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>[]
          }
          delete: {
            args: Prisma.schoolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          update: {
            args: Prisma.schoolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          deleteMany: {
            args: Prisma.schoolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schoolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.schoolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schoolsPayload>
          }
          aggregate: {
            args: Prisma.SchoolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchools>
          }
          groupBy: {
            args: Prisma.schoolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolsGroupByOutputType>[]
          }
          count: {
            args: Prisma.schoolsCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolsCountAggregateOutputType> | number
          }
        }
      }
      student_badges: {
        payload: Prisma.$student_badgesPayload<ExtArgs>
        fields: Prisma.student_badgesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_badgesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_badgesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          findFirst: {
            args: Prisma.student_badgesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_badgesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          findMany: {
            args: Prisma.student_badgesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>[]
          }
          create: {
            args: Prisma.student_badgesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          createMany: {
            args: Prisma.student_badgesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_badgesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>[]
          }
          delete: {
            args: Prisma.student_badgesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          update: {
            args: Prisma.student_badgesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          deleteMany: {
            args: Prisma.student_badgesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_badgesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_badgesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_badgesPayload>
          }
          aggregate: {
            args: Prisma.Student_badgesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_badges>
          }
          groupBy: {
            args: Prisma.student_badgesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_badgesGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_badgesCountArgs<ExtArgs>
            result: $Utils.Optional<Student_badgesCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      student_checkins: {
        payload: Prisma.$student_checkinsPayload<ExtArgs>
        fields: Prisma.student_checkinsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_checkinsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_checkinsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          findFirst: {
            args: Prisma.student_checkinsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_checkinsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          findMany: {
            args: Prisma.student_checkinsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>[]
          }
          create: {
            args: Prisma.student_checkinsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          createMany: {
            args: Prisma.student_checkinsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_checkinsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>[]
          }
          delete: {
            args: Prisma.student_checkinsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          update: {
            args: Prisma.student_checkinsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          deleteMany: {
            args: Prisma.student_checkinsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_checkinsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.student_checkinsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_checkinsPayload>
          }
          aggregate: {
            args: Prisma.Student_checkinsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_checkins>
          }
          groupBy: {
            args: Prisma.student_checkinsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_checkinsGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_checkinsCountArgs<ExtArgs>
            result: $Utils.Optional<Student_checkinsCountAggregateOutputType> | number
          }
        }
      }
      task_library: {
        payload: Prisma.$task_libraryPayload<ExtArgs>
        fields: Prisma.task_libraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.task_libraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.task_libraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          findFirst: {
            args: Prisma.task_libraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.task_libraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          findMany: {
            args: Prisma.task_libraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>[]
          }
          create: {
            args: Prisma.task_libraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          createMany: {
            args: Prisma.task_libraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.task_libraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>[]
          }
          delete: {
            args: Prisma.task_libraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          update: {
            args: Prisma.task_libraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          deleteMany: {
            args: Prisma.task_libraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.task_libraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.task_libraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_libraryPayload>
          }
          aggregate: {
            args: Prisma.Task_libraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask_library>
          }
          groupBy: {
            args: Prisma.task_libraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Task_libraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.task_libraryCountArgs<ExtArgs>
            result: $Utils.Optional<Task_libraryCountAggregateOutputType> | number
          }
        }
      }
      task_records: {
        payload: Prisma.$task_recordsPayload<ExtArgs>
        fields: Prisma.task_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.task_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.task_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          findFirst: {
            args: Prisma.task_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.task_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          findMany: {
            args: Prisma.task_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>[]
          }
          create: {
            args: Prisma.task_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          createMany: {
            args: Prisma.task_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.task_recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>[]
          }
          delete: {
            args: Prisma.task_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          update: {
            args: Prisma.task_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          deleteMany: {
            args: Prisma.task_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.task_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.task_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$task_recordsPayload>
          }
          aggregate: {
            args: Prisma.Task_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask_records>
          }
          groupBy: {
            args: Prisma.task_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Task_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.task_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Task_recordsCountAggregateOutputType> | number
          }
        }
      }
      teachers: {
        payload: Prisma.$teachersPayload<ExtArgs>
        fields: Prisma.teachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findFirst: {
            args: Prisma.teachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findMany: {
            args: Prisma.teachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          create: {
            args: Prisma.teachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          createMany: {
            args: Prisma.teachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          delete: {
            args: Prisma.teachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          update: {
            args: Prisma.teachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          deleteMany: {
            args: Prisma.teachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.teachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.teachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.teachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      personalized_tutoring_plans: {
        payload: Prisma.$personalized_tutoring_plansPayload<ExtArgs>
        fields: Prisma.personalized_tutoring_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.personalized_tutoring_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.personalized_tutoring_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          findFirst: {
            args: Prisma.personalized_tutoring_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.personalized_tutoring_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          findMany: {
            args: Prisma.personalized_tutoring_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>[]
          }
          create: {
            args: Prisma.personalized_tutoring_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          createMany: {
            args: Prisma.personalized_tutoring_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.personalized_tutoring_plansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>[]
          }
          delete: {
            args: Prisma.personalized_tutoring_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          update: {
            args: Prisma.personalized_tutoring_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          deleteMany: {
            args: Prisma.personalized_tutoring_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.personalized_tutoring_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.personalized_tutoring_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalized_tutoring_plansPayload>
          }
          aggregate: {
            args: Prisma.Personalized_tutoring_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalized_tutoring_plans>
          }
          groupBy: {
            args: Prisma.personalized_tutoring_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Personalized_tutoring_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.personalized_tutoring_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Personalized_tutoring_plansCountAggregateOutputType> | number
          }
        }
      }
      parents: {
        payload: Prisma.$parentsPayload<ExtArgs>
        fields: Prisma.parentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findFirst: {
            args: Prisma.parentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          findMany: {
            args: Prisma.parentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          create: {
            args: Prisma.parentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          createMany: {
            args: Prisma.parentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>[]
          }
          delete: {
            args: Prisma.parentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          update: {
            args: Prisma.parentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          deleteMany: {
            args: Prisma.parentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parentsPayload>
          }
          aggregate: {
            args: Prisma.ParentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParents>
          }
          groupBy: {
            args: Prisma.parentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parentsCountArgs<ExtArgs>
            result: $Utils.Optional<ParentsCountAggregateOutputType> | number
          }
        }
      }
      parent_student_bindings: {
        payload: Prisma.$parent_student_bindingsPayload<ExtArgs>
        fields: Prisma.parent_student_bindingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.parent_student_bindingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.parent_student_bindingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          findFirst: {
            args: Prisma.parent_student_bindingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.parent_student_bindingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          findMany: {
            args: Prisma.parent_student_bindingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>[]
          }
          create: {
            args: Prisma.parent_student_bindingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          createMany: {
            args: Prisma.parent_student_bindingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.parent_student_bindingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>[]
          }
          delete: {
            args: Prisma.parent_student_bindingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          update: {
            args: Prisma.parent_student_bindingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          deleteMany: {
            args: Prisma.parent_student_bindingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.parent_student_bindingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.parent_student_bindingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$parent_student_bindingsPayload>
          }
          aggregate: {
            args: Prisma.Parent_student_bindingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent_student_bindings>
          }
          groupBy: {
            args: Prisma.parent_student_bindingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Parent_student_bindingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.parent_student_bindingsCountArgs<ExtArgs>
            result: $Utils.Optional<Parent_student_bindingsCountAggregateOutputType> | number
          }
        }
      }
      daily_summaries: {
        payload: Prisma.$daily_summariesPayload<ExtArgs>
        fields: Prisma.daily_summariesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.daily_summariesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.daily_summariesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          findFirst: {
            args: Prisma.daily_summariesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.daily_summariesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          findMany: {
            args: Prisma.daily_summariesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>[]
          }
          create: {
            args: Prisma.daily_summariesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          createMany: {
            args: Prisma.daily_summariesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.daily_summariesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>[]
          }
          delete: {
            args: Prisma.daily_summariesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          update: {
            args: Prisma.daily_summariesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          deleteMany: {
            args: Prisma.daily_summariesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.daily_summariesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.daily_summariesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$daily_summariesPayload>
          }
          aggregate: {
            args: Prisma.Daily_summariesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDaily_summaries>
          }
          groupBy: {
            args: Prisma.daily_summariesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Daily_summariesGroupByOutputType>[]
          }
          count: {
            args: Prisma.daily_summariesCountArgs<ExtArgs>
            result: $Utils.Optional<Daily_summariesCountAggregateOutputType> | number
          }
        }
      }
      campaigns: {
        payload: Prisma.$campaignsPayload<ExtArgs>
        fields: Prisma.campaignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.campaignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.campaignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          findFirst: {
            args: Prisma.campaignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.campaignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          findMany: {
            args: Prisma.campaignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>[]
          }
          create: {
            args: Prisma.campaignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          createMany: {
            args: Prisma.campaignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.campaignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>[]
          }
          delete: {
            args: Prisma.campaignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          update: {
            args: Prisma.campaignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          deleteMany: {
            args: Prisma.campaignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.campaignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.campaignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$campaignsPayload>
          }
          aggregate: {
            args: Prisma.CampaignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaigns>
          }
          groupBy: {
            args: Prisma.campaignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.campaignsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignsCountAggregateOutputType> | number
          }
        }
      }
      reward_configs: {
        payload: Prisma.$reward_configsPayload<ExtArgs>
        fields: Prisma.reward_configsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reward_configsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reward_configsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          findFirst: {
            args: Prisma.reward_configsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reward_configsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          findMany: {
            args: Prisma.reward_configsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>[]
          }
          create: {
            args: Prisma.reward_configsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          createMany: {
            args: Prisma.reward_configsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reward_configsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>[]
          }
          delete: {
            args: Prisma.reward_configsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          update: {
            args: Prisma.reward_configsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          deleteMany: {
            args: Prisma.reward_configsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reward_configsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reward_configsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reward_configsPayload>
          }
          aggregate: {
            args: Prisma.Reward_configsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward_configs>
          }
          groupBy: {
            args: Prisma.reward_configsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reward_configsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reward_configsCountArgs<ExtArgs>
            result: $Utils.Optional<Reward_configsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BadgesCountOutputType
   */

  export type BadgesCountOutputType = {
    student_badges: number
  }

  export type BadgesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_badges?: boolean | BadgesCountOutputTypeCountStudent_badgesArgs
  }

  // Custom InputTypes
  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgesCountOutputType
     */
    select?: BadgesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgesCountOutputType without action
   */
  export type BadgesCountOutputTypeCountStudent_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_badgesWhereInput
  }


  /**
   * Count Type ChallengesCountOutputType
   */

  export type ChallengesCountOutputType = {
    challenge_participants: number
  }

  export type ChallengesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_participants?: boolean | ChallengesCountOutputTypeCountChallenge_participantsArgs
  }

  // Custom InputTypes
  /**
   * ChallengesCountOutputType without action
   */
  export type ChallengesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengesCountOutputType
     */
    select?: ChallengesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengesCountOutputType without action
   */
  export type ChallengesCountOutputTypeCountChallenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challenge_participantsWhereInput
  }


  /**
   * Count Type HabitsCountOutputType
   */

  export type HabitsCountOutputType = {
    habit_logs: number
  }

  export type HabitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit_logs?: boolean | HabitsCountOutputTypeCountHabit_logsArgs
  }

  // Custom InputTypes
  /**
   * HabitsCountOutputType without action
   */
  export type HabitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HabitsCountOutputType
     */
    select?: HabitsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HabitsCountOutputType without action
   */
  export type HabitsCountOutputTypeCountHabit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habit_logsWhereInput
  }


  /**
   * Count Type Lesson_plansCountOutputType
   */

  export type Lesson_plansCountOutputType = {
    task_records: number
  }

  export type Lesson_plansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_records?: boolean | Lesson_plansCountOutputTypeCountTask_recordsArgs
  }

  // Custom InputTypes
  /**
   * Lesson_plansCountOutputType without action
   */
  export type Lesson_plansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson_plansCountOutputType
     */
    select?: Lesson_plansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Lesson_plansCountOutputType without action
   */
  export type Lesson_plansCountOutputTypeCountTask_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_recordsWhereInput
  }


  /**
   * Count Type SchoolsCountOutputType
   */

  export type SchoolsCountOutputType = {
    badges: number
    challenges: number
    habit_logs: number
    habits: number
    lesson_plans: number
    mistakes: number
    parents: number
    personalized_tutoring_plans: number
    pk_matches: number
    reward_configs: number
    student_checkins: number
    students: number
    task_library: number
    task_records: number
    teachers: number
  }

  export type SchoolsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | SchoolsCountOutputTypeCountBadgesArgs
    challenges?: boolean | SchoolsCountOutputTypeCountChallengesArgs
    habit_logs?: boolean | SchoolsCountOutputTypeCountHabit_logsArgs
    habits?: boolean | SchoolsCountOutputTypeCountHabitsArgs
    lesson_plans?: boolean | SchoolsCountOutputTypeCountLesson_plansArgs
    mistakes?: boolean | SchoolsCountOutputTypeCountMistakesArgs
    parents?: boolean | SchoolsCountOutputTypeCountParentsArgs
    personalized_tutoring_plans?: boolean | SchoolsCountOutputTypeCountPersonalized_tutoring_plansArgs
    pk_matches?: boolean | SchoolsCountOutputTypeCountPk_matchesArgs
    reward_configs?: boolean | SchoolsCountOutputTypeCountReward_configsArgs
    student_checkins?: boolean | SchoolsCountOutputTypeCountStudent_checkinsArgs
    students?: boolean | SchoolsCountOutputTypeCountStudentsArgs
    task_library?: boolean | SchoolsCountOutputTypeCountTask_libraryArgs
    task_records?: boolean | SchoolsCountOutputTypeCountTask_recordsArgs
    teachers?: boolean | SchoolsCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes
  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolsCountOutputType
     */
    select?: SchoolsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgesWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challengesWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountHabit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habit_logsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountHabitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habitsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountLesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lesson_plansWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountMistakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mistakesWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountPersonalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalized_tutoring_plansWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountPk_matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_matchesWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountReward_configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reward_configsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountStudent_checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_checkinsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountTask_libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_libraryWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountTask_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_recordsWhereInput
  }

  /**
   * SchoolsCountOutputType without action
   */
  export type SchoolsCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    campaigns: number
    challenge_participants: number
    daily_summaries: number
    habit_logs: number
    mistakes: number
    parent_student_bindings: number
    personalized_tutoring_plans: number
    pk_matches_studentA: number
    pk_matches_studentB: number
    pk_matches_winner: number
    student_badges: number
    student_checkins: number
    task_records: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | StudentsCountOutputTypeCountCampaignsArgs
    challenge_participants?: boolean | StudentsCountOutputTypeCountChallenge_participantsArgs
    daily_summaries?: boolean | StudentsCountOutputTypeCountDaily_summariesArgs
    habit_logs?: boolean | StudentsCountOutputTypeCountHabit_logsArgs
    mistakes?: boolean | StudentsCountOutputTypeCountMistakesArgs
    parent_student_bindings?: boolean | StudentsCountOutputTypeCountParent_student_bindingsArgs
    personalized_tutoring_plans?: boolean | StudentsCountOutputTypeCountPersonalized_tutoring_plansArgs
    pk_matches_studentA?: boolean | StudentsCountOutputTypeCountPk_matches_studentAArgs
    pk_matches_studentB?: boolean | StudentsCountOutputTypeCountPk_matches_studentBArgs
    pk_matches_winner?: boolean | StudentsCountOutputTypeCountPk_matches_winnerArgs
    student_badges?: boolean | StudentsCountOutputTypeCountStudent_badgesArgs
    student_checkins?: boolean | StudentsCountOutputTypeCountStudent_checkinsArgs
    task_records?: boolean | StudentsCountOutputTypeCountTask_recordsArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountChallenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challenge_participantsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountDaily_summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daily_summariesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountHabit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habit_logsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountMistakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mistakesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountParent_student_bindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_student_bindingsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountPersonalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalized_tutoring_plansWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountPk_matches_studentAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_matchesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountPk_matches_studentBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_matchesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountPk_matches_winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_matchesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_badgesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_checkinsWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountTask_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_recordsWhereInput
  }


  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    challenges: number
    lesson_plans: number
    personalized_tutoring_plans: number
    students: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | TeachersCountOutputTypeCountChallengesArgs
    lesson_plans?: boolean | TeachersCountOutputTypeCountLesson_plansArgs
    personalized_tutoring_plans?: boolean | TeachersCountOutputTypeCountPersonalized_tutoring_plansArgs
    students?: boolean | TeachersCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challengesWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountLesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lesson_plansWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountPersonalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalized_tutoring_plansWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }


  /**
   * Count Type ParentsCountOutputType
   */

  export type ParentsCountOutputType = {
    daily_summaries: number
    parent_student_bindings: number
  }

  export type ParentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    daily_summaries?: boolean | ParentsCountOutputTypeCountDaily_summariesArgs
    parent_student_bindings?: boolean | ParentsCountOutputTypeCountParent_student_bindingsArgs
  }

  // Custom InputTypes
  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentsCountOutputType
     */
    select?: ParentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountDaily_summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daily_summariesWhereInput
  }

  /**
   * ParentsCountOutputType without action
   */
  export type ParentsCountOutputTypeCountParent_student_bindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_student_bindingsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model badges
   */

  export type AggregateBadges = {
    _count: BadgesCountAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  export type BadgesMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    icon: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgesMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    icon: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgesCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    description: number
    icon: number
    category: number
    requirement: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgesMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgesMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgesCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    category?: true
    requirement?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to aggregate.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges
    **/
    _count?: true | BadgesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgesMaxAggregateInputType
  }

  export type GetBadgesAggregateType<T extends BadgesAggregateArgs> = {
        [P in keyof T & keyof AggregateBadges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadges[P]>
      : GetScalarType<T[P], AggregateBadges[P]>
  }




  export type badgesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgesWhereInput
    orderBy?: badgesOrderByWithAggregationInput | badgesOrderByWithAggregationInput[]
    by: BadgesScalarFieldEnum[] | BadgesScalarFieldEnum
    having?: badgesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgesCountAggregateInputType | true
    _min?: BadgesMinAggregateInputType
    _max?: BadgesMaxAggregateInputType
  }

  export type BadgesGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    description: string | null
    icon: string | null
    category: string
    requirement: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BadgesCountAggregateOutputType | null
    _min: BadgesMinAggregateOutputType | null
    _max: BadgesMaxAggregateOutputType | null
  }

  type GetBadgesGroupByPayload<T extends badgesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgesGroupByOutputType[P]>
            : GetScalarType<T[P], BadgesGroupByOutputType[P]>
        }
      >
    >


  export type badgesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    requirement?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    student_badges?: boolean | badges$student_badgesArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges"]>

  export type badgesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    requirement?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badges"]>

  export type badgesSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    requirement?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type badgesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    student_badges?: boolean | badges$student_badgesArgs<ExtArgs>
    _count?: boolean | BadgesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type badgesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $badgesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badges"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      student_badges: Prisma.$student_badgesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      description: string | null
      icon: string | null
      category: string
      requirement: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badges"]>
    composites: {}
  }

  type badgesGetPayload<S extends boolean | null | undefined | badgesDefaultArgs> = $Result.GetResult<Prisma.$badgesPayload, S>

  type badgesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<badgesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgesCountAggregateInputType | true
    }

  export interface badgesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badges'], meta: { name: 'badges' } }
    /**
     * Find zero or one Badges that matches the filter.
     * @param {badgesFindUniqueArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badgesFindUniqueArgs>(args: SelectSubset<T, badgesFindUniqueArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badges that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {badgesFindUniqueOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badgesFindUniqueOrThrowArgs>(args: SelectSubset<T, badgesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindFirstArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badgesFindFirstArgs>(args?: SelectSubset<T, badgesFindFirstArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindFirstOrThrowArgs} args - Arguments to find a Badges
     * @example
     * // Get one Badges
     * const badges = await prisma.badges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badgesFindFirstOrThrowArgs>(args?: SelectSubset<T, badgesFindFirstOrThrowArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badges.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgesWithIdOnly = await prisma.badges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends badgesFindManyArgs>(args?: SelectSubset<T, badgesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badges.
     * @param {badgesCreateArgs} args - Arguments to create a Badges.
     * @example
     * // Create one Badges
     * const Badges = await prisma.badges.create({
     *   data: {
     *     // ... data to create a Badges
     *   }
     * })
     * 
     */
    create<T extends badgesCreateArgs>(args: SelectSubset<T, badgesCreateArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {badgesCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badges = await prisma.badges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badgesCreateManyArgs>(args?: SelectSubset<T, badgesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {badgesCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badges = await prisma.badges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgesWithIdOnly = await prisma.badges.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends badgesCreateManyAndReturnArgs>(args?: SelectSubset<T, badgesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badges.
     * @param {badgesDeleteArgs} args - Arguments to delete one Badges.
     * @example
     * // Delete one Badges
     * const Badges = await prisma.badges.delete({
     *   where: {
     *     // ... filter to delete one Badges
     *   }
     * })
     * 
     */
    delete<T extends badgesDeleteArgs>(args: SelectSubset<T, badgesDeleteArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badges.
     * @param {badgesUpdateArgs} args - Arguments to update one Badges.
     * @example
     * // Update one Badges
     * const badges = await prisma.badges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badgesUpdateArgs>(args: SelectSubset<T, badgesUpdateArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {badgesDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badgesDeleteManyArgs>(args?: SelectSubset<T, badgesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badges = await prisma.badges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badgesUpdateManyArgs>(args: SelectSubset<T, badgesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badges.
     * @param {badgesUpsertArgs} args - Arguments to update or create a Badges.
     * @example
     * // Update or create a Badges
     * const badges = await prisma.badges.upsert({
     *   create: {
     *     // ... data to create a Badges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badges we want to update
     *   }
     * })
     */
    upsert<T extends badgesUpsertArgs>(args: SelectSubset<T, badgesUpsertArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badges.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends badgesCountArgs>(
      args?: Subset<T, badgesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgesAggregateArgs>(args: Subset<T, BadgesAggregateArgs>): Prisma.PrismaPromise<GetBadgesAggregateType<T>>

    /**
     * Group by Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badgesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badgesGroupByArgs['orderBy'] }
        : { orderBy?: badgesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badgesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badges model
   */
  readonly fields: badgesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badgesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_badges<T extends badges$student_badgesArgs<ExtArgs> = {}>(args?: Subset<T, badges$student_badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badges model
   */ 
  interface badgesFieldRefs {
    readonly id: FieldRef<"badges", 'String'>
    readonly schoolId: FieldRef<"badges", 'String'>
    readonly name: FieldRef<"badges", 'String'>
    readonly description: FieldRef<"badges", 'String'>
    readonly icon: FieldRef<"badges", 'String'>
    readonly category: FieldRef<"badges", 'String'>
    readonly requirement: FieldRef<"badges", 'Json'>
    readonly isActive: FieldRef<"badges", 'Boolean'>
    readonly createdAt: FieldRef<"badges", 'DateTime'>
    readonly updatedAt: FieldRef<"badges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * badges findUnique
   */
  export type badgesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges findUniqueOrThrow
   */
  export type badgesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges findFirst
   */
  export type badgesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges findFirstOrThrow
   */
  export type badgesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges findMany
   */
  export type badgesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges.
     */
    cursor?: badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * badges create
   */
  export type badgesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The data needed to create a badges.
     */
    data: XOR<badgesCreateInput, badgesUncheckedCreateInput>
  }

  /**
   * badges createMany
   */
  export type badgesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges.
     */
    data: badgesCreateManyInput | badgesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badges createManyAndReturn
   */
  export type badgesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many badges.
     */
    data: badgesCreateManyInput | badgesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * badges update
   */
  export type badgesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The data needed to update a badges.
     */
    data: XOR<badgesUpdateInput, badgesUncheckedUpdateInput>
    /**
     * Choose, which badges to update.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges updateMany
   */
  export type badgesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges.
     */
    data: XOR<badgesUpdateManyMutationInput, badgesUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgesWhereInput
  }

  /**
   * badges upsert
   */
  export type badgesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * The filter to search for the badges to update in case it exists.
     */
    where: badgesWhereUniqueInput
    /**
     * In case the badges found by the `where` argument doesn't exist, create a new badges with this data.
     */
    create: XOR<badgesCreateInput, badgesUncheckedCreateInput>
    /**
     * In case the badges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badgesUpdateInput, badgesUncheckedUpdateInput>
  }

  /**
   * badges delete
   */
  export type badgesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    /**
     * Filter which badges to delete.
     */
    where: badgesWhereUniqueInput
  }

  /**
   * badges deleteMany
   */
  export type badgesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to delete
     */
    where?: badgesWhereInput
  }

  /**
   * badges.student_badges
   */
  export type badges$student_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    where?: student_badgesWhereInput
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    cursor?: student_badgesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_badgesScalarFieldEnum | Student_badgesScalarFieldEnum[]
  }

  /**
   * badges without action
   */
  export type badgesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
  }


  /**
   * Model challenge_participants
   */

  export type AggregateChallenge_participants = {
    _count: Challenge_participantsCountAggregateOutputType | null
    _avg: Challenge_participantsAvgAggregateOutputType | null
    _sum: Challenge_participantsSumAggregateOutputType | null
    _min: Challenge_participantsMinAggregateOutputType | null
    _max: Challenge_participantsMaxAggregateOutputType | null
  }

  export type Challenge_participantsAvgAggregateOutputType = {
    score: number | null
  }

  export type Challenge_participantsSumAggregateOutputType = {
    score: number | null
  }

  export type Challenge_participantsMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    studentId: string | null
    joinedAt: Date | null
    status: $Enums.ParticipantStatus | null
    result: $Enums.ParticipantResult | null
    score: number | null
    notes: string | null
    completedAt: Date | null
  }

  export type Challenge_participantsMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    studentId: string | null
    joinedAt: Date | null
    status: $Enums.ParticipantStatus | null
    result: $Enums.ParticipantResult | null
    score: number | null
    notes: string | null
    completedAt: Date | null
  }

  export type Challenge_participantsCountAggregateOutputType = {
    id: number
    challengeId: number
    studentId: number
    joinedAt: number
    status: number
    result: number
    score: number
    notes: number
    completedAt: number
    _all: number
  }


  export type Challenge_participantsAvgAggregateInputType = {
    score?: true
  }

  export type Challenge_participantsSumAggregateInputType = {
    score?: true
  }

  export type Challenge_participantsMinAggregateInputType = {
    id?: true
    challengeId?: true
    studentId?: true
    joinedAt?: true
    status?: true
    result?: true
    score?: true
    notes?: true
    completedAt?: true
  }

  export type Challenge_participantsMaxAggregateInputType = {
    id?: true
    challengeId?: true
    studentId?: true
    joinedAt?: true
    status?: true
    result?: true
    score?: true
    notes?: true
    completedAt?: true
  }

  export type Challenge_participantsCountAggregateInputType = {
    id?: true
    challengeId?: true
    studentId?: true
    joinedAt?: true
    status?: true
    result?: true
    score?: true
    notes?: true
    completedAt?: true
    _all?: true
  }

  export type Challenge_participantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenge_participants to aggregate.
     */
    where?: challenge_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_participants to fetch.
     */
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: challenge_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned challenge_participants
    **/
    _count?: true | Challenge_participantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Challenge_participantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Challenge_participantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Challenge_participantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Challenge_participantsMaxAggregateInputType
  }

  export type GetChallenge_participantsAggregateType<T extends Challenge_participantsAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge_participants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge_participants[P]>
      : GetScalarType<T[P], AggregateChallenge_participants[P]>
  }




  export type challenge_participantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challenge_participantsWhereInput
    orderBy?: challenge_participantsOrderByWithAggregationInput | challenge_participantsOrderByWithAggregationInput[]
    by: Challenge_participantsScalarFieldEnum[] | Challenge_participantsScalarFieldEnum
    having?: challenge_participantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Challenge_participantsCountAggregateInputType | true
    _avg?: Challenge_participantsAvgAggregateInputType
    _sum?: Challenge_participantsSumAggregateInputType
    _min?: Challenge_participantsMinAggregateInputType
    _max?: Challenge_participantsMaxAggregateInputType
  }

  export type Challenge_participantsGroupByOutputType = {
    id: string
    challengeId: string
    studentId: string
    joinedAt: Date
    status: $Enums.ParticipantStatus
    result: $Enums.ParticipantResult | null
    score: number | null
    notes: string | null
    completedAt: Date | null
    _count: Challenge_participantsCountAggregateOutputType | null
    _avg: Challenge_participantsAvgAggregateOutputType | null
    _sum: Challenge_participantsSumAggregateOutputType | null
    _min: Challenge_participantsMinAggregateOutputType | null
    _max: Challenge_participantsMaxAggregateOutputType | null
  }

  type GetChallenge_participantsGroupByPayload<T extends challenge_participantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Challenge_participantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Challenge_participantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Challenge_participantsGroupByOutputType[P]>
            : GetScalarType<T[P], Challenge_participantsGroupByOutputType[P]>
        }
      >
    >


  export type challenge_participantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    result?: boolean
    score?: boolean
    notes?: boolean
    completedAt?: boolean
    challenges?: boolean | challengesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge_participants"]>

  export type challenge_participantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    result?: boolean
    score?: boolean
    notes?: boolean
    completedAt?: boolean
    challenges?: boolean | challengesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge_participants"]>

  export type challenge_participantsSelectScalar = {
    id?: boolean
    challengeId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    result?: boolean
    score?: boolean
    notes?: boolean
    completedAt?: boolean
  }

  export type challenge_participantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | challengesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type challenge_participantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | challengesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $challenge_participantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "challenge_participants"
    objects: {
      challenges: Prisma.$challengesPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      studentId: string
      joinedAt: Date
      status: $Enums.ParticipantStatus
      result: $Enums.ParticipantResult | null
      score: number | null
      notes: string | null
      completedAt: Date | null
    }, ExtArgs["result"]["challenge_participants"]>
    composites: {}
  }

  type challenge_participantsGetPayload<S extends boolean | null | undefined | challenge_participantsDefaultArgs> = $Result.GetResult<Prisma.$challenge_participantsPayload, S>

  type challenge_participantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<challenge_participantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Challenge_participantsCountAggregateInputType | true
    }

  export interface challenge_participantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['challenge_participants'], meta: { name: 'challenge_participants' } }
    /**
     * Find zero or one Challenge_participants that matches the filter.
     * @param {challenge_participantsFindUniqueArgs} args - Arguments to find a Challenge_participants
     * @example
     * // Get one Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends challenge_participantsFindUniqueArgs>(args: SelectSubset<T, challenge_participantsFindUniqueArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge_participants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {challenge_participantsFindUniqueOrThrowArgs} args - Arguments to find a Challenge_participants
     * @example
     * // Get one Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends challenge_participantsFindUniqueOrThrowArgs>(args: SelectSubset<T, challenge_participantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsFindFirstArgs} args - Arguments to find a Challenge_participants
     * @example
     * // Get one Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends challenge_participantsFindFirstArgs>(args?: SelectSubset<T, challenge_participantsFindFirstArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge_participants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsFindFirstOrThrowArgs} args - Arguments to find a Challenge_participants
     * @example
     * // Get one Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends challenge_participantsFindFirstOrThrowArgs>(args?: SelectSubset<T, challenge_participantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenge_participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findMany()
     * 
     * // Get first 10 Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challenge_participantsWithIdOnly = await prisma.challenge_participants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends challenge_participantsFindManyArgs>(args?: SelectSubset<T, challenge_participantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge_participants.
     * @param {challenge_participantsCreateArgs} args - Arguments to create a Challenge_participants.
     * @example
     * // Create one Challenge_participants
     * const Challenge_participants = await prisma.challenge_participants.create({
     *   data: {
     *     // ... data to create a Challenge_participants
     *   }
     * })
     * 
     */
    create<T extends challenge_participantsCreateArgs>(args: SelectSubset<T, challenge_participantsCreateArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenge_participants.
     * @param {challenge_participantsCreateManyArgs} args - Arguments to create many Challenge_participants.
     * @example
     * // Create many Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends challenge_participantsCreateManyArgs>(args?: SelectSubset<T, challenge_participantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenge_participants and returns the data saved in the database.
     * @param {challenge_participantsCreateManyAndReturnArgs} args - Arguments to create many Challenge_participants.
     * @example
     * // Create many Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenge_participants and only return the `id`
     * const challenge_participantsWithIdOnly = await prisma.challenge_participants.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends challenge_participantsCreateManyAndReturnArgs>(args?: SelectSubset<T, challenge_participantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenge_participants.
     * @param {challenge_participantsDeleteArgs} args - Arguments to delete one Challenge_participants.
     * @example
     * // Delete one Challenge_participants
     * const Challenge_participants = await prisma.challenge_participants.delete({
     *   where: {
     *     // ... filter to delete one Challenge_participants
     *   }
     * })
     * 
     */
    delete<T extends challenge_participantsDeleteArgs>(args: SelectSubset<T, challenge_participantsDeleteArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge_participants.
     * @param {challenge_participantsUpdateArgs} args - Arguments to update one Challenge_participants.
     * @example
     * // Update one Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends challenge_participantsUpdateArgs>(args: SelectSubset<T, challenge_participantsUpdateArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenge_participants.
     * @param {challenge_participantsDeleteManyArgs} args - Arguments to filter Challenge_participants to delete.
     * @example
     * // Delete a few Challenge_participants
     * const { count } = await prisma.challenge_participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends challenge_participantsDeleteManyArgs>(args?: SelectSubset<T, challenge_participantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenge_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends challenge_participantsUpdateManyArgs>(args: SelectSubset<T, challenge_participantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge_participants.
     * @param {challenge_participantsUpsertArgs} args - Arguments to update or create a Challenge_participants.
     * @example
     * // Update or create a Challenge_participants
     * const challenge_participants = await prisma.challenge_participants.upsert({
     *   create: {
     *     // ... data to create a Challenge_participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge_participants we want to update
     *   }
     * })
     */
    upsert<T extends challenge_participantsUpsertArgs>(args: SelectSubset<T, challenge_participantsUpsertArgs<ExtArgs>>): Prisma__challenge_participantsClient<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenge_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsCountArgs} args - Arguments to filter Challenge_participants to count.
     * @example
     * // Count the number of Challenge_participants
     * const count = await prisma.challenge_participants.count({
     *   where: {
     *     // ... the filter for the Challenge_participants we want to count
     *   }
     * })
    **/
    count<T extends challenge_participantsCountArgs>(
      args?: Subset<T, challenge_participantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Challenge_participantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Challenge_participantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Challenge_participantsAggregateArgs>(args: Subset<T, Challenge_participantsAggregateArgs>): Prisma.PrismaPromise<GetChallenge_participantsAggregateType<T>>

    /**
     * Group by Challenge_participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challenge_participantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends challenge_participantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: challenge_participantsGroupByArgs['orderBy'] }
        : { orderBy?: challenge_participantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, challenge_participantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallenge_participantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the challenge_participants model
   */
  readonly fields: challenge_participantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for challenge_participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__challenge_participantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenges<T extends challengesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, challengesDefaultArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the challenge_participants model
   */ 
  interface challenge_participantsFieldRefs {
    readonly id: FieldRef<"challenge_participants", 'String'>
    readonly challengeId: FieldRef<"challenge_participants", 'String'>
    readonly studentId: FieldRef<"challenge_participants", 'String'>
    readonly joinedAt: FieldRef<"challenge_participants", 'DateTime'>
    readonly status: FieldRef<"challenge_participants", 'ParticipantStatus'>
    readonly result: FieldRef<"challenge_participants", 'ParticipantResult'>
    readonly score: FieldRef<"challenge_participants", 'Int'>
    readonly notes: FieldRef<"challenge_participants", 'String'>
    readonly completedAt: FieldRef<"challenge_participants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * challenge_participants findUnique
   */
  export type challenge_participantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter, which challenge_participants to fetch.
     */
    where: challenge_participantsWhereUniqueInput
  }

  /**
   * challenge_participants findUniqueOrThrow
   */
  export type challenge_participantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter, which challenge_participants to fetch.
     */
    where: challenge_participantsWhereUniqueInput
  }

  /**
   * challenge_participants findFirst
   */
  export type challenge_participantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter, which challenge_participants to fetch.
     */
    where?: challenge_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_participants to fetch.
     */
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenge_participants.
     */
    cursor?: challenge_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenge_participants.
     */
    distinct?: Challenge_participantsScalarFieldEnum | Challenge_participantsScalarFieldEnum[]
  }

  /**
   * challenge_participants findFirstOrThrow
   */
  export type challenge_participantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter, which challenge_participants to fetch.
     */
    where?: challenge_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_participants to fetch.
     */
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenge_participants.
     */
    cursor?: challenge_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenge_participants.
     */
    distinct?: Challenge_participantsScalarFieldEnum | Challenge_participantsScalarFieldEnum[]
  }

  /**
   * challenge_participants findMany
   */
  export type challenge_participantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter, which challenge_participants to fetch.
     */
    where?: challenge_participantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenge_participants to fetch.
     */
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing challenge_participants.
     */
    cursor?: challenge_participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenge_participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenge_participants.
     */
    skip?: number
    distinct?: Challenge_participantsScalarFieldEnum | Challenge_participantsScalarFieldEnum[]
  }

  /**
   * challenge_participants create
   */
  export type challenge_participantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * The data needed to create a challenge_participants.
     */
    data: XOR<challenge_participantsCreateInput, challenge_participantsUncheckedCreateInput>
  }

  /**
   * challenge_participants createMany
   */
  export type challenge_participantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many challenge_participants.
     */
    data: challenge_participantsCreateManyInput | challenge_participantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * challenge_participants createManyAndReturn
   */
  export type challenge_participantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many challenge_participants.
     */
    data: challenge_participantsCreateManyInput | challenge_participantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * challenge_participants update
   */
  export type challenge_participantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * The data needed to update a challenge_participants.
     */
    data: XOR<challenge_participantsUpdateInput, challenge_participantsUncheckedUpdateInput>
    /**
     * Choose, which challenge_participants to update.
     */
    where: challenge_participantsWhereUniqueInput
  }

  /**
   * challenge_participants updateMany
   */
  export type challenge_participantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update challenge_participants.
     */
    data: XOR<challenge_participantsUpdateManyMutationInput, challenge_participantsUncheckedUpdateManyInput>
    /**
     * Filter which challenge_participants to update
     */
    where?: challenge_participantsWhereInput
  }

  /**
   * challenge_participants upsert
   */
  export type challenge_participantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * The filter to search for the challenge_participants to update in case it exists.
     */
    where: challenge_participantsWhereUniqueInput
    /**
     * In case the challenge_participants found by the `where` argument doesn't exist, create a new challenge_participants with this data.
     */
    create: XOR<challenge_participantsCreateInput, challenge_participantsUncheckedCreateInput>
    /**
     * In case the challenge_participants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<challenge_participantsUpdateInput, challenge_participantsUncheckedUpdateInput>
  }

  /**
   * challenge_participants delete
   */
  export type challenge_participantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    /**
     * Filter which challenge_participants to delete.
     */
    where: challenge_participantsWhereUniqueInput
  }

  /**
   * challenge_participants deleteMany
   */
  export type challenge_participantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenge_participants to delete
     */
    where?: challenge_participantsWhereInput
  }

  /**
   * challenge_participants without action
   */
  export type challenge_participantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
  }


  /**
   * Model challenges
   */

  export type AggregateChallenges = {
    _count: ChallengesCountAggregateOutputType | null
    _avg: ChallengesAvgAggregateOutputType | null
    _sum: ChallengesSumAggregateOutputType | null
    _min: ChallengesMinAggregateOutputType | null
    _max: ChallengesMaxAggregateOutputType | null
  }

  export type ChallengesAvgAggregateOutputType = {
    rewardPoints: number | null
    rewardExp: number | null
    maxParticipants: number | null
  }

  export type ChallengesSumAggregateOutputType = {
    rewardPoints: number | null
    rewardExp: number | null
    maxParticipants: number | null
  }

  export type ChallengesMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    title: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    status: $Enums.ChallengeStatus | null
    creatorId: string | null
    startDate: Date | null
    endDate: Date | null
    rewardPoints: number | null
    rewardExp: number | null
    maxParticipants: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengesMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    title: string | null
    description: string | null
    type: $Enums.ChallengeType | null
    status: $Enums.ChallengeStatus | null
    creatorId: string | null
    startDate: Date | null
    endDate: Date | null
    rewardPoints: number | null
    rewardExp: number | null
    maxParticipants: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengesCountAggregateOutputType = {
    id: number
    schoolId: number
    title: number
    description: number
    type: number
    status: number
    creatorId: number
    startDate: number
    endDate: number
    rewardPoints: number
    rewardExp: number
    maxParticipants: number
    metadata: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengesAvgAggregateInputType = {
    rewardPoints?: true
    rewardExp?: true
    maxParticipants?: true
  }

  export type ChallengesSumAggregateInputType = {
    rewardPoints?: true
    rewardExp?: true
    maxParticipants?: true
  }

  export type ChallengesMinAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    rewardPoints?: true
    rewardExp?: true
    maxParticipants?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengesMaxAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    rewardPoints?: true
    rewardExp?: true
    maxParticipants?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengesCountAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    creatorId?: true
    startDate?: true
    endDate?: true
    rewardPoints?: true
    rewardExp?: true
    maxParticipants?: true
    metadata?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenges to aggregate.
     */
    where?: challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenges to fetch.
     */
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned challenges
    **/
    _count?: true | ChallengesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengesMaxAggregateInputType
  }

  export type GetChallengesAggregateType<T extends ChallengesAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenges[P]>
      : GetScalarType<T[P], AggregateChallenges[P]>
  }




  export type challengesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: challengesWhereInput
    orderBy?: challengesOrderByWithAggregationInput | challengesOrderByWithAggregationInput[]
    by: ChallengesScalarFieldEnum[] | ChallengesScalarFieldEnum
    having?: challengesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengesCountAggregateInputType | true
    _avg?: ChallengesAvgAggregateInputType
    _sum?: ChallengesSumAggregateInputType
    _min?: ChallengesMinAggregateInputType
    _max?: ChallengesMaxAggregateInputType
  }

  export type ChallengesGroupByOutputType = {
    id: string
    schoolId: string
    title: string
    description: string | null
    type: $Enums.ChallengeType
    status: $Enums.ChallengeStatus
    creatorId: string
    startDate: Date
    endDate: Date | null
    rewardPoints: number
    rewardExp: number
    maxParticipants: number
    metadata: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChallengesCountAggregateOutputType | null
    _avg: ChallengesAvgAggregateOutputType | null
    _sum: ChallengesSumAggregateOutputType | null
    _min: ChallengesMinAggregateOutputType | null
    _max: ChallengesMaxAggregateOutputType | null
  }

  type GetChallengesGroupByPayload<T extends challengesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengesGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengesGroupByOutputType[P]>
        }
      >
    >


  export type challengesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    rewardPoints?: boolean
    rewardExp?: boolean
    maxParticipants?: boolean
    metadata?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    challenge_participants?: boolean | challenges$challenge_participantsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | ChallengesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenges"]>

  export type challengesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    rewardPoints?: boolean
    rewardExp?: boolean
    maxParticipants?: boolean
    metadata?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenges"]>

  export type challengesSelectScalar = {
    id?: boolean
    schoolId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    creatorId?: boolean
    startDate?: boolean
    endDate?: boolean
    rewardPoints?: boolean
    rewardExp?: boolean
    maxParticipants?: boolean
    metadata?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type challengesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_participants?: boolean | challenges$challenge_participantsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | ChallengesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type challengesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $challengesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "challenges"
    objects: {
      challenge_participants: Prisma.$challenge_participantsPayload<ExtArgs>[]
      teachers: Prisma.$teachersPayload<ExtArgs>
      schools: Prisma.$schoolsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      title: string
      description: string | null
      type: $Enums.ChallengeType
      status: $Enums.ChallengeStatus
      creatorId: string
      startDate: Date
      endDate: Date | null
      rewardPoints: number
      rewardExp: number
      maxParticipants: number
      metadata: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challenges"]>
    composites: {}
  }

  type challengesGetPayload<S extends boolean | null | undefined | challengesDefaultArgs> = $Result.GetResult<Prisma.$challengesPayload, S>

  type challengesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<challengesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengesCountAggregateInputType | true
    }

  export interface challengesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['challenges'], meta: { name: 'challenges' } }
    /**
     * Find zero or one Challenges that matches the filter.
     * @param {challengesFindUniqueArgs} args - Arguments to find a Challenges
     * @example
     * // Get one Challenges
     * const challenges = await prisma.challenges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends challengesFindUniqueArgs>(args: SelectSubset<T, challengesFindUniqueArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenges that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {challengesFindUniqueOrThrowArgs} args - Arguments to find a Challenges
     * @example
     * // Get one Challenges
     * const challenges = await prisma.challenges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends challengesFindUniqueOrThrowArgs>(args: SelectSubset<T, challengesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesFindFirstArgs} args - Arguments to find a Challenges
     * @example
     * // Get one Challenges
     * const challenges = await prisma.challenges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends challengesFindFirstArgs>(args?: SelectSubset<T, challengesFindFirstArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesFindFirstOrThrowArgs} args - Arguments to find a Challenges
     * @example
     * // Get one Challenges
     * const challenges = await prisma.challenges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends challengesFindFirstOrThrowArgs>(args?: SelectSubset<T, challengesFindFirstOrThrowArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenges.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengesWithIdOnly = await prisma.challenges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends challengesFindManyArgs>(args?: SelectSubset<T, challengesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenges.
     * @param {challengesCreateArgs} args - Arguments to create a Challenges.
     * @example
     * // Create one Challenges
     * const Challenges = await prisma.challenges.create({
     *   data: {
     *     // ... data to create a Challenges
     *   }
     * })
     * 
     */
    create<T extends challengesCreateArgs>(args: SelectSubset<T, challengesCreateArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {challengesCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenges = await prisma.challenges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends challengesCreateManyArgs>(args?: SelectSubset<T, challengesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {challengesCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenges = await prisma.challenges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengesWithIdOnly = await prisma.challenges.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends challengesCreateManyAndReturnArgs>(args?: SelectSubset<T, challengesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenges.
     * @param {challengesDeleteArgs} args - Arguments to delete one Challenges.
     * @example
     * // Delete one Challenges
     * const Challenges = await prisma.challenges.delete({
     *   where: {
     *     // ... filter to delete one Challenges
     *   }
     * })
     * 
     */
    delete<T extends challengesDeleteArgs>(args: SelectSubset<T, challengesDeleteArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenges.
     * @param {challengesUpdateArgs} args - Arguments to update one Challenges.
     * @example
     * // Update one Challenges
     * const challenges = await prisma.challenges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends challengesUpdateArgs>(args: SelectSubset<T, challengesUpdateArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {challengesDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends challengesDeleteManyArgs>(args?: SelectSubset<T, challengesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenges = await prisma.challenges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends challengesUpdateManyArgs>(args: SelectSubset<T, challengesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenges.
     * @param {challengesUpsertArgs} args - Arguments to update or create a Challenges.
     * @example
     * // Update or create a Challenges
     * const challenges = await prisma.challenges.upsert({
     *   create: {
     *     // ... data to create a Challenges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenges we want to update
     *   }
     * })
     */
    upsert<T extends challengesUpsertArgs>(args: SelectSubset<T, challengesUpsertArgs<ExtArgs>>): Prisma__challengesClient<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenges.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends challengesCountArgs>(
      args?: Subset<T, challengesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengesAggregateArgs>(args: Subset<T, ChallengesAggregateArgs>): Prisma.PrismaPromise<GetChallengesAggregateType<T>>

    /**
     * Group by Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {challengesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends challengesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: challengesGroupByArgs['orderBy'] }
        : { orderBy?: challengesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, challengesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the challenges model
   */
  readonly fields: challengesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for challenges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__challengesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge_participants<T extends challenges$challenge_participantsArgs<ExtArgs> = {}>(args?: Subset<T, challenges$challenge_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the challenges model
   */ 
  interface challengesFieldRefs {
    readonly id: FieldRef<"challenges", 'String'>
    readonly schoolId: FieldRef<"challenges", 'String'>
    readonly title: FieldRef<"challenges", 'String'>
    readonly description: FieldRef<"challenges", 'String'>
    readonly type: FieldRef<"challenges", 'ChallengeType'>
    readonly status: FieldRef<"challenges", 'ChallengeStatus'>
    readonly creatorId: FieldRef<"challenges", 'String'>
    readonly startDate: FieldRef<"challenges", 'DateTime'>
    readonly endDate: FieldRef<"challenges", 'DateTime'>
    readonly rewardPoints: FieldRef<"challenges", 'Int'>
    readonly rewardExp: FieldRef<"challenges", 'Int'>
    readonly maxParticipants: FieldRef<"challenges", 'Int'>
    readonly metadata: FieldRef<"challenges", 'Json'>
    readonly isActive: FieldRef<"challenges", 'Boolean'>
    readonly createdAt: FieldRef<"challenges", 'DateTime'>
    readonly updatedAt: FieldRef<"challenges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * challenges findUnique
   */
  export type challengesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter, which challenges to fetch.
     */
    where: challengesWhereUniqueInput
  }

  /**
   * challenges findUniqueOrThrow
   */
  export type challengesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter, which challenges to fetch.
     */
    where: challengesWhereUniqueInput
  }

  /**
   * challenges findFirst
   */
  export type challengesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter, which challenges to fetch.
     */
    where?: challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenges to fetch.
     */
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenges.
     */
    cursor?: challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenges.
     */
    distinct?: ChallengesScalarFieldEnum | ChallengesScalarFieldEnum[]
  }

  /**
   * challenges findFirstOrThrow
   */
  export type challengesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter, which challenges to fetch.
     */
    where?: challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenges to fetch.
     */
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for challenges.
     */
    cursor?: challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of challenges.
     */
    distinct?: ChallengesScalarFieldEnum | ChallengesScalarFieldEnum[]
  }

  /**
   * challenges findMany
   */
  export type challengesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter, which challenges to fetch.
     */
    where?: challengesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of challenges to fetch.
     */
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing challenges.
     */
    cursor?: challengesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` challenges.
     */
    skip?: number
    distinct?: ChallengesScalarFieldEnum | ChallengesScalarFieldEnum[]
  }

  /**
   * challenges create
   */
  export type challengesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * The data needed to create a challenges.
     */
    data: XOR<challengesCreateInput, challengesUncheckedCreateInput>
  }

  /**
   * challenges createMany
   */
  export type challengesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many challenges.
     */
    data: challengesCreateManyInput | challengesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * challenges createManyAndReturn
   */
  export type challengesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many challenges.
     */
    data: challengesCreateManyInput | challengesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * challenges update
   */
  export type challengesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * The data needed to update a challenges.
     */
    data: XOR<challengesUpdateInput, challengesUncheckedUpdateInput>
    /**
     * Choose, which challenges to update.
     */
    where: challengesWhereUniqueInput
  }

  /**
   * challenges updateMany
   */
  export type challengesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update challenges.
     */
    data: XOR<challengesUpdateManyMutationInput, challengesUncheckedUpdateManyInput>
    /**
     * Filter which challenges to update
     */
    where?: challengesWhereInput
  }

  /**
   * challenges upsert
   */
  export type challengesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * The filter to search for the challenges to update in case it exists.
     */
    where: challengesWhereUniqueInput
    /**
     * In case the challenges found by the `where` argument doesn't exist, create a new challenges with this data.
     */
    create: XOR<challengesCreateInput, challengesUncheckedCreateInput>
    /**
     * In case the challenges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<challengesUpdateInput, challengesUncheckedUpdateInput>
  }

  /**
   * challenges delete
   */
  export type challengesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    /**
     * Filter which challenges to delete.
     */
    where: challengesWhereUniqueInput
  }

  /**
   * challenges deleteMany
   */
  export type challengesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which challenges to delete
     */
    where?: challengesWhereInput
  }

  /**
   * challenges.challenge_participants
   */
  export type challenges$challenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    where?: challenge_participantsWhereInput
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    cursor?: challenge_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Challenge_participantsScalarFieldEnum | Challenge_participantsScalarFieldEnum[]
  }

  /**
   * challenges without action
   */
  export type challengesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
  }


  /**
   * Model habit_logs
   */

  export type AggregateHabit_logs = {
    _count: Habit_logsCountAggregateOutputType | null
    _avg: Habit_logsAvgAggregateOutputType | null
    _sum: Habit_logsSumAggregateOutputType | null
    _min: Habit_logsMinAggregateOutputType | null
    _max: Habit_logsMaxAggregateOutputType | null
  }

  export type Habit_logsAvgAggregateOutputType = {
    streakDays: number | null
  }

  export type Habit_logsSumAggregateOutputType = {
    streakDays: number | null
  }

  export type Habit_logsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    habitId: string | null
    studentId: string | null
    checkedAt: Date | null
    streakDays: number | null
    notes: string | null
  }

  export type Habit_logsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    habitId: string | null
    studentId: string | null
    checkedAt: Date | null
    streakDays: number | null
    notes: string | null
  }

  export type Habit_logsCountAggregateOutputType = {
    id: number
    schoolId: number
    habitId: number
    studentId: number
    checkedAt: number
    streakDays: number
    notes: number
    _all: number
  }


  export type Habit_logsAvgAggregateInputType = {
    streakDays?: true
  }

  export type Habit_logsSumAggregateInputType = {
    streakDays?: true
  }

  export type Habit_logsMinAggregateInputType = {
    id?: true
    schoolId?: true
    habitId?: true
    studentId?: true
    checkedAt?: true
    streakDays?: true
    notes?: true
  }

  export type Habit_logsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    habitId?: true
    studentId?: true
    checkedAt?: true
    streakDays?: true
    notes?: true
  }

  export type Habit_logsCountAggregateInputType = {
    id?: true
    schoolId?: true
    habitId?: true
    studentId?: true
    checkedAt?: true
    streakDays?: true
    notes?: true
    _all?: true
  }

  export type Habit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habit_logs to aggregate.
     */
    where?: habit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habit_logs to fetch.
     */
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: habit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned habit_logs
    **/
    _count?: true | Habit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Habit_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Habit_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Habit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Habit_logsMaxAggregateInputType
  }

  export type GetHabit_logsAggregateType<T extends Habit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateHabit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabit_logs[P]>
      : GetScalarType<T[P], AggregateHabit_logs[P]>
  }




  export type habit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habit_logsWhereInput
    orderBy?: habit_logsOrderByWithAggregationInput | habit_logsOrderByWithAggregationInput[]
    by: Habit_logsScalarFieldEnum[] | Habit_logsScalarFieldEnum
    having?: habit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Habit_logsCountAggregateInputType | true
    _avg?: Habit_logsAvgAggregateInputType
    _sum?: Habit_logsSumAggregateInputType
    _min?: Habit_logsMinAggregateInputType
    _max?: Habit_logsMaxAggregateInputType
  }

  export type Habit_logsGroupByOutputType = {
    id: string
    schoolId: string
    habitId: string
    studentId: string
    checkedAt: Date
    streakDays: number
    notes: string | null
    _count: Habit_logsCountAggregateOutputType | null
    _avg: Habit_logsAvgAggregateOutputType | null
    _sum: Habit_logsSumAggregateOutputType | null
    _min: Habit_logsMinAggregateOutputType | null
    _max: Habit_logsMaxAggregateOutputType | null
  }

  type GetHabit_logsGroupByPayload<T extends habit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Habit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Habit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Habit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Habit_logsGroupByOutputType[P]>
        }
      >
    >


  export type habit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    habitId?: boolean
    studentId?: boolean
    checkedAt?: boolean
    streakDays?: boolean
    notes?: boolean
    habits?: boolean | habitsDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit_logs"]>

  export type habit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    habitId?: boolean
    studentId?: boolean
    checkedAt?: boolean
    streakDays?: boolean
    notes?: boolean
    habits?: boolean | habitsDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habit_logs"]>

  export type habit_logsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    habitId?: boolean
    studentId?: boolean
    checkedAt?: boolean
    streakDays?: boolean
    notes?: boolean
  }

  export type habit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habits?: boolean | habitsDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type habit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habits?: boolean | habitsDefaultArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $habit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "habit_logs"
    objects: {
      habits: Prisma.$habitsPayload<ExtArgs>
      schools: Prisma.$schoolsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      habitId: string
      studentId: string
      checkedAt: Date
      streakDays: number
      notes: string | null
    }, ExtArgs["result"]["habit_logs"]>
    composites: {}
  }

  type habit_logsGetPayload<S extends boolean | null | undefined | habit_logsDefaultArgs> = $Result.GetResult<Prisma.$habit_logsPayload, S>

  type habit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<habit_logsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Habit_logsCountAggregateInputType | true
    }

  export interface habit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['habit_logs'], meta: { name: 'habit_logs' } }
    /**
     * Find zero or one Habit_logs that matches the filter.
     * @param {habit_logsFindUniqueArgs} args - Arguments to find a Habit_logs
     * @example
     * // Get one Habit_logs
     * const habit_logs = await prisma.habit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends habit_logsFindUniqueArgs>(args: SelectSubset<T, habit_logsFindUniqueArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Habit_logs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {habit_logsFindUniqueOrThrowArgs} args - Arguments to find a Habit_logs
     * @example
     * // Get one Habit_logs
     * const habit_logs = await prisma.habit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends habit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, habit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Habit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsFindFirstArgs} args - Arguments to find a Habit_logs
     * @example
     * // Get one Habit_logs
     * const habit_logs = await prisma.habit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends habit_logsFindFirstArgs>(args?: SelectSubset<T, habit_logsFindFirstArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Habit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsFindFirstOrThrowArgs} args - Arguments to find a Habit_logs
     * @example
     * // Get one Habit_logs
     * const habit_logs = await prisma.habit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends habit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, habit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Habit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Habit_logs
     * const habit_logs = await prisma.habit_logs.findMany()
     * 
     * // Get first 10 Habit_logs
     * const habit_logs = await prisma.habit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habit_logsWithIdOnly = await prisma.habit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends habit_logsFindManyArgs>(args?: SelectSubset<T, habit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Habit_logs.
     * @param {habit_logsCreateArgs} args - Arguments to create a Habit_logs.
     * @example
     * // Create one Habit_logs
     * const Habit_logs = await prisma.habit_logs.create({
     *   data: {
     *     // ... data to create a Habit_logs
     *   }
     * })
     * 
     */
    create<T extends habit_logsCreateArgs>(args: SelectSubset<T, habit_logsCreateArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Habit_logs.
     * @param {habit_logsCreateManyArgs} args - Arguments to create many Habit_logs.
     * @example
     * // Create many Habit_logs
     * const habit_logs = await prisma.habit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends habit_logsCreateManyArgs>(args?: SelectSubset<T, habit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Habit_logs and returns the data saved in the database.
     * @param {habit_logsCreateManyAndReturnArgs} args - Arguments to create many Habit_logs.
     * @example
     * // Create many Habit_logs
     * const habit_logs = await prisma.habit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Habit_logs and only return the `id`
     * const habit_logsWithIdOnly = await prisma.habit_logs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends habit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, habit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Habit_logs.
     * @param {habit_logsDeleteArgs} args - Arguments to delete one Habit_logs.
     * @example
     * // Delete one Habit_logs
     * const Habit_logs = await prisma.habit_logs.delete({
     *   where: {
     *     // ... filter to delete one Habit_logs
     *   }
     * })
     * 
     */
    delete<T extends habit_logsDeleteArgs>(args: SelectSubset<T, habit_logsDeleteArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Habit_logs.
     * @param {habit_logsUpdateArgs} args - Arguments to update one Habit_logs.
     * @example
     * // Update one Habit_logs
     * const habit_logs = await prisma.habit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends habit_logsUpdateArgs>(args: SelectSubset<T, habit_logsUpdateArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Habit_logs.
     * @param {habit_logsDeleteManyArgs} args - Arguments to filter Habit_logs to delete.
     * @example
     * // Delete a few Habit_logs
     * const { count } = await prisma.habit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends habit_logsDeleteManyArgs>(args?: SelectSubset<T, habit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Habit_logs
     * const habit_logs = await prisma.habit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends habit_logsUpdateManyArgs>(args: SelectSubset<T, habit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Habit_logs.
     * @param {habit_logsUpsertArgs} args - Arguments to update or create a Habit_logs.
     * @example
     * // Update or create a Habit_logs
     * const habit_logs = await prisma.habit_logs.upsert({
     *   create: {
     *     // ... data to create a Habit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Habit_logs we want to update
     *   }
     * })
     */
    upsert<T extends habit_logsUpsertArgs>(args: SelectSubset<T, habit_logsUpsertArgs<ExtArgs>>): Prisma__habit_logsClient<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Habit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsCountArgs} args - Arguments to filter Habit_logs to count.
     * @example
     * // Count the number of Habit_logs
     * const count = await prisma.habit_logs.count({
     *   where: {
     *     // ... the filter for the Habit_logs we want to count
     *   }
     * })
    **/
    count<T extends habit_logsCountArgs>(
      args?: Subset<T, habit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Habit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Habit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Habit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Habit_logsAggregateArgs>(args: Subset<T, Habit_logsAggregateArgs>): Prisma.PrismaPromise<GetHabit_logsAggregateType<T>>

    /**
     * Group by Habit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends habit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: habit_logsGroupByArgs['orderBy'] }
        : { orderBy?: habit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, habit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the habit_logs model
   */
  readonly fields: habit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for habit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__habit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habits<T extends habitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, habitsDefaultArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the habit_logs model
   */ 
  interface habit_logsFieldRefs {
    readonly id: FieldRef<"habit_logs", 'String'>
    readonly schoolId: FieldRef<"habit_logs", 'String'>
    readonly habitId: FieldRef<"habit_logs", 'String'>
    readonly studentId: FieldRef<"habit_logs", 'String'>
    readonly checkedAt: FieldRef<"habit_logs", 'DateTime'>
    readonly streakDays: FieldRef<"habit_logs", 'Int'>
    readonly notes: FieldRef<"habit_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * habit_logs findUnique
   */
  export type habit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter, which habit_logs to fetch.
     */
    where: habit_logsWhereUniqueInput
  }

  /**
   * habit_logs findUniqueOrThrow
   */
  export type habit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter, which habit_logs to fetch.
     */
    where: habit_logsWhereUniqueInput
  }

  /**
   * habit_logs findFirst
   */
  export type habit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter, which habit_logs to fetch.
     */
    where?: habit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habit_logs to fetch.
     */
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habit_logs.
     */
    cursor?: habit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habit_logs.
     */
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * habit_logs findFirstOrThrow
   */
  export type habit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter, which habit_logs to fetch.
     */
    where?: habit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habit_logs to fetch.
     */
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habit_logs.
     */
    cursor?: habit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habit_logs.
     */
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * habit_logs findMany
   */
  export type habit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter, which habit_logs to fetch.
     */
    where?: habit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habit_logs to fetch.
     */
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing habit_logs.
     */
    cursor?: habit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habit_logs.
     */
    skip?: number
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * habit_logs create
   */
  export type habit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a habit_logs.
     */
    data: XOR<habit_logsCreateInput, habit_logsUncheckedCreateInput>
  }

  /**
   * habit_logs createMany
   */
  export type habit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many habit_logs.
     */
    data: habit_logsCreateManyInput | habit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * habit_logs createManyAndReturn
   */
  export type habit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many habit_logs.
     */
    data: habit_logsCreateManyInput | habit_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * habit_logs update
   */
  export type habit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a habit_logs.
     */
    data: XOR<habit_logsUpdateInput, habit_logsUncheckedUpdateInput>
    /**
     * Choose, which habit_logs to update.
     */
    where: habit_logsWhereUniqueInput
  }

  /**
   * habit_logs updateMany
   */
  export type habit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update habit_logs.
     */
    data: XOR<habit_logsUpdateManyMutationInput, habit_logsUncheckedUpdateManyInput>
    /**
     * Filter which habit_logs to update
     */
    where?: habit_logsWhereInput
  }

  /**
   * habit_logs upsert
   */
  export type habit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the habit_logs to update in case it exists.
     */
    where: habit_logsWhereUniqueInput
    /**
     * In case the habit_logs found by the `where` argument doesn't exist, create a new habit_logs with this data.
     */
    create: XOR<habit_logsCreateInput, habit_logsUncheckedCreateInput>
    /**
     * In case the habit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<habit_logsUpdateInput, habit_logsUncheckedUpdateInput>
  }

  /**
   * habit_logs delete
   */
  export type habit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    /**
     * Filter which habit_logs to delete.
     */
    where: habit_logsWhereUniqueInput
  }

  /**
   * habit_logs deleteMany
   */
  export type habit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habit_logs to delete
     */
    where?: habit_logsWhereInput
  }

  /**
   * habit_logs without action
   */
  export type habit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
  }


  /**
   * Model habits
   */

  export type AggregateHabits = {
    _count: HabitsCountAggregateOutputType | null
    _avg: HabitsAvgAggregateOutputType | null
    _sum: HabitsSumAggregateOutputType | null
    _min: HabitsMinAggregateOutputType | null
    _max: HabitsMaxAggregateOutputType | null
  }

  export type HabitsAvgAggregateOutputType = {
    expReward: number | null
    pointsReward: number | null
  }

  export type HabitsSumAggregateOutputType = {
    expReward: number | null
    pointsReward: number | null
  }

  export type HabitsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    icon: string | null
    expReward: number | null
    pointsReward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    description: string | null
    icon: string | null
    expReward: number | null
    pointsReward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HabitsCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    description: number
    icon: number
    expReward: number
    pointsReward: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HabitsAvgAggregateInputType = {
    expReward?: true
    pointsReward?: true
  }

  export type HabitsSumAggregateInputType = {
    expReward?: true
    pointsReward?: true
  }

  export type HabitsMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    expReward?: true
    pointsReward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    expReward?: true
    pointsReward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HabitsCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    icon?: true
    expReward?: true
    pointsReward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HabitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habits to aggregate.
     */
    where?: habitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habits to fetch.
     */
    orderBy?: habitsOrderByWithRelationInput | habitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: habitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned habits
    **/
    _count?: true | HabitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabitsMaxAggregateInputType
  }

  export type GetHabitsAggregateType<T extends HabitsAggregateArgs> = {
        [P in keyof T & keyof AggregateHabits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabits[P]>
      : GetScalarType<T[P], AggregateHabits[P]>
  }




  export type habitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habitsWhereInput
    orderBy?: habitsOrderByWithAggregationInput | habitsOrderByWithAggregationInput[]
    by: HabitsScalarFieldEnum[] | HabitsScalarFieldEnum
    having?: habitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabitsCountAggregateInputType | true
    _avg?: HabitsAvgAggregateInputType
    _sum?: HabitsSumAggregateInputType
    _min?: HabitsMinAggregateInputType
    _max?: HabitsMaxAggregateInputType
  }

  export type HabitsGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    description: string | null
    icon: string | null
    expReward: number
    pointsReward: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HabitsCountAggregateOutputType | null
    _avg: HabitsAvgAggregateOutputType | null
    _sum: HabitsSumAggregateOutputType | null
    _min: HabitsMinAggregateOutputType | null
    _max: HabitsMaxAggregateOutputType | null
  }

  type GetHabitsGroupByPayload<T extends habitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabitsGroupByOutputType[P]>
            : GetScalarType<T[P], HabitsGroupByOutputType[P]>
        }
      >
    >


  export type habitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    expReward?: boolean
    pointsReward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    habit_logs?: boolean | habits$habit_logsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | HabitsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habits"]>

  export type habitsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    expReward?: boolean
    pointsReward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habits"]>

  export type habitsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    expReward?: boolean
    pointsReward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type habitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habit_logs?: boolean | habits$habit_logsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | HabitsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type habitsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $habitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "habits"
    objects: {
      habit_logs: Prisma.$habit_logsPayload<ExtArgs>[]
      schools: Prisma.$schoolsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      description: string | null
      icon: string | null
      expReward: number
      pointsReward: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["habits"]>
    composites: {}
  }

  type habitsGetPayload<S extends boolean | null | undefined | habitsDefaultArgs> = $Result.GetResult<Prisma.$habitsPayload, S>

  type habitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<habitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabitsCountAggregateInputType | true
    }

  export interface habitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['habits'], meta: { name: 'habits' } }
    /**
     * Find zero or one Habits that matches the filter.
     * @param {habitsFindUniqueArgs} args - Arguments to find a Habits
     * @example
     * // Get one Habits
     * const habits = await prisma.habits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends habitsFindUniqueArgs>(args: SelectSubset<T, habitsFindUniqueArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Habits that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {habitsFindUniqueOrThrowArgs} args - Arguments to find a Habits
     * @example
     * // Get one Habits
     * const habits = await prisma.habits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends habitsFindUniqueOrThrowArgs>(args: SelectSubset<T, habitsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Habits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsFindFirstArgs} args - Arguments to find a Habits
     * @example
     * // Get one Habits
     * const habits = await prisma.habits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends habitsFindFirstArgs>(args?: SelectSubset<T, habitsFindFirstArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Habits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsFindFirstOrThrowArgs} args - Arguments to find a Habits
     * @example
     * // Get one Habits
     * const habits = await prisma.habits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends habitsFindFirstOrThrowArgs>(args?: SelectSubset<T, habitsFindFirstOrThrowArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Habits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Habits
     * const habits = await prisma.habits.findMany()
     * 
     * // Get first 10 Habits
     * const habits = await prisma.habits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const habitsWithIdOnly = await prisma.habits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends habitsFindManyArgs>(args?: SelectSubset<T, habitsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Habits.
     * @param {habitsCreateArgs} args - Arguments to create a Habits.
     * @example
     * // Create one Habits
     * const Habits = await prisma.habits.create({
     *   data: {
     *     // ... data to create a Habits
     *   }
     * })
     * 
     */
    create<T extends habitsCreateArgs>(args: SelectSubset<T, habitsCreateArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Habits.
     * @param {habitsCreateManyArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habits = await prisma.habits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends habitsCreateManyArgs>(args?: SelectSubset<T, habitsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Habits and returns the data saved in the database.
     * @param {habitsCreateManyAndReturnArgs} args - Arguments to create many Habits.
     * @example
     * // Create many Habits
     * const habits = await prisma.habits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Habits and only return the `id`
     * const habitsWithIdOnly = await prisma.habits.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends habitsCreateManyAndReturnArgs>(args?: SelectSubset<T, habitsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Habits.
     * @param {habitsDeleteArgs} args - Arguments to delete one Habits.
     * @example
     * // Delete one Habits
     * const Habits = await prisma.habits.delete({
     *   where: {
     *     // ... filter to delete one Habits
     *   }
     * })
     * 
     */
    delete<T extends habitsDeleteArgs>(args: SelectSubset<T, habitsDeleteArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Habits.
     * @param {habitsUpdateArgs} args - Arguments to update one Habits.
     * @example
     * // Update one Habits
     * const habits = await prisma.habits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends habitsUpdateArgs>(args: SelectSubset<T, habitsUpdateArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Habits.
     * @param {habitsDeleteManyArgs} args - Arguments to filter Habits to delete.
     * @example
     * // Delete a few Habits
     * const { count } = await prisma.habits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends habitsDeleteManyArgs>(args?: SelectSubset<T, habitsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Habits
     * const habits = await prisma.habits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends habitsUpdateManyArgs>(args: SelectSubset<T, habitsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Habits.
     * @param {habitsUpsertArgs} args - Arguments to update or create a Habits.
     * @example
     * // Update or create a Habits
     * const habits = await prisma.habits.upsert({
     *   create: {
     *     // ... data to create a Habits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Habits we want to update
     *   }
     * })
     */
    upsert<T extends habitsUpsertArgs>(args: SelectSubset<T, habitsUpsertArgs<ExtArgs>>): Prisma__habitsClient<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsCountArgs} args - Arguments to filter Habits to count.
     * @example
     * // Count the number of Habits
     * const count = await prisma.habits.count({
     *   where: {
     *     // ... the filter for the Habits we want to count
     *   }
     * })
    **/
    count<T extends habitsCountArgs>(
      args?: Subset<T, habitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabitsAggregateArgs>(args: Subset<T, HabitsAggregateArgs>): Prisma.PrismaPromise<GetHabitsAggregateType<T>>

    /**
     * Group by Habits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends habitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: habitsGroupByArgs['orderBy'] }
        : { orderBy?: habitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, habitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the habits model
   */
  readonly fields: habitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for habits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__habitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habit_logs<T extends habits$habit_logsArgs<ExtArgs> = {}>(args?: Subset<T, habits$habit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findMany"> | Null>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the habits model
   */ 
  interface habitsFieldRefs {
    readonly id: FieldRef<"habits", 'String'>
    readonly schoolId: FieldRef<"habits", 'String'>
    readonly name: FieldRef<"habits", 'String'>
    readonly description: FieldRef<"habits", 'String'>
    readonly icon: FieldRef<"habits", 'String'>
    readonly expReward: FieldRef<"habits", 'Int'>
    readonly pointsReward: FieldRef<"habits", 'Int'>
    readonly isActive: FieldRef<"habits", 'Boolean'>
    readonly createdAt: FieldRef<"habits", 'DateTime'>
    readonly updatedAt: FieldRef<"habits", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * habits findUnique
   */
  export type habitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter, which habits to fetch.
     */
    where: habitsWhereUniqueInput
  }

  /**
   * habits findUniqueOrThrow
   */
  export type habitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter, which habits to fetch.
     */
    where: habitsWhereUniqueInput
  }

  /**
   * habits findFirst
   */
  export type habitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter, which habits to fetch.
     */
    where?: habitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habits to fetch.
     */
    orderBy?: habitsOrderByWithRelationInput | habitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habits.
     */
    cursor?: habitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habits.
     */
    distinct?: HabitsScalarFieldEnum | HabitsScalarFieldEnum[]
  }

  /**
   * habits findFirstOrThrow
   */
  export type habitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter, which habits to fetch.
     */
    where?: habitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habits to fetch.
     */
    orderBy?: habitsOrderByWithRelationInput | habitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habits.
     */
    cursor?: habitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habits.
     */
    distinct?: HabitsScalarFieldEnum | HabitsScalarFieldEnum[]
  }

  /**
   * habits findMany
   */
  export type habitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter, which habits to fetch.
     */
    where?: habitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habits to fetch.
     */
    orderBy?: habitsOrderByWithRelationInput | habitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing habits.
     */
    cursor?: habitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habits.
     */
    skip?: number
    distinct?: HabitsScalarFieldEnum | HabitsScalarFieldEnum[]
  }

  /**
   * habits create
   */
  export type habitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * The data needed to create a habits.
     */
    data: XOR<habitsCreateInput, habitsUncheckedCreateInput>
  }

  /**
   * habits createMany
   */
  export type habitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many habits.
     */
    data: habitsCreateManyInput | habitsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * habits createManyAndReturn
   */
  export type habitsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many habits.
     */
    data: habitsCreateManyInput | habitsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * habits update
   */
  export type habitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * The data needed to update a habits.
     */
    data: XOR<habitsUpdateInput, habitsUncheckedUpdateInput>
    /**
     * Choose, which habits to update.
     */
    where: habitsWhereUniqueInput
  }

  /**
   * habits updateMany
   */
  export type habitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update habits.
     */
    data: XOR<habitsUpdateManyMutationInput, habitsUncheckedUpdateManyInput>
    /**
     * Filter which habits to update
     */
    where?: habitsWhereInput
  }

  /**
   * habits upsert
   */
  export type habitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * The filter to search for the habits to update in case it exists.
     */
    where: habitsWhereUniqueInput
    /**
     * In case the habits found by the `where` argument doesn't exist, create a new habits with this data.
     */
    create: XOR<habitsCreateInput, habitsUncheckedCreateInput>
    /**
     * In case the habits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<habitsUpdateInput, habitsUncheckedUpdateInput>
  }

  /**
   * habits delete
   */
  export type habitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    /**
     * Filter which habits to delete.
     */
    where: habitsWhereUniqueInput
  }

  /**
   * habits deleteMany
   */
  export type habitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habits to delete
     */
    where?: habitsWhereInput
  }

  /**
   * habits.habit_logs
   */
  export type habits$habit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    where?: habit_logsWhereInput
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    cursor?: habit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * habits without action
   */
  export type habitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
  }


  /**
   * Model lesson_plans
   */

  export type AggregateLesson_plans = {
    _count: Lesson_plansCountAggregateOutputType | null
    _min: Lesson_plansMinAggregateOutputType | null
    _max: Lesson_plansMaxAggregateOutputType | null
  }

  export type Lesson_plansMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    teacherId: string | null
    title: string | null
    date: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isGlobal: boolean | null
  }

  export type Lesson_plansMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    teacherId: string | null
    title: string | null
    date: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    isGlobal: boolean | null
  }

  export type Lesson_plansCountAggregateOutputType = {
    id: number
    schoolId: number
    teacherId: number
    title: number
    content: number
    date: number
    isActive: number
    createdAt: number
    updatedAt: number
    isGlobal: number
    _all: number
  }


  export type Lesson_plansMinAggregateInputType = {
    id?: true
    schoolId?: true
    teacherId?: true
    title?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isGlobal?: true
  }

  export type Lesson_plansMaxAggregateInputType = {
    id?: true
    schoolId?: true
    teacherId?: true
    title?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isGlobal?: true
  }

  export type Lesson_plansCountAggregateInputType = {
    id?: true
    schoolId?: true
    teacherId?: true
    title?: true
    content?: true
    date?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    isGlobal?: true
    _all?: true
  }

  export type Lesson_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lesson_plans to aggregate.
     */
    where?: lesson_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lesson_plans to fetch.
     */
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lesson_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lesson_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lesson_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lesson_plans
    **/
    _count?: true | Lesson_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lesson_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lesson_plansMaxAggregateInputType
  }

  export type GetLesson_plansAggregateType<T extends Lesson_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson_plans[P]>
      : GetScalarType<T[P], AggregateLesson_plans[P]>
  }




  export type lesson_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lesson_plansWhereInput
    orderBy?: lesson_plansOrderByWithAggregationInput | lesson_plansOrderByWithAggregationInput[]
    by: Lesson_plansScalarFieldEnum[] | Lesson_plansScalarFieldEnum
    having?: lesson_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lesson_plansCountAggregateInputType | true
    _min?: Lesson_plansMinAggregateInputType
    _max?: Lesson_plansMaxAggregateInputType
  }

  export type Lesson_plansGroupByOutputType = {
    id: string
    schoolId: string
    teacherId: string
    title: string
    content: JsonValue
    date: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    isGlobal: boolean
    _count: Lesson_plansCountAggregateOutputType | null
    _min: Lesson_plansMinAggregateOutputType | null
    _max: Lesson_plansMaxAggregateOutputType | null
  }

  type GetLesson_plansGroupByPayload<T extends lesson_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lesson_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lesson_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lesson_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Lesson_plansGroupByOutputType[P]>
        }
      >
    >


  export type lesson_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    teacherId?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGlobal?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    task_records?: boolean | lesson_plans$task_recordsArgs<ExtArgs>
    _count?: boolean | Lesson_plansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson_plans"]>

  export type lesson_plansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    teacherId?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGlobal?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson_plans"]>

  export type lesson_plansSelectScalar = {
    id?: boolean
    schoolId?: boolean
    teacherId?: boolean
    title?: boolean
    content?: boolean
    date?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isGlobal?: boolean
  }

  export type lesson_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
    task_records?: boolean | lesson_plans$task_recordsArgs<ExtArgs>
    _count?: boolean | Lesson_plansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type lesson_plansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $lesson_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lesson_plans"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
      task_records: Prisma.$task_recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      teacherId: string
      title: string
      content: Prisma.JsonValue
      date: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      isGlobal: boolean
    }, ExtArgs["result"]["lesson_plans"]>
    composites: {}
  }

  type lesson_plansGetPayload<S extends boolean | null | undefined | lesson_plansDefaultArgs> = $Result.GetResult<Prisma.$lesson_plansPayload, S>

  type lesson_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lesson_plansFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Lesson_plansCountAggregateInputType | true
    }

  export interface lesson_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lesson_plans'], meta: { name: 'lesson_plans' } }
    /**
     * Find zero or one Lesson_plans that matches the filter.
     * @param {lesson_plansFindUniqueArgs} args - Arguments to find a Lesson_plans
     * @example
     * // Get one Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lesson_plansFindUniqueArgs>(args: SelectSubset<T, lesson_plansFindUniqueArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lesson_plans that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {lesson_plansFindUniqueOrThrowArgs} args - Arguments to find a Lesson_plans
     * @example
     * // Get one Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lesson_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, lesson_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lesson_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansFindFirstArgs} args - Arguments to find a Lesson_plans
     * @example
     * // Get one Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lesson_plansFindFirstArgs>(args?: SelectSubset<T, lesson_plansFindFirstArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lesson_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansFindFirstOrThrowArgs} args - Arguments to find a Lesson_plans
     * @example
     * // Get one Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lesson_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, lesson_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lesson_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findMany()
     * 
     * // Get first 10 Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lesson_plansWithIdOnly = await prisma.lesson_plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lesson_plansFindManyArgs>(args?: SelectSubset<T, lesson_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lesson_plans.
     * @param {lesson_plansCreateArgs} args - Arguments to create a Lesson_plans.
     * @example
     * // Create one Lesson_plans
     * const Lesson_plans = await prisma.lesson_plans.create({
     *   data: {
     *     // ... data to create a Lesson_plans
     *   }
     * })
     * 
     */
    create<T extends lesson_plansCreateArgs>(args: SelectSubset<T, lesson_plansCreateArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lesson_plans.
     * @param {lesson_plansCreateManyArgs} args - Arguments to create many Lesson_plans.
     * @example
     * // Create many Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lesson_plansCreateManyArgs>(args?: SelectSubset<T, lesson_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lesson_plans and returns the data saved in the database.
     * @param {lesson_plansCreateManyAndReturnArgs} args - Arguments to create many Lesson_plans.
     * @example
     * // Create many Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lesson_plans and only return the `id`
     * const lesson_plansWithIdOnly = await prisma.lesson_plans.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lesson_plansCreateManyAndReturnArgs>(args?: SelectSubset<T, lesson_plansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lesson_plans.
     * @param {lesson_plansDeleteArgs} args - Arguments to delete one Lesson_plans.
     * @example
     * // Delete one Lesson_plans
     * const Lesson_plans = await prisma.lesson_plans.delete({
     *   where: {
     *     // ... filter to delete one Lesson_plans
     *   }
     * })
     * 
     */
    delete<T extends lesson_plansDeleteArgs>(args: SelectSubset<T, lesson_plansDeleteArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lesson_plans.
     * @param {lesson_plansUpdateArgs} args - Arguments to update one Lesson_plans.
     * @example
     * // Update one Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lesson_plansUpdateArgs>(args: SelectSubset<T, lesson_plansUpdateArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lesson_plans.
     * @param {lesson_plansDeleteManyArgs} args - Arguments to filter Lesson_plans to delete.
     * @example
     * // Delete a few Lesson_plans
     * const { count } = await prisma.lesson_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lesson_plansDeleteManyArgs>(args?: SelectSubset<T, lesson_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lesson_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lesson_plansUpdateManyArgs>(args: SelectSubset<T, lesson_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson_plans.
     * @param {lesson_plansUpsertArgs} args - Arguments to update or create a Lesson_plans.
     * @example
     * // Update or create a Lesson_plans
     * const lesson_plans = await prisma.lesson_plans.upsert({
     *   create: {
     *     // ... data to create a Lesson_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson_plans we want to update
     *   }
     * })
     */
    upsert<T extends lesson_plansUpsertArgs>(args: SelectSubset<T, lesson_plansUpsertArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lesson_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansCountArgs} args - Arguments to filter Lesson_plans to count.
     * @example
     * // Count the number of Lesson_plans
     * const count = await prisma.lesson_plans.count({
     *   where: {
     *     // ... the filter for the Lesson_plans we want to count
     *   }
     * })
    **/
    count<T extends lesson_plansCountArgs>(
      args?: Subset<T, lesson_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lesson_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lesson_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lesson_plansAggregateArgs>(args: Subset<T, Lesson_plansAggregateArgs>): Prisma.PrismaPromise<GetLesson_plansAggregateType<T>>

    /**
     * Group by Lesson_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lesson_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lesson_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lesson_plansGroupByArgs['orderBy'] }
        : { orderBy?: lesson_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lesson_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLesson_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lesson_plans model
   */
  readonly fields: lesson_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lesson_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lesson_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task_records<T extends lesson_plans$task_recordsArgs<ExtArgs> = {}>(args?: Subset<T, lesson_plans$task_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lesson_plans model
   */ 
  interface lesson_plansFieldRefs {
    readonly id: FieldRef<"lesson_plans", 'String'>
    readonly schoolId: FieldRef<"lesson_plans", 'String'>
    readonly teacherId: FieldRef<"lesson_plans", 'String'>
    readonly title: FieldRef<"lesson_plans", 'String'>
    readonly content: FieldRef<"lesson_plans", 'Json'>
    readonly date: FieldRef<"lesson_plans", 'DateTime'>
    readonly isActive: FieldRef<"lesson_plans", 'Boolean'>
    readonly createdAt: FieldRef<"lesson_plans", 'DateTime'>
    readonly updatedAt: FieldRef<"lesson_plans", 'DateTime'>
    readonly isGlobal: FieldRef<"lesson_plans", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * lesson_plans findUnique
   */
  export type lesson_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter, which lesson_plans to fetch.
     */
    where: lesson_plansWhereUniqueInput
  }

  /**
   * lesson_plans findUniqueOrThrow
   */
  export type lesson_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter, which lesson_plans to fetch.
     */
    where: lesson_plansWhereUniqueInput
  }

  /**
   * lesson_plans findFirst
   */
  export type lesson_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter, which lesson_plans to fetch.
     */
    where?: lesson_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lesson_plans to fetch.
     */
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lesson_plans.
     */
    cursor?: lesson_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lesson_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lesson_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lesson_plans.
     */
    distinct?: Lesson_plansScalarFieldEnum | Lesson_plansScalarFieldEnum[]
  }

  /**
   * lesson_plans findFirstOrThrow
   */
  export type lesson_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter, which lesson_plans to fetch.
     */
    where?: lesson_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lesson_plans to fetch.
     */
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lesson_plans.
     */
    cursor?: lesson_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lesson_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lesson_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lesson_plans.
     */
    distinct?: Lesson_plansScalarFieldEnum | Lesson_plansScalarFieldEnum[]
  }

  /**
   * lesson_plans findMany
   */
  export type lesson_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter, which lesson_plans to fetch.
     */
    where?: lesson_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lesson_plans to fetch.
     */
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lesson_plans.
     */
    cursor?: lesson_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lesson_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lesson_plans.
     */
    skip?: number
    distinct?: Lesson_plansScalarFieldEnum | Lesson_plansScalarFieldEnum[]
  }

  /**
   * lesson_plans create
   */
  export type lesson_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a lesson_plans.
     */
    data: XOR<lesson_plansCreateInput, lesson_plansUncheckedCreateInput>
  }

  /**
   * lesson_plans createMany
   */
  export type lesson_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lesson_plans.
     */
    data: lesson_plansCreateManyInput | lesson_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lesson_plans createManyAndReturn
   */
  export type lesson_plansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many lesson_plans.
     */
    data: lesson_plansCreateManyInput | lesson_plansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * lesson_plans update
   */
  export type lesson_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a lesson_plans.
     */
    data: XOR<lesson_plansUpdateInput, lesson_plansUncheckedUpdateInput>
    /**
     * Choose, which lesson_plans to update.
     */
    where: lesson_plansWhereUniqueInput
  }

  /**
   * lesson_plans updateMany
   */
  export type lesson_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lesson_plans.
     */
    data: XOR<lesson_plansUpdateManyMutationInput, lesson_plansUncheckedUpdateManyInput>
    /**
     * Filter which lesson_plans to update
     */
    where?: lesson_plansWhereInput
  }

  /**
   * lesson_plans upsert
   */
  export type lesson_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the lesson_plans to update in case it exists.
     */
    where: lesson_plansWhereUniqueInput
    /**
     * In case the lesson_plans found by the `where` argument doesn't exist, create a new lesson_plans with this data.
     */
    create: XOR<lesson_plansCreateInput, lesson_plansUncheckedCreateInput>
    /**
     * In case the lesson_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lesson_plansUpdateInput, lesson_plansUncheckedUpdateInput>
  }

  /**
   * lesson_plans delete
   */
  export type lesson_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    /**
     * Filter which lesson_plans to delete.
     */
    where: lesson_plansWhereUniqueInput
  }

  /**
   * lesson_plans deleteMany
   */
  export type lesson_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lesson_plans to delete
     */
    where?: lesson_plansWhereInput
  }

  /**
   * lesson_plans.task_records
   */
  export type lesson_plans$task_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    where?: task_recordsWhereInput
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    cursor?: task_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * lesson_plans without action
   */
  export type lesson_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
  }


  /**
   * Model mistakes
   */

  export type AggregateMistakes = {
    _count: MistakesCountAggregateOutputType | null
    _avg: MistakesAvgAggregateOutputType | null
    _sum: MistakesSumAggregateOutputType | null
    _min: MistakesMinAggregateOutputType | null
    _max: MistakesMaxAggregateOutputType | null
  }

  export type MistakesAvgAggregateOutputType = {
    questionNo: number | null
    retryCount: number | null
    workbookPage: number | null
    wrongCount: number | null
  }

  export type MistakesSumAggregateOutputType = {
    questionNo: number | null
    retryCount: number | null
    workbookPage: number | null
    wrongCount: number | null
  }

  export type MistakesMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    imageUrl: string | null
    ocrText: string | null
    status: $Enums.MistakeStatus | null
    category: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    errorCause: string | null
    lastRetryAt: Date | null
    lesson: string | null
    questionNo: number | null
    retryCount: number | null
    subject: string | null
    unit: string | null
    workbookPage: number | null
    wrongCount: number | null
  }

  export type MistakesMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    imageUrl: string | null
    ocrText: string | null
    status: $Enums.MistakeStatus | null
    category: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    errorCause: string | null
    lastRetryAt: Date | null
    lesson: string | null
    questionNo: number | null
    retryCount: number | null
    subject: string | null
    unit: string | null
    workbookPage: number | null
    wrongCount: number | null
  }

  export type MistakesCountAggregateOutputType = {
    id: number
    schoolId: number
    studentId: number
    imageUrl: number
    ocrText: number
    status: number
    category: number
    notes: number
    createdAt: number
    updatedAt: number
    aiAnalysis: number
    errorCause: number
    lastRetryAt: number
    lesson: number
    questionNo: number
    retryCount: number
    subject: number
    unit: number
    workbookPage: number
    wrongCount: number
    _all: number
  }


  export type MistakesAvgAggregateInputType = {
    questionNo?: true
    retryCount?: true
    workbookPage?: true
    wrongCount?: true
  }

  export type MistakesSumAggregateInputType = {
    questionNo?: true
    retryCount?: true
    workbookPage?: true
    wrongCount?: true
  }

  export type MistakesMinAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    imageUrl?: true
    ocrText?: true
    status?: true
    category?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    errorCause?: true
    lastRetryAt?: true
    lesson?: true
    questionNo?: true
    retryCount?: true
    subject?: true
    unit?: true
    workbookPage?: true
    wrongCount?: true
  }

  export type MistakesMaxAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    imageUrl?: true
    ocrText?: true
    status?: true
    category?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    errorCause?: true
    lastRetryAt?: true
    lesson?: true
    questionNo?: true
    retryCount?: true
    subject?: true
    unit?: true
    workbookPage?: true
    wrongCount?: true
  }

  export type MistakesCountAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    imageUrl?: true
    ocrText?: true
    status?: true
    category?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    aiAnalysis?: true
    errorCause?: true
    lastRetryAt?: true
    lesson?: true
    questionNo?: true
    retryCount?: true
    subject?: true
    unit?: true
    workbookPage?: true
    wrongCount?: true
    _all?: true
  }

  export type MistakesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mistakes to aggregate.
     */
    where?: mistakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mistakes to fetch.
     */
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mistakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mistakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mistakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mistakes
    **/
    _count?: true | MistakesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MistakesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MistakesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MistakesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MistakesMaxAggregateInputType
  }

  export type GetMistakesAggregateType<T extends MistakesAggregateArgs> = {
        [P in keyof T & keyof AggregateMistakes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMistakes[P]>
      : GetScalarType<T[P], AggregateMistakes[P]>
  }




  export type mistakesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mistakesWhereInput
    orderBy?: mistakesOrderByWithAggregationInput | mistakesOrderByWithAggregationInput[]
    by: MistakesScalarFieldEnum[] | MistakesScalarFieldEnum
    having?: mistakesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MistakesCountAggregateInputType | true
    _avg?: MistakesAvgAggregateInputType
    _sum?: MistakesSumAggregateInputType
    _min?: MistakesMinAggregateInputType
    _max?: MistakesMaxAggregateInputType
  }

  export type MistakesGroupByOutputType = {
    id: string
    schoolId: string
    studentId: string
    imageUrl: string | null
    ocrText: string | null
    status: $Enums.MistakeStatus
    category: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    aiAnalysis: JsonValue | null
    errorCause: string | null
    lastRetryAt: Date | null
    lesson: string | null
    questionNo: number | null
    retryCount: number
    subject: string | null
    unit: string | null
    workbookPage: number | null
    wrongCount: number
    _count: MistakesCountAggregateOutputType | null
    _avg: MistakesAvgAggregateOutputType | null
    _sum: MistakesSumAggregateOutputType | null
    _min: MistakesMinAggregateOutputType | null
    _max: MistakesMaxAggregateOutputType | null
  }

  type GetMistakesGroupByPayload<T extends mistakesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MistakesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MistakesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MistakesGroupByOutputType[P]>
            : GetScalarType<T[P], MistakesGroupByOutputType[P]>
        }
      >
    >


  export type mistakesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    imageUrl?: boolean
    ocrText?: boolean
    status?: boolean
    category?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiAnalysis?: boolean
    errorCause?: boolean
    lastRetryAt?: boolean
    lesson?: boolean
    questionNo?: boolean
    retryCount?: boolean
    subject?: boolean
    unit?: boolean
    workbookPage?: boolean
    wrongCount?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mistakes"]>

  export type mistakesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    imageUrl?: boolean
    ocrText?: boolean
    status?: boolean
    category?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiAnalysis?: boolean
    errorCause?: boolean
    lastRetryAt?: boolean
    lesson?: boolean
    questionNo?: boolean
    retryCount?: boolean
    subject?: boolean
    unit?: boolean
    workbookPage?: boolean
    wrongCount?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mistakes"]>

  export type mistakesSelectScalar = {
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    imageUrl?: boolean
    ocrText?: boolean
    status?: boolean
    category?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiAnalysis?: boolean
    errorCause?: boolean
    lastRetryAt?: boolean
    lesson?: boolean
    questionNo?: boolean
    retryCount?: boolean
    subject?: boolean
    unit?: boolean
    workbookPage?: boolean
    wrongCount?: boolean
  }

  export type mistakesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type mistakesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $mistakesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mistakes"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      studentId: string
      imageUrl: string | null
      ocrText: string | null
      status: $Enums.MistakeStatus
      category: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      aiAnalysis: Prisma.JsonValue | null
      errorCause: string | null
      lastRetryAt: Date | null
      lesson: string | null
      questionNo: number | null
      retryCount: number
      subject: string | null
      unit: string | null
      workbookPage: number | null
      wrongCount: number
    }, ExtArgs["result"]["mistakes"]>
    composites: {}
  }

  type mistakesGetPayload<S extends boolean | null | undefined | mistakesDefaultArgs> = $Result.GetResult<Prisma.$mistakesPayload, S>

  type mistakesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mistakesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MistakesCountAggregateInputType | true
    }

  export interface mistakesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mistakes'], meta: { name: 'mistakes' } }
    /**
     * Find zero or one Mistakes that matches the filter.
     * @param {mistakesFindUniqueArgs} args - Arguments to find a Mistakes
     * @example
     * // Get one Mistakes
     * const mistakes = await prisma.mistakes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mistakesFindUniqueArgs>(args: SelectSubset<T, mistakesFindUniqueArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mistakes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mistakesFindUniqueOrThrowArgs} args - Arguments to find a Mistakes
     * @example
     * // Get one Mistakes
     * const mistakes = await prisma.mistakes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mistakesFindUniqueOrThrowArgs>(args: SelectSubset<T, mistakesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mistakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesFindFirstArgs} args - Arguments to find a Mistakes
     * @example
     * // Get one Mistakes
     * const mistakes = await prisma.mistakes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mistakesFindFirstArgs>(args?: SelectSubset<T, mistakesFindFirstArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mistakes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesFindFirstOrThrowArgs} args - Arguments to find a Mistakes
     * @example
     * // Get one Mistakes
     * const mistakes = await prisma.mistakes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mistakesFindFirstOrThrowArgs>(args?: SelectSubset<T, mistakesFindFirstOrThrowArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mistakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mistakes
     * const mistakes = await prisma.mistakes.findMany()
     * 
     * // Get first 10 Mistakes
     * const mistakes = await prisma.mistakes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mistakesWithIdOnly = await prisma.mistakes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mistakesFindManyArgs>(args?: SelectSubset<T, mistakesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mistakes.
     * @param {mistakesCreateArgs} args - Arguments to create a Mistakes.
     * @example
     * // Create one Mistakes
     * const Mistakes = await prisma.mistakes.create({
     *   data: {
     *     // ... data to create a Mistakes
     *   }
     * })
     * 
     */
    create<T extends mistakesCreateArgs>(args: SelectSubset<T, mistakesCreateArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mistakes.
     * @param {mistakesCreateManyArgs} args - Arguments to create many Mistakes.
     * @example
     * // Create many Mistakes
     * const mistakes = await prisma.mistakes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mistakesCreateManyArgs>(args?: SelectSubset<T, mistakesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mistakes and returns the data saved in the database.
     * @param {mistakesCreateManyAndReturnArgs} args - Arguments to create many Mistakes.
     * @example
     * // Create many Mistakes
     * const mistakes = await prisma.mistakes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mistakes and only return the `id`
     * const mistakesWithIdOnly = await prisma.mistakes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mistakesCreateManyAndReturnArgs>(args?: SelectSubset<T, mistakesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mistakes.
     * @param {mistakesDeleteArgs} args - Arguments to delete one Mistakes.
     * @example
     * // Delete one Mistakes
     * const Mistakes = await prisma.mistakes.delete({
     *   where: {
     *     // ... filter to delete one Mistakes
     *   }
     * })
     * 
     */
    delete<T extends mistakesDeleteArgs>(args: SelectSubset<T, mistakesDeleteArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mistakes.
     * @param {mistakesUpdateArgs} args - Arguments to update one Mistakes.
     * @example
     * // Update one Mistakes
     * const mistakes = await prisma.mistakes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mistakesUpdateArgs>(args: SelectSubset<T, mistakesUpdateArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mistakes.
     * @param {mistakesDeleteManyArgs} args - Arguments to filter Mistakes to delete.
     * @example
     * // Delete a few Mistakes
     * const { count } = await prisma.mistakes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mistakesDeleteManyArgs>(args?: SelectSubset<T, mistakesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mistakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mistakes
     * const mistakes = await prisma.mistakes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mistakesUpdateManyArgs>(args: SelectSubset<T, mistakesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mistakes.
     * @param {mistakesUpsertArgs} args - Arguments to update or create a Mistakes.
     * @example
     * // Update or create a Mistakes
     * const mistakes = await prisma.mistakes.upsert({
     *   create: {
     *     // ... data to create a Mistakes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mistakes we want to update
     *   }
     * })
     */
    upsert<T extends mistakesUpsertArgs>(args: SelectSubset<T, mistakesUpsertArgs<ExtArgs>>): Prisma__mistakesClient<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mistakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesCountArgs} args - Arguments to filter Mistakes to count.
     * @example
     * // Count the number of Mistakes
     * const count = await prisma.mistakes.count({
     *   where: {
     *     // ... the filter for the Mistakes we want to count
     *   }
     * })
    **/
    count<T extends mistakesCountArgs>(
      args?: Subset<T, mistakesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MistakesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mistakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MistakesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MistakesAggregateArgs>(args: Subset<T, MistakesAggregateArgs>): Prisma.PrismaPromise<GetMistakesAggregateType<T>>

    /**
     * Group by Mistakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mistakesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mistakesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mistakesGroupByArgs['orderBy'] }
        : { orderBy?: mistakesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mistakesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMistakesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mistakes model
   */
  readonly fields: mistakesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mistakes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mistakesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mistakes model
   */ 
  interface mistakesFieldRefs {
    readonly id: FieldRef<"mistakes", 'String'>
    readonly schoolId: FieldRef<"mistakes", 'String'>
    readonly studentId: FieldRef<"mistakes", 'String'>
    readonly imageUrl: FieldRef<"mistakes", 'String'>
    readonly ocrText: FieldRef<"mistakes", 'String'>
    readonly status: FieldRef<"mistakes", 'MistakeStatus'>
    readonly category: FieldRef<"mistakes", 'String'>
    readonly notes: FieldRef<"mistakes", 'String'>
    readonly createdAt: FieldRef<"mistakes", 'DateTime'>
    readonly updatedAt: FieldRef<"mistakes", 'DateTime'>
    readonly aiAnalysis: FieldRef<"mistakes", 'Json'>
    readonly errorCause: FieldRef<"mistakes", 'String'>
    readonly lastRetryAt: FieldRef<"mistakes", 'DateTime'>
    readonly lesson: FieldRef<"mistakes", 'String'>
    readonly questionNo: FieldRef<"mistakes", 'Int'>
    readonly retryCount: FieldRef<"mistakes", 'Int'>
    readonly subject: FieldRef<"mistakes", 'String'>
    readonly unit: FieldRef<"mistakes", 'String'>
    readonly workbookPage: FieldRef<"mistakes", 'Int'>
    readonly wrongCount: FieldRef<"mistakes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * mistakes findUnique
   */
  export type mistakesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter, which mistakes to fetch.
     */
    where: mistakesWhereUniqueInput
  }

  /**
   * mistakes findUniqueOrThrow
   */
  export type mistakesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter, which mistakes to fetch.
     */
    where: mistakesWhereUniqueInput
  }

  /**
   * mistakes findFirst
   */
  export type mistakesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter, which mistakes to fetch.
     */
    where?: mistakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mistakes to fetch.
     */
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mistakes.
     */
    cursor?: mistakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mistakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mistakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mistakes.
     */
    distinct?: MistakesScalarFieldEnum | MistakesScalarFieldEnum[]
  }

  /**
   * mistakes findFirstOrThrow
   */
  export type mistakesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter, which mistakes to fetch.
     */
    where?: mistakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mistakes to fetch.
     */
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mistakes.
     */
    cursor?: mistakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mistakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mistakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mistakes.
     */
    distinct?: MistakesScalarFieldEnum | MistakesScalarFieldEnum[]
  }

  /**
   * mistakes findMany
   */
  export type mistakesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter, which mistakes to fetch.
     */
    where?: mistakesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mistakes to fetch.
     */
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mistakes.
     */
    cursor?: mistakesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mistakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mistakes.
     */
    skip?: number
    distinct?: MistakesScalarFieldEnum | MistakesScalarFieldEnum[]
  }

  /**
   * mistakes create
   */
  export type mistakesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * The data needed to create a mistakes.
     */
    data: XOR<mistakesCreateInput, mistakesUncheckedCreateInput>
  }

  /**
   * mistakes createMany
   */
  export type mistakesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mistakes.
     */
    data: mistakesCreateManyInput | mistakesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mistakes createManyAndReturn
   */
  export type mistakesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mistakes.
     */
    data: mistakesCreateManyInput | mistakesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mistakes update
   */
  export type mistakesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * The data needed to update a mistakes.
     */
    data: XOR<mistakesUpdateInput, mistakesUncheckedUpdateInput>
    /**
     * Choose, which mistakes to update.
     */
    where: mistakesWhereUniqueInput
  }

  /**
   * mistakes updateMany
   */
  export type mistakesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mistakes.
     */
    data: XOR<mistakesUpdateManyMutationInput, mistakesUncheckedUpdateManyInput>
    /**
     * Filter which mistakes to update
     */
    where?: mistakesWhereInput
  }

  /**
   * mistakes upsert
   */
  export type mistakesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * The filter to search for the mistakes to update in case it exists.
     */
    where: mistakesWhereUniqueInput
    /**
     * In case the mistakes found by the `where` argument doesn't exist, create a new mistakes with this data.
     */
    create: XOR<mistakesCreateInput, mistakesUncheckedCreateInput>
    /**
     * In case the mistakes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mistakesUpdateInput, mistakesUncheckedUpdateInput>
  }

  /**
   * mistakes delete
   */
  export type mistakesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    /**
     * Filter which mistakes to delete.
     */
    where: mistakesWhereUniqueInput
  }

  /**
   * mistakes deleteMany
   */
  export type mistakesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mistakes to delete
     */
    where?: mistakesWhereInput
  }

  /**
   * mistakes without action
   */
  export type mistakesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
  }


  /**
   * Model pk_matches
   */

  export type AggregatePk_matches = {
    _count: Pk_matchesCountAggregateOutputType | null
    _min: Pk_matchesMinAggregateOutputType | null
    _max: Pk_matchesMaxAggregateOutputType | null
  }

  export type Pk_matchesMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentA: string | null
    studentB: string | null
    winnerId: string | null
    status: $Enums.PKStatus | null
    topic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pk_matchesMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentA: string | null
    studentB: string | null
    winnerId: string | null
    status: $Enums.PKStatus | null
    topic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Pk_matchesCountAggregateOutputType = {
    id: number
    schoolId: number
    studentA: number
    studentB: number
    winnerId: number
    status: number
    topic: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Pk_matchesMinAggregateInputType = {
    id?: true
    schoolId?: true
    studentA?: true
    studentB?: true
    winnerId?: true
    status?: true
    topic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pk_matchesMaxAggregateInputType = {
    id?: true
    schoolId?: true
    studentA?: true
    studentB?: true
    winnerId?: true
    status?: true
    topic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Pk_matchesCountAggregateInputType = {
    id?: true
    schoolId?: true
    studentA?: true
    studentB?: true
    winnerId?: true
    status?: true
    topic?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Pk_matchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_matches to aggregate.
     */
    where?: pk_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_matches to fetch.
     */
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pk_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pk_matches
    **/
    _count?: true | Pk_matchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pk_matchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pk_matchesMaxAggregateInputType
  }

  export type GetPk_matchesAggregateType<T extends Pk_matchesAggregateArgs> = {
        [P in keyof T & keyof AggregatePk_matches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePk_matches[P]>
      : GetScalarType<T[P], AggregatePk_matches[P]>
  }




  export type pk_matchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pk_matchesWhereInput
    orderBy?: pk_matchesOrderByWithAggregationInput | pk_matchesOrderByWithAggregationInput[]
    by: Pk_matchesScalarFieldEnum[] | Pk_matchesScalarFieldEnum
    having?: pk_matchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pk_matchesCountAggregateInputType | true
    _min?: Pk_matchesMinAggregateInputType
    _max?: Pk_matchesMaxAggregateInputType
  }

  export type Pk_matchesGroupByOutputType = {
    id: string
    schoolId: string
    studentA: string
    studentB: string
    winnerId: string | null
    status: $Enums.PKStatus
    topic: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: Pk_matchesCountAggregateOutputType | null
    _min: Pk_matchesMinAggregateOutputType | null
    _max: Pk_matchesMaxAggregateOutputType | null
  }

  type GetPk_matchesGroupByPayload<T extends pk_matchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pk_matchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pk_matchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pk_matchesGroupByOutputType[P]>
            : GetScalarType<T[P], Pk_matchesGroupByOutputType[P]>
        }
      >
    >


  export type pk_matchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentA?: boolean
    studentB?: boolean
    winnerId?: boolean
    status?: boolean
    topic?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    playerA?: boolean | studentsDefaultArgs<ExtArgs>
    playerB?: boolean | studentsDefaultArgs<ExtArgs>
    winner?: boolean | pk_matches$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["pk_matches"]>

  export type pk_matchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentA?: boolean
    studentB?: boolean
    winnerId?: boolean
    status?: boolean
    topic?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    playerA?: boolean | studentsDefaultArgs<ExtArgs>
    playerB?: boolean | studentsDefaultArgs<ExtArgs>
    winner?: boolean | pk_matches$winnerArgs<ExtArgs>
  }, ExtArgs["result"]["pk_matches"]>

  export type pk_matchesSelectScalar = {
    id?: boolean
    schoolId?: boolean
    studentA?: boolean
    studentB?: boolean
    winnerId?: boolean
    status?: boolean
    topic?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type pk_matchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    playerA?: boolean | studentsDefaultArgs<ExtArgs>
    playerB?: boolean | studentsDefaultArgs<ExtArgs>
    winner?: boolean | pk_matches$winnerArgs<ExtArgs>
  }
  export type pk_matchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    playerA?: boolean | studentsDefaultArgs<ExtArgs>
    playerB?: boolean | studentsDefaultArgs<ExtArgs>
    winner?: boolean | pk_matches$winnerArgs<ExtArgs>
  }

  export type $pk_matchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pk_matches"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      playerA: Prisma.$studentsPayload<ExtArgs>
      playerB: Prisma.$studentsPayload<ExtArgs>
      winner: Prisma.$studentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      studentA: string
      studentB: string
      winnerId: string | null
      status: $Enums.PKStatus
      topic: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pk_matches"]>
    composites: {}
  }

  type pk_matchesGetPayload<S extends boolean | null | undefined | pk_matchesDefaultArgs> = $Result.GetResult<Prisma.$pk_matchesPayload, S>

  type pk_matchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pk_matchesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pk_matchesCountAggregateInputType | true
    }

  export interface pk_matchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pk_matches'], meta: { name: 'pk_matches' } }
    /**
     * Find zero or one Pk_matches that matches the filter.
     * @param {pk_matchesFindUniqueArgs} args - Arguments to find a Pk_matches
     * @example
     * // Get one Pk_matches
     * const pk_matches = await prisma.pk_matches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pk_matchesFindUniqueArgs>(args: SelectSubset<T, pk_matchesFindUniqueArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pk_matches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pk_matchesFindUniqueOrThrowArgs} args - Arguments to find a Pk_matches
     * @example
     * // Get one Pk_matches
     * const pk_matches = await prisma.pk_matches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pk_matchesFindUniqueOrThrowArgs>(args: SelectSubset<T, pk_matchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pk_matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesFindFirstArgs} args - Arguments to find a Pk_matches
     * @example
     * // Get one Pk_matches
     * const pk_matches = await prisma.pk_matches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pk_matchesFindFirstArgs>(args?: SelectSubset<T, pk_matchesFindFirstArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pk_matches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesFindFirstOrThrowArgs} args - Arguments to find a Pk_matches
     * @example
     * // Get one Pk_matches
     * const pk_matches = await prisma.pk_matches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pk_matchesFindFirstOrThrowArgs>(args?: SelectSubset<T, pk_matchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pk_matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pk_matches
     * const pk_matches = await prisma.pk_matches.findMany()
     * 
     * // Get first 10 Pk_matches
     * const pk_matches = await prisma.pk_matches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pk_matchesWithIdOnly = await prisma.pk_matches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pk_matchesFindManyArgs>(args?: SelectSubset<T, pk_matchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pk_matches.
     * @param {pk_matchesCreateArgs} args - Arguments to create a Pk_matches.
     * @example
     * // Create one Pk_matches
     * const Pk_matches = await prisma.pk_matches.create({
     *   data: {
     *     // ... data to create a Pk_matches
     *   }
     * })
     * 
     */
    create<T extends pk_matchesCreateArgs>(args: SelectSubset<T, pk_matchesCreateArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pk_matches.
     * @param {pk_matchesCreateManyArgs} args - Arguments to create many Pk_matches.
     * @example
     * // Create many Pk_matches
     * const pk_matches = await prisma.pk_matches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pk_matchesCreateManyArgs>(args?: SelectSubset<T, pk_matchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pk_matches and returns the data saved in the database.
     * @param {pk_matchesCreateManyAndReturnArgs} args - Arguments to create many Pk_matches.
     * @example
     * // Create many Pk_matches
     * const pk_matches = await prisma.pk_matches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pk_matches and only return the `id`
     * const pk_matchesWithIdOnly = await prisma.pk_matches.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pk_matchesCreateManyAndReturnArgs>(args?: SelectSubset<T, pk_matchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pk_matches.
     * @param {pk_matchesDeleteArgs} args - Arguments to delete one Pk_matches.
     * @example
     * // Delete one Pk_matches
     * const Pk_matches = await prisma.pk_matches.delete({
     *   where: {
     *     // ... filter to delete one Pk_matches
     *   }
     * })
     * 
     */
    delete<T extends pk_matchesDeleteArgs>(args: SelectSubset<T, pk_matchesDeleteArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pk_matches.
     * @param {pk_matchesUpdateArgs} args - Arguments to update one Pk_matches.
     * @example
     * // Update one Pk_matches
     * const pk_matches = await prisma.pk_matches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pk_matchesUpdateArgs>(args: SelectSubset<T, pk_matchesUpdateArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pk_matches.
     * @param {pk_matchesDeleteManyArgs} args - Arguments to filter Pk_matches to delete.
     * @example
     * // Delete a few Pk_matches
     * const { count } = await prisma.pk_matches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pk_matchesDeleteManyArgs>(args?: SelectSubset<T, pk_matchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pk_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pk_matches
     * const pk_matches = await prisma.pk_matches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pk_matchesUpdateManyArgs>(args: SelectSubset<T, pk_matchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pk_matches.
     * @param {pk_matchesUpsertArgs} args - Arguments to update or create a Pk_matches.
     * @example
     * // Update or create a Pk_matches
     * const pk_matches = await prisma.pk_matches.upsert({
     *   create: {
     *     // ... data to create a Pk_matches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pk_matches we want to update
     *   }
     * })
     */
    upsert<T extends pk_matchesUpsertArgs>(args: SelectSubset<T, pk_matchesUpsertArgs<ExtArgs>>): Prisma__pk_matchesClient<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pk_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesCountArgs} args - Arguments to filter Pk_matches to count.
     * @example
     * // Count the number of Pk_matches
     * const count = await prisma.pk_matches.count({
     *   where: {
     *     // ... the filter for the Pk_matches we want to count
     *   }
     * })
    **/
    count<T extends pk_matchesCountArgs>(
      args?: Subset<T, pk_matchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pk_matchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pk_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pk_matchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pk_matchesAggregateArgs>(args: Subset<T, Pk_matchesAggregateArgs>): Prisma.PrismaPromise<GetPk_matchesAggregateType<T>>

    /**
     * Group by Pk_matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pk_matchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pk_matchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pk_matchesGroupByArgs['orderBy'] }
        : { orderBy?: pk_matchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pk_matchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPk_matchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pk_matches model
   */
  readonly fields: pk_matchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pk_matches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pk_matchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playerA<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playerB<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    winner<T extends pk_matches$winnerArgs<ExtArgs> = {}>(args?: Subset<T, pk_matches$winnerArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pk_matches model
   */ 
  interface pk_matchesFieldRefs {
    readonly id: FieldRef<"pk_matches", 'String'>
    readonly schoolId: FieldRef<"pk_matches", 'String'>
    readonly studentA: FieldRef<"pk_matches", 'String'>
    readonly studentB: FieldRef<"pk_matches", 'String'>
    readonly winnerId: FieldRef<"pk_matches", 'String'>
    readonly status: FieldRef<"pk_matches", 'PKStatus'>
    readonly topic: FieldRef<"pk_matches", 'String'>
    readonly metadata: FieldRef<"pk_matches", 'Json'>
    readonly createdAt: FieldRef<"pk_matches", 'DateTime'>
    readonly updatedAt: FieldRef<"pk_matches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pk_matches findUnique
   */
  export type pk_matchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter, which pk_matches to fetch.
     */
    where: pk_matchesWhereUniqueInput
  }

  /**
   * pk_matches findUniqueOrThrow
   */
  export type pk_matchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter, which pk_matches to fetch.
     */
    where: pk_matchesWhereUniqueInput
  }

  /**
   * pk_matches findFirst
   */
  export type pk_matchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter, which pk_matches to fetch.
     */
    where?: pk_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_matches to fetch.
     */
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_matches.
     */
    cursor?: pk_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_matches.
     */
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * pk_matches findFirstOrThrow
   */
  export type pk_matchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter, which pk_matches to fetch.
     */
    where?: pk_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_matches to fetch.
     */
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pk_matches.
     */
    cursor?: pk_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pk_matches.
     */
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * pk_matches findMany
   */
  export type pk_matchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter, which pk_matches to fetch.
     */
    where?: pk_matchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pk_matches to fetch.
     */
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pk_matches.
     */
    cursor?: pk_matchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pk_matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pk_matches.
     */
    skip?: number
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * pk_matches create
   */
  export type pk_matchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * The data needed to create a pk_matches.
     */
    data: XOR<pk_matchesCreateInput, pk_matchesUncheckedCreateInput>
  }

  /**
   * pk_matches createMany
   */
  export type pk_matchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pk_matches.
     */
    data: pk_matchesCreateManyInput | pk_matchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pk_matches createManyAndReturn
   */
  export type pk_matchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pk_matches.
     */
    data: pk_matchesCreateManyInput | pk_matchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pk_matches update
   */
  export type pk_matchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * The data needed to update a pk_matches.
     */
    data: XOR<pk_matchesUpdateInput, pk_matchesUncheckedUpdateInput>
    /**
     * Choose, which pk_matches to update.
     */
    where: pk_matchesWhereUniqueInput
  }

  /**
   * pk_matches updateMany
   */
  export type pk_matchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pk_matches.
     */
    data: XOR<pk_matchesUpdateManyMutationInput, pk_matchesUncheckedUpdateManyInput>
    /**
     * Filter which pk_matches to update
     */
    where?: pk_matchesWhereInput
  }

  /**
   * pk_matches upsert
   */
  export type pk_matchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * The filter to search for the pk_matches to update in case it exists.
     */
    where: pk_matchesWhereUniqueInput
    /**
     * In case the pk_matches found by the `where` argument doesn't exist, create a new pk_matches with this data.
     */
    create: XOR<pk_matchesCreateInput, pk_matchesUncheckedCreateInput>
    /**
     * In case the pk_matches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pk_matchesUpdateInput, pk_matchesUncheckedUpdateInput>
  }

  /**
   * pk_matches delete
   */
  export type pk_matchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    /**
     * Filter which pk_matches to delete.
     */
    where: pk_matchesWhereUniqueInput
  }

  /**
   * pk_matches deleteMany
   */
  export type pk_matchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pk_matches to delete
     */
    where?: pk_matchesWhereInput
  }

  /**
   * pk_matches.winner
   */
  export type pk_matches$winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * pk_matches without action
   */
  export type pk_matchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
  }


  /**
   * Model schools
   */

  export type AggregateSchools = {
    _count: SchoolsCountAggregateOutputType | null
    _min: SchoolsMinAggregateOutputType | null
    _max: SchoolsMaxAggregateOutputType | null
  }

  export type SchoolsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    planType: $Enums.PlanType | null
    educationalPhilosophy: string | null
    expiredAt: Date | null
  }

  export type SchoolsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    planType: $Enums.PlanType | null
    educationalPhilosophy: string | null
    expiredAt: Date | null
  }

  export type SchoolsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    isActive: number
    planType: number
    settings: number
    educationalPhilosophy: number
    expiredAt: number
    _all: number
  }


  export type SchoolsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    planType?: true
    educationalPhilosophy?: true
    expiredAt?: true
  }

  export type SchoolsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    planType?: true
    educationalPhilosophy?: true
    expiredAt?: true
  }

  export type SchoolsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    planType?: true
    settings?: true
    educationalPhilosophy?: true
    expiredAt?: true
    _all?: true
  }

  export type SchoolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schools to aggregate.
     */
    where?: schoolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolsOrderByWithRelationInput | schoolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schoolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schools
    **/
    _count?: true | SchoolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolsMaxAggregateInputType
  }

  export type GetSchoolsAggregateType<T extends SchoolsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchools]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchools[P]>
      : GetScalarType<T[P], AggregateSchools[P]>
  }




  export type schoolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schoolsWhereInput
    orderBy?: schoolsOrderByWithAggregationInput | schoolsOrderByWithAggregationInput[]
    by: SchoolsScalarFieldEnum[] | SchoolsScalarFieldEnum
    having?: schoolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolsCountAggregateInputType | true
    _min?: SchoolsMinAggregateInputType
    _max?: SchoolsMaxAggregateInputType
  }

  export type SchoolsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    planType: $Enums.PlanType
    settings: JsonValue | null
    educationalPhilosophy: string
    expiredAt: Date | null
    _count: SchoolsCountAggregateOutputType | null
    _min: SchoolsMinAggregateOutputType | null
    _max: SchoolsMaxAggregateOutputType | null
  }

  type GetSchoolsGroupByPayload<T extends schoolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolsGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolsGroupByOutputType[P]>
        }
      >
    >


  export type schoolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    planType?: boolean
    settings?: boolean
    educationalPhilosophy?: boolean
    expiredAt?: boolean
    badges?: boolean | schools$badgesArgs<ExtArgs>
    challenges?: boolean | schools$challengesArgs<ExtArgs>
    habit_logs?: boolean | schools$habit_logsArgs<ExtArgs>
    habits?: boolean | schools$habitsArgs<ExtArgs>
    lesson_plans?: boolean | schools$lesson_plansArgs<ExtArgs>
    mistakes?: boolean | schools$mistakesArgs<ExtArgs>
    parents?: boolean | schools$parentsArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | schools$personalized_tutoring_plansArgs<ExtArgs>
    pk_matches?: boolean | schools$pk_matchesArgs<ExtArgs>
    reward_configs?: boolean | schools$reward_configsArgs<ExtArgs>
    student_checkins?: boolean | schools$student_checkinsArgs<ExtArgs>
    students?: boolean | schools$studentsArgs<ExtArgs>
    task_library?: boolean | schools$task_libraryArgs<ExtArgs>
    task_records?: boolean | schools$task_recordsArgs<ExtArgs>
    teachers?: boolean | schools$teachersArgs<ExtArgs>
    _count?: boolean | SchoolsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schools"]>

  export type schoolsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    planType?: boolean
    settings?: boolean
    educationalPhilosophy?: boolean
    expiredAt?: boolean
  }, ExtArgs["result"]["schools"]>

  export type schoolsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    planType?: boolean
    settings?: boolean
    educationalPhilosophy?: boolean
    expiredAt?: boolean
  }

  export type schoolsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | schools$badgesArgs<ExtArgs>
    challenges?: boolean | schools$challengesArgs<ExtArgs>
    habit_logs?: boolean | schools$habit_logsArgs<ExtArgs>
    habits?: boolean | schools$habitsArgs<ExtArgs>
    lesson_plans?: boolean | schools$lesson_plansArgs<ExtArgs>
    mistakes?: boolean | schools$mistakesArgs<ExtArgs>
    parents?: boolean | schools$parentsArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | schools$personalized_tutoring_plansArgs<ExtArgs>
    pk_matches?: boolean | schools$pk_matchesArgs<ExtArgs>
    reward_configs?: boolean | schools$reward_configsArgs<ExtArgs>
    student_checkins?: boolean | schools$student_checkinsArgs<ExtArgs>
    students?: boolean | schools$studentsArgs<ExtArgs>
    task_library?: boolean | schools$task_libraryArgs<ExtArgs>
    task_records?: boolean | schools$task_recordsArgs<ExtArgs>
    teachers?: boolean | schools$teachersArgs<ExtArgs>
    _count?: boolean | SchoolsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type schoolsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $schoolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schools"
    objects: {
      badges: Prisma.$badgesPayload<ExtArgs>[]
      challenges: Prisma.$challengesPayload<ExtArgs>[]
      habit_logs: Prisma.$habit_logsPayload<ExtArgs>[]
      habits: Prisma.$habitsPayload<ExtArgs>[]
      lesson_plans: Prisma.$lesson_plansPayload<ExtArgs>[]
      mistakes: Prisma.$mistakesPayload<ExtArgs>[]
      parents: Prisma.$parentsPayload<ExtArgs>[]
      personalized_tutoring_plans: Prisma.$personalized_tutoring_plansPayload<ExtArgs>[]
      pk_matches: Prisma.$pk_matchesPayload<ExtArgs>[]
      reward_configs: Prisma.$reward_configsPayload<ExtArgs>[]
      student_checkins: Prisma.$student_checkinsPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
      task_library: Prisma.$task_libraryPayload<ExtArgs>[]
      task_records: Prisma.$task_recordsPayload<ExtArgs>[]
      teachers: Prisma.$teachersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      planType: $Enums.PlanType
      settings: Prisma.JsonValue | null
      educationalPhilosophy: string
      expiredAt: Date | null
    }, ExtArgs["result"]["schools"]>
    composites: {}
  }

  type schoolsGetPayload<S extends boolean | null | undefined | schoolsDefaultArgs> = $Result.GetResult<Prisma.$schoolsPayload, S>

  type schoolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<schoolsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolsCountAggregateInputType | true
    }

  export interface schoolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schools'], meta: { name: 'schools' } }
    /**
     * Find zero or one Schools that matches the filter.
     * @param {schoolsFindUniqueArgs} args - Arguments to find a Schools
     * @example
     * // Get one Schools
     * const schools = await prisma.schools.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schoolsFindUniqueArgs>(args: SelectSubset<T, schoolsFindUniqueArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schools that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {schoolsFindUniqueOrThrowArgs} args - Arguments to find a Schools
     * @example
     * // Get one Schools
     * const schools = await prisma.schools.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schoolsFindUniqueOrThrowArgs>(args: SelectSubset<T, schoolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsFindFirstArgs} args - Arguments to find a Schools
     * @example
     * // Get one Schools
     * const schools = await prisma.schools.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schoolsFindFirstArgs>(args?: SelectSubset<T, schoolsFindFirstArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schools that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsFindFirstOrThrowArgs} args - Arguments to find a Schools
     * @example
     * // Get one Schools
     * const schools = await prisma.schools.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schoolsFindFirstOrThrowArgs>(args?: SelectSubset<T, schoolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.schools.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.schools.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolsWithIdOnly = await prisma.schools.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends schoolsFindManyArgs>(args?: SelectSubset<T, schoolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schools.
     * @param {schoolsCreateArgs} args - Arguments to create a Schools.
     * @example
     * // Create one Schools
     * const Schools = await prisma.schools.create({
     *   data: {
     *     // ... data to create a Schools
     *   }
     * })
     * 
     */
    create<T extends schoolsCreateArgs>(args: SelectSubset<T, schoolsCreateArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schools.
     * @param {schoolsCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const schools = await prisma.schools.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schoolsCreateManyArgs>(args?: SelectSubset<T, schoolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {schoolsCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const schools = await prisma.schools.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolsWithIdOnly = await prisma.schools.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schoolsCreateManyAndReturnArgs>(args?: SelectSubset<T, schoolsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Schools.
     * @param {schoolsDeleteArgs} args - Arguments to delete one Schools.
     * @example
     * // Delete one Schools
     * const Schools = await prisma.schools.delete({
     *   where: {
     *     // ... filter to delete one Schools
     *   }
     * })
     * 
     */
    delete<T extends schoolsDeleteArgs>(args: SelectSubset<T, schoolsDeleteArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schools.
     * @param {schoolsUpdateArgs} args - Arguments to update one Schools.
     * @example
     * // Update one Schools
     * const schools = await prisma.schools.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schoolsUpdateArgs>(args: SelectSubset<T, schoolsUpdateArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {schoolsDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.schools.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schoolsDeleteManyArgs>(args?: SelectSubset<T, schoolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const schools = await prisma.schools.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schoolsUpdateManyArgs>(args: SelectSubset<T, schoolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schools.
     * @param {schoolsUpsertArgs} args - Arguments to update or create a Schools.
     * @example
     * // Update or create a Schools
     * const schools = await prisma.schools.upsert({
     *   create: {
     *     // ... data to create a Schools
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schools we want to update
     *   }
     * })
     */
    upsert<T extends schoolsUpsertArgs>(args: SelectSubset<T, schoolsUpsertArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.schools.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends schoolsCountArgs>(
      args?: Subset<T, schoolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolsAggregateArgs>(args: Subset<T, SchoolsAggregateArgs>): Prisma.PrismaPromise<GetSchoolsAggregateType<T>>

    /**
     * Group by Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schoolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schoolsGroupByArgs['orderBy'] }
        : { orderBy?: schoolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schoolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schools model
   */
  readonly fields: schoolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schools.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schoolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends schools$badgesArgs<ExtArgs> = {}>(args?: Subset<T, schools$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findMany"> | Null>
    challenges<T extends schools$challengesArgs<ExtArgs> = {}>(args?: Subset<T, schools$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findMany"> | Null>
    habit_logs<T extends schools$habit_logsArgs<ExtArgs> = {}>(args?: Subset<T, schools$habit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findMany"> | Null>
    habits<T extends schools$habitsArgs<ExtArgs> = {}>(args?: Subset<T, schools$habitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habitsPayload<ExtArgs>, T, "findMany"> | Null>
    lesson_plans<T extends schools$lesson_plansArgs<ExtArgs> = {}>(args?: Subset<T, schools$lesson_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findMany"> | Null>
    mistakes<T extends schools$mistakesArgs<ExtArgs> = {}>(args?: Subset<T, schools$mistakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findMany"> | Null>
    parents<T extends schools$parentsArgs<ExtArgs> = {}>(args?: Subset<T, schools$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany"> | Null>
    personalized_tutoring_plans<T extends schools$personalized_tutoring_plansArgs<ExtArgs> = {}>(args?: Subset<T, schools$personalized_tutoring_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findMany"> | Null>
    pk_matches<T extends schools$pk_matchesArgs<ExtArgs> = {}>(args?: Subset<T, schools$pk_matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    reward_configs<T extends schools$reward_configsArgs<ExtArgs> = {}>(args?: Subset<T, schools$reward_configsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findMany"> | Null>
    student_checkins<T extends schools$student_checkinsArgs<ExtArgs> = {}>(args?: Subset<T, schools$student_checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends schools$studentsArgs<ExtArgs> = {}>(args?: Subset<T, schools$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany"> | Null>
    task_library<T extends schools$task_libraryArgs<ExtArgs> = {}>(args?: Subset<T, schools$task_libraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findMany"> | Null>
    task_records<T extends schools$task_recordsArgs<ExtArgs> = {}>(args?: Subset<T, schools$task_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findMany"> | Null>
    teachers<T extends schools$teachersArgs<ExtArgs> = {}>(args?: Subset<T, schools$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schools model
   */ 
  interface schoolsFieldRefs {
    readonly id: FieldRef<"schools", 'String'>
    readonly name: FieldRef<"schools", 'String'>
    readonly createdAt: FieldRef<"schools", 'DateTime'>
    readonly updatedAt: FieldRef<"schools", 'DateTime'>
    readonly isActive: FieldRef<"schools", 'Boolean'>
    readonly planType: FieldRef<"schools", 'PlanType'>
    readonly settings: FieldRef<"schools", 'Json'>
    readonly educationalPhilosophy: FieldRef<"schools", 'String'>
    readonly expiredAt: FieldRef<"schools", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * schools findUnique
   */
  export type schoolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where: schoolsWhereUniqueInput
  }

  /**
   * schools findUniqueOrThrow
   */
  export type schoolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where: schoolsWhereUniqueInput
  }

  /**
   * schools findFirst
   */
  export type schoolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where?: schoolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolsOrderByWithRelationInput | schoolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schools.
     */
    cursor?: schoolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schools.
     */
    distinct?: SchoolsScalarFieldEnum | SchoolsScalarFieldEnum[]
  }

  /**
   * schools findFirstOrThrow
   */
  export type schoolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where?: schoolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolsOrderByWithRelationInput | schoolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schools.
     */
    cursor?: schoolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schools.
     */
    distinct?: SchoolsScalarFieldEnum | SchoolsScalarFieldEnum[]
  }

  /**
   * schools findMany
   */
  export type schoolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where?: schoolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolsOrderByWithRelationInput | schoolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schools.
     */
    cursor?: schoolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    distinct?: SchoolsScalarFieldEnum | SchoolsScalarFieldEnum[]
  }

  /**
   * schools create
   */
  export type schoolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * The data needed to create a schools.
     */
    data: XOR<schoolsCreateInput, schoolsUncheckedCreateInput>
  }

  /**
   * schools createMany
   */
  export type schoolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schools.
     */
    data: schoolsCreateManyInput | schoolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schools createManyAndReturn
   */
  export type schoolsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many schools.
     */
    data: schoolsCreateManyInput | schoolsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schools update
   */
  export type schoolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * The data needed to update a schools.
     */
    data: XOR<schoolsUpdateInput, schoolsUncheckedUpdateInput>
    /**
     * Choose, which schools to update.
     */
    where: schoolsWhereUniqueInput
  }

  /**
   * schools updateMany
   */
  export type schoolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schools.
     */
    data: XOR<schoolsUpdateManyMutationInput, schoolsUncheckedUpdateManyInput>
    /**
     * Filter which schools to update
     */
    where?: schoolsWhereInput
  }

  /**
   * schools upsert
   */
  export type schoolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * The filter to search for the schools to update in case it exists.
     */
    where: schoolsWhereUniqueInput
    /**
     * In case the schools found by the `where` argument doesn't exist, create a new schools with this data.
     */
    create: XOR<schoolsCreateInput, schoolsUncheckedCreateInput>
    /**
     * In case the schools was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schoolsUpdateInput, schoolsUncheckedUpdateInput>
  }

  /**
   * schools delete
   */
  export type schoolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    /**
     * Filter which schools to delete.
     */
    where: schoolsWhereUniqueInput
  }

  /**
   * schools deleteMany
   */
  export type schoolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schools to delete
     */
    where?: schoolsWhereInput
  }

  /**
   * schools.badges
   */
  export type schools$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badges
     */
    select?: badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgesInclude<ExtArgs> | null
    where?: badgesWhereInput
    orderBy?: badgesOrderByWithRelationInput | badgesOrderByWithRelationInput[]
    cursor?: badgesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgesScalarFieldEnum | BadgesScalarFieldEnum[]
  }

  /**
   * schools.challenges
   */
  export type schools$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    where?: challengesWhereInput
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    cursor?: challengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengesScalarFieldEnum | ChallengesScalarFieldEnum[]
  }

  /**
   * schools.habit_logs
   */
  export type schools$habit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    where?: habit_logsWhereInput
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    cursor?: habit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * schools.habits
   */
  export type schools$habitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habits
     */
    select?: habitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habitsInclude<ExtArgs> | null
    where?: habitsWhereInput
    orderBy?: habitsOrderByWithRelationInput | habitsOrderByWithRelationInput[]
    cursor?: habitsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabitsScalarFieldEnum | HabitsScalarFieldEnum[]
  }

  /**
   * schools.lesson_plans
   */
  export type schools$lesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    where?: lesson_plansWhereInput
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    cursor?: lesson_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lesson_plansScalarFieldEnum | Lesson_plansScalarFieldEnum[]
  }

  /**
   * schools.mistakes
   */
  export type schools$mistakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    where?: mistakesWhereInput
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    cursor?: mistakesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MistakesScalarFieldEnum | MistakesScalarFieldEnum[]
  }

  /**
   * schools.parents
   */
  export type schools$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    cursor?: parentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * schools.personalized_tutoring_plans
   */
  export type schools$personalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    where?: personalized_tutoring_plansWhereInput
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    cursor?: personalized_tutoring_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * schools.pk_matches
   */
  export type schools$pk_matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    where?: pk_matchesWhereInput
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    cursor?: pk_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * schools.reward_configs
   */
  export type schools$reward_configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    where?: reward_configsWhereInput
    orderBy?: reward_configsOrderByWithRelationInput | reward_configsOrderByWithRelationInput[]
    cursor?: reward_configsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Reward_configsScalarFieldEnum | Reward_configsScalarFieldEnum[]
  }

  /**
   * schools.student_checkins
   */
  export type schools$student_checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    where?: student_checkinsWhereInput
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    cursor?: student_checkinsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_checkinsScalarFieldEnum | Student_checkinsScalarFieldEnum[]
  }

  /**
   * schools.students
   */
  export type schools$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * schools.task_library
   */
  export type schools$task_libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    where?: task_libraryWhereInput
    orderBy?: task_libraryOrderByWithRelationInput | task_libraryOrderByWithRelationInput[]
    cursor?: task_libraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Task_libraryScalarFieldEnum | Task_libraryScalarFieldEnum[]
  }

  /**
   * schools.task_records
   */
  export type schools$task_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    where?: task_recordsWhereInput
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    cursor?: task_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * schools.teachers
   */
  export type schools$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    cursor?: teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * schools without action
   */
  export type schoolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
  }


  /**
   * Model student_badges
   */

  export type AggregateStudent_badges = {
    _count: Student_badgesCountAggregateOutputType | null
    _min: Student_badgesMinAggregateOutputType | null
    _max: Student_badgesMaxAggregateOutputType | null
  }

  export type Student_badgesMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    badgeId: string | null
    awardedBy: string | null
    awardedAt: Date | null
    reason: string | null
  }

  export type Student_badgesMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    badgeId: string | null
    awardedBy: string | null
    awardedAt: Date | null
    reason: string | null
  }

  export type Student_badgesCountAggregateOutputType = {
    id: number
    studentId: number
    badgeId: number
    awardedBy: number
    awardedAt: number
    reason: number
    _all: number
  }


  export type Student_badgesMinAggregateInputType = {
    id?: true
    studentId?: true
    badgeId?: true
    awardedBy?: true
    awardedAt?: true
    reason?: true
  }

  export type Student_badgesMaxAggregateInputType = {
    id?: true
    studentId?: true
    badgeId?: true
    awardedBy?: true
    awardedAt?: true
    reason?: true
  }

  export type Student_badgesCountAggregateInputType = {
    id?: true
    studentId?: true
    badgeId?: true
    awardedBy?: true
    awardedAt?: true
    reason?: true
    _all?: true
  }

  export type Student_badgesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_badges to aggregate.
     */
    where?: student_badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_badges to fetch.
     */
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_badges
    **/
    _count?: true | Student_badgesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_badgesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_badgesMaxAggregateInputType
  }

  export type GetStudent_badgesAggregateType<T extends Student_badgesAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_badges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_badges[P]>
      : GetScalarType<T[P], AggregateStudent_badges[P]>
  }




  export type student_badgesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_badgesWhereInput
    orderBy?: student_badgesOrderByWithAggregationInput | student_badgesOrderByWithAggregationInput[]
    by: Student_badgesScalarFieldEnum[] | Student_badgesScalarFieldEnum
    having?: student_badgesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_badgesCountAggregateInputType | true
    _min?: Student_badgesMinAggregateInputType
    _max?: Student_badgesMaxAggregateInputType
  }

  export type Student_badgesGroupByOutputType = {
    id: string
    studentId: string
    badgeId: string
    awardedBy: string | null
    awardedAt: Date
    reason: string | null
    _count: Student_badgesCountAggregateOutputType | null
    _min: Student_badgesMinAggregateOutputType | null
    _max: Student_badgesMaxAggregateOutputType | null
  }

  type GetStudent_badgesGroupByPayload<T extends student_badgesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_badgesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_badgesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_badgesGroupByOutputType[P]>
            : GetScalarType<T[P], Student_badgesGroupByOutputType[P]>
        }
      >
    >


  export type student_badgesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    badgeId?: boolean
    awardedBy?: boolean
    awardedAt?: boolean
    reason?: boolean
    badges?: boolean | badgesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_badges"]>

  export type student_badgesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    badgeId?: boolean
    awardedBy?: boolean
    awardedAt?: boolean
    reason?: boolean
    badges?: boolean | badgesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_badges"]>

  export type student_badgesSelectScalar = {
    id?: boolean
    studentId?: boolean
    badgeId?: boolean
    awardedBy?: boolean
    awardedAt?: boolean
    reason?: boolean
  }

  export type student_badgesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | badgesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type student_badgesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | badgesDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $student_badgesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_badges"
    objects: {
      badges: Prisma.$badgesPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      badgeId: string
      awardedBy: string | null
      awardedAt: Date
      reason: string | null
    }, ExtArgs["result"]["student_badges"]>
    composites: {}
  }

  type student_badgesGetPayload<S extends boolean | null | undefined | student_badgesDefaultArgs> = $Result.GetResult<Prisma.$student_badgesPayload, S>

  type student_badgesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_badgesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_badgesCountAggregateInputType | true
    }

  export interface student_badgesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_badges'], meta: { name: 'student_badges' } }
    /**
     * Find zero or one Student_badges that matches the filter.
     * @param {student_badgesFindUniqueArgs} args - Arguments to find a Student_badges
     * @example
     * // Get one Student_badges
     * const student_badges = await prisma.student_badges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_badgesFindUniqueArgs>(args: SelectSubset<T, student_badgesFindUniqueArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_badges that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_badgesFindUniqueOrThrowArgs} args - Arguments to find a Student_badges
     * @example
     * // Get one Student_badges
     * const student_badges = await prisma.student_badges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_badgesFindUniqueOrThrowArgs>(args: SelectSubset<T, student_badgesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesFindFirstArgs} args - Arguments to find a Student_badges
     * @example
     * // Get one Student_badges
     * const student_badges = await prisma.student_badges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_badgesFindFirstArgs>(args?: SelectSubset<T, student_badgesFindFirstArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_badges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesFindFirstOrThrowArgs} args - Arguments to find a Student_badges
     * @example
     * // Get one Student_badges
     * const student_badges = await prisma.student_badges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_badgesFindFirstOrThrowArgs>(args?: SelectSubset<T, student_badgesFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_badges
     * const student_badges = await prisma.student_badges.findMany()
     * 
     * // Get first 10 Student_badges
     * const student_badges = await prisma.student_badges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_badgesWithIdOnly = await prisma.student_badges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_badgesFindManyArgs>(args?: SelectSubset<T, student_badgesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_badges.
     * @param {student_badgesCreateArgs} args - Arguments to create a Student_badges.
     * @example
     * // Create one Student_badges
     * const Student_badges = await prisma.student_badges.create({
     *   data: {
     *     // ... data to create a Student_badges
     *   }
     * })
     * 
     */
    create<T extends student_badgesCreateArgs>(args: SelectSubset<T, student_badgesCreateArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_badges.
     * @param {student_badgesCreateManyArgs} args - Arguments to create many Student_badges.
     * @example
     * // Create many Student_badges
     * const student_badges = await prisma.student_badges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_badgesCreateManyArgs>(args?: SelectSubset<T, student_badgesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_badges and returns the data saved in the database.
     * @param {student_badgesCreateManyAndReturnArgs} args - Arguments to create many Student_badges.
     * @example
     * // Create many Student_badges
     * const student_badges = await prisma.student_badges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_badges and only return the `id`
     * const student_badgesWithIdOnly = await prisma.student_badges.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_badgesCreateManyAndReturnArgs>(args?: SelectSubset<T, student_badgesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student_badges.
     * @param {student_badgesDeleteArgs} args - Arguments to delete one Student_badges.
     * @example
     * // Delete one Student_badges
     * const Student_badges = await prisma.student_badges.delete({
     *   where: {
     *     // ... filter to delete one Student_badges
     *   }
     * })
     * 
     */
    delete<T extends student_badgesDeleteArgs>(args: SelectSubset<T, student_badgesDeleteArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_badges.
     * @param {student_badgesUpdateArgs} args - Arguments to update one Student_badges.
     * @example
     * // Update one Student_badges
     * const student_badges = await prisma.student_badges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_badgesUpdateArgs>(args: SelectSubset<T, student_badgesUpdateArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_badges.
     * @param {student_badgesDeleteManyArgs} args - Arguments to filter Student_badges to delete.
     * @example
     * // Delete a few Student_badges
     * const { count } = await prisma.student_badges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_badgesDeleteManyArgs>(args?: SelectSubset<T, student_badgesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_badges
     * const student_badges = await prisma.student_badges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_badgesUpdateManyArgs>(args: SelectSubset<T, student_badgesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_badges.
     * @param {student_badgesUpsertArgs} args - Arguments to update or create a Student_badges.
     * @example
     * // Update or create a Student_badges
     * const student_badges = await prisma.student_badges.upsert({
     *   create: {
     *     // ... data to create a Student_badges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_badges we want to update
     *   }
     * })
     */
    upsert<T extends student_badgesUpsertArgs>(args: SelectSubset<T, student_badgesUpsertArgs<ExtArgs>>): Prisma__student_badgesClient<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesCountArgs} args - Arguments to filter Student_badges to count.
     * @example
     * // Count the number of Student_badges
     * const count = await prisma.student_badges.count({
     *   where: {
     *     // ... the filter for the Student_badges we want to count
     *   }
     * })
    **/
    count<T extends student_badgesCountArgs>(
      args?: Subset<T, student_badgesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_badgesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_badgesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_badgesAggregateArgs>(args: Subset<T, Student_badgesAggregateArgs>): Prisma.PrismaPromise<GetStudent_badgesAggregateType<T>>

    /**
     * Group by Student_badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_badgesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_badgesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_badgesGroupByArgs['orderBy'] }
        : { orderBy?: student_badgesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_badgesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_badgesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_badges model
   */
  readonly fields: student_badgesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_badges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_badgesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends badgesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, badgesDefaultArgs<ExtArgs>>): Prisma__badgesClient<$Result.GetResult<Prisma.$badgesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_badges model
   */ 
  interface student_badgesFieldRefs {
    readonly id: FieldRef<"student_badges", 'String'>
    readonly studentId: FieldRef<"student_badges", 'String'>
    readonly badgeId: FieldRef<"student_badges", 'String'>
    readonly awardedBy: FieldRef<"student_badges", 'String'>
    readonly awardedAt: FieldRef<"student_badges", 'DateTime'>
    readonly reason: FieldRef<"student_badges", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student_badges findUnique
   */
  export type student_badgesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter, which student_badges to fetch.
     */
    where: student_badgesWhereUniqueInput
  }

  /**
   * student_badges findUniqueOrThrow
   */
  export type student_badgesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter, which student_badges to fetch.
     */
    where: student_badgesWhereUniqueInput
  }

  /**
   * student_badges findFirst
   */
  export type student_badgesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter, which student_badges to fetch.
     */
    where?: student_badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_badges to fetch.
     */
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_badges.
     */
    cursor?: student_badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_badges.
     */
    distinct?: Student_badgesScalarFieldEnum | Student_badgesScalarFieldEnum[]
  }

  /**
   * student_badges findFirstOrThrow
   */
  export type student_badgesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter, which student_badges to fetch.
     */
    where?: student_badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_badges to fetch.
     */
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_badges.
     */
    cursor?: student_badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_badges.
     */
    distinct?: Student_badgesScalarFieldEnum | Student_badgesScalarFieldEnum[]
  }

  /**
   * student_badges findMany
   */
  export type student_badgesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter, which student_badges to fetch.
     */
    where?: student_badgesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_badges to fetch.
     */
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_badges.
     */
    cursor?: student_badgesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_badges.
     */
    skip?: number
    distinct?: Student_badgesScalarFieldEnum | Student_badgesScalarFieldEnum[]
  }

  /**
   * student_badges create
   */
  export type student_badgesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * The data needed to create a student_badges.
     */
    data: XOR<student_badgesCreateInput, student_badgesUncheckedCreateInput>
  }

  /**
   * student_badges createMany
   */
  export type student_badgesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_badges.
     */
    data: student_badgesCreateManyInput | student_badgesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_badges createManyAndReturn
   */
  export type student_badgesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many student_badges.
     */
    data: student_badgesCreateManyInput | student_badgesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_badges update
   */
  export type student_badgesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * The data needed to update a student_badges.
     */
    data: XOR<student_badgesUpdateInput, student_badgesUncheckedUpdateInput>
    /**
     * Choose, which student_badges to update.
     */
    where: student_badgesWhereUniqueInput
  }

  /**
   * student_badges updateMany
   */
  export type student_badgesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_badges.
     */
    data: XOR<student_badgesUpdateManyMutationInput, student_badgesUncheckedUpdateManyInput>
    /**
     * Filter which student_badges to update
     */
    where?: student_badgesWhereInput
  }

  /**
   * student_badges upsert
   */
  export type student_badgesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * The filter to search for the student_badges to update in case it exists.
     */
    where: student_badgesWhereUniqueInput
    /**
     * In case the student_badges found by the `where` argument doesn't exist, create a new student_badges with this data.
     */
    create: XOR<student_badgesCreateInput, student_badgesUncheckedCreateInput>
    /**
     * In case the student_badges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_badgesUpdateInput, student_badgesUncheckedUpdateInput>
  }

  /**
   * student_badges delete
   */
  export type student_badgesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    /**
     * Filter which student_badges to delete.
     */
    where: student_badgesWhereUniqueInput
  }

  /**
   * student_badges deleteMany
   */
  export type student_badgesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_badges to delete
     */
    where?: student_badgesWhereInput
  }

  /**
   * student_badges without action
   */
  export type student_badgesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    level: number | null
    points: number | null
    exp: number | null
  }

  export type StudentsSumAggregateOutputType = {
    level: number | null
    points: number | null
    exp: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    className: string | null
    level: number | null
    points: number | null
    exp: number | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    teacherId: string | null
    currentLesson: string | null
    currentLessonTitle: string | null
    currentUnit: string | null
    currentInviteCode: string | null
    inviteCodeExpiresAt: Date | null
    deletedAt: Date | null
    grade: string | null
    semester: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    name: string | null
    className: string | null
    level: number | null
    points: number | null
    exp: number | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    teamId: string | null
    teacherId: string | null
    currentLesson: string | null
    currentLessonTitle: string | null
    currentUnit: string | null
    currentInviteCode: string | null
    inviteCodeExpiresAt: Date | null
    deletedAt: Date | null
    grade: string | null
    semester: string | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    className: number
    level: number
    points: number
    exp: number
    avatarUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    teamId: number
    teacherId: number
    currentLesson: number
    currentLessonTitle: number
    currentUnit: number
    currentInviteCode: number
    inviteCodeExpiresAt: number
    deletedAt: number
    grade: number
    semester: number
    currentProgress: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    level?: true
    points?: true
    exp?: true
  }

  export type StudentsSumAggregateInputType = {
    level?: true
    points?: true
    exp?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    className?: true
    level?: true
    points?: true
    exp?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    teacherId?: true
    currentLesson?: true
    currentLessonTitle?: true
    currentUnit?: true
    currentInviteCode?: true
    inviteCodeExpiresAt?: true
    deletedAt?: true
    grade?: true
    semester?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    className?: true
    level?: true
    points?: true
    exp?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    teacherId?: true
    currentLesson?: true
    currentLessonTitle?: true
    currentUnit?: true
    currentInviteCode?: true
    inviteCodeExpiresAt?: true
    deletedAt?: true
    grade?: true
    semester?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    className?: true
    level?: true
    points?: true
    exp?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    teamId?: true
    teacherId?: true
    currentLesson?: true
    currentLessonTitle?: true
    currentUnit?: true
    currentInviteCode?: true
    inviteCodeExpiresAt?: true
    deletedAt?: true
    grade?: true
    semester?: true
    currentProgress?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: string
    schoolId: string
    name: string
    className: string | null
    level: number
    points: number
    exp: number
    avatarUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    teamId: string | null
    teacherId: string | null
    currentLesson: string | null
    currentLessonTitle: string | null
    currentUnit: string | null
    currentInviteCode: string | null
    inviteCodeExpiresAt: Date | null
    deletedAt: Date | null
    grade: string | null
    semester: string | null
    currentProgress: JsonValue | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    className?: boolean
    level?: boolean
    points?: boolean
    exp?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    teacherId?: boolean
    currentLesson?: boolean
    currentLessonTitle?: boolean
    currentUnit?: boolean
    currentInviteCode?: boolean
    inviteCodeExpiresAt?: boolean
    deletedAt?: boolean
    grade?: boolean
    semester?: boolean
    currentProgress?: boolean
    campaigns?: boolean | students$campaignsArgs<ExtArgs>
    challenge_participants?: boolean | students$challenge_participantsArgs<ExtArgs>
    daily_summaries?: boolean | students$daily_summariesArgs<ExtArgs>
    habit_logs?: boolean | students$habit_logsArgs<ExtArgs>
    mistakes?: boolean | students$mistakesArgs<ExtArgs>
    parent_student_bindings?: boolean | students$parent_student_bindingsArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | students$personalized_tutoring_plansArgs<ExtArgs>
    pk_matches_studentA?: boolean | students$pk_matches_studentAArgs<ExtArgs>
    pk_matches_studentB?: boolean | students$pk_matches_studentBArgs<ExtArgs>
    pk_matches_winner?: boolean | students$pk_matches_winnerArgs<ExtArgs>
    student_badges?: boolean | students$student_badgesArgs<ExtArgs>
    student_checkins?: boolean | students$student_checkinsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | students$teachersArgs<ExtArgs>
    task_records?: boolean | students$task_recordsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    className?: boolean
    level?: boolean
    points?: boolean
    exp?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    teacherId?: boolean
    currentLesson?: boolean
    currentLessonTitle?: boolean
    currentUnit?: boolean
    currentInviteCode?: boolean
    inviteCodeExpiresAt?: boolean
    deletedAt?: boolean
    grade?: boolean
    semester?: boolean
    currentProgress?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | students$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    className?: boolean
    level?: boolean
    points?: boolean
    exp?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamId?: boolean
    teacherId?: boolean
    currentLesson?: boolean
    currentLessonTitle?: boolean
    currentUnit?: boolean
    currentInviteCode?: boolean
    inviteCodeExpiresAt?: boolean
    deletedAt?: boolean
    grade?: boolean
    semester?: boolean
    currentProgress?: boolean
  }

  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | students$campaignsArgs<ExtArgs>
    challenge_participants?: boolean | students$challenge_participantsArgs<ExtArgs>
    daily_summaries?: boolean | students$daily_summariesArgs<ExtArgs>
    habit_logs?: boolean | students$habit_logsArgs<ExtArgs>
    mistakes?: boolean | students$mistakesArgs<ExtArgs>
    parent_student_bindings?: boolean | students$parent_student_bindingsArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | students$personalized_tutoring_plansArgs<ExtArgs>
    pk_matches_studentA?: boolean | students$pk_matches_studentAArgs<ExtArgs>
    pk_matches_studentB?: boolean | students$pk_matches_studentBArgs<ExtArgs>
    pk_matches_winner?: boolean | students$pk_matches_winnerArgs<ExtArgs>
    student_badges?: boolean | students$student_badgesArgs<ExtArgs>
    student_checkins?: boolean | students$student_checkinsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | students$teachersArgs<ExtArgs>
    task_records?: boolean | students$task_recordsArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    teachers?: boolean | students$teachersArgs<ExtArgs>
  }

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      campaigns: Prisma.$campaignsPayload<ExtArgs>[]
      challenge_participants: Prisma.$challenge_participantsPayload<ExtArgs>[]
      daily_summaries: Prisma.$daily_summariesPayload<ExtArgs>[]
      habit_logs: Prisma.$habit_logsPayload<ExtArgs>[]
      mistakes: Prisma.$mistakesPayload<ExtArgs>[]
      parent_student_bindings: Prisma.$parent_student_bindingsPayload<ExtArgs>[]
      personalized_tutoring_plans: Prisma.$personalized_tutoring_plansPayload<ExtArgs>[]
      pk_matches_studentA: Prisma.$pk_matchesPayload<ExtArgs>[]
      pk_matches_studentB: Prisma.$pk_matchesPayload<ExtArgs>[]
      pk_matches_winner: Prisma.$pk_matchesPayload<ExtArgs>[]
      student_badges: Prisma.$student_badgesPayload<ExtArgs>[]
      student_checkins: Prisma.$student_checkinsPayload<ExtArgs>[]
      schools: Prisma.$schoolsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs> | null
      task_records: Prisma.$task_recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      name: string
      className: string | null
      level: number
      points: number
      exp: number
      avatarUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      teamId: string | null
      teacherId: string | null
      currentLesson: string | null
      currentLessonTitle: string | null
      currentUnit: string | null
      currentInviteCode: string | null
      inviteCodeExpiresAt: Date | null
      deletedAt: Date | null
      grade: string | null
      semester: string | null
      currentProgress: Prisma.JsonValue | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentsCreateManyAndReturnArgs>(args?: SelectSubset<T, studentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends students$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, students$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findMany"> | Null>
    challenge_participants<T extends students$challenge_participantsArgs<ExtArgs> = {}>(args?: Subset<T, students$challenge_participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challenge_participantsPayload<ExtArgs>, T, "findMany"> | Null>
    daily_summaries<T extends students$daily_summariesArgs<ExtArgs> = {}>(args?: Subset<T, students$daily_summariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findMany"> | Null>
    habit_logs<T extends students$habit_logsArgs<ExtArgs> = {}>(args?: Subset<T, students$habit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habit_logsPayload<ExtArgs>, T, "findMany"> | Null>
    mistakes<T extends students$mistakesArgs<ExtArgs> = {}>(args?: Subset<T, students$mistakesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mistakesPayload<ExtArgs>, T, "findMany"> | Null>
    parent_student_bindings<T extends students$parent_student_bindingsArgs<ExtArgs> = {}>(args?: Subset<T, students$parent_student_bindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findMany"> | Null>
    personalized_tutoring_plans<T extends students$personalized_tutoring_plansArgs<ExtArgs> = {}>(args?: Subset<T, students$personalized_tutoring_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findMany"> | Null>
    pk_matches_studentA<T extends students$pk_matches_studentAArgs<ExtArgs> = {}>(args?: Subset<T, students$pk_matches_studentAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    pk_matches_studentB<T extends students$pk_matches_studentBArgs<ExtArgs> = {}>(args?: Subset<T, students$pk_matches_studentBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    pk_matches_winner<T extends students$pk_matches_winnerArgs<ExtArgs> = {}>(args?: Subset<T, students$pk_matches_winnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pk_matchesPayload<ExtArgs>, T, "findMany"> | Null>
    student_badges<T extends students$student_badgesArgs<ExtArgs> = {}>(args?: Subset<T, students$student_badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_badgesPayload<ExtArgs>, T, "findMany"> | Null>
    student_checkins<T extends students$student_checkinsArgs<ExtArgs> = {}>(args?: Subset<T, students$student_checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findMany"> | Null>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends students$teachersArgs<ExtArgs> = {}>(args?: Subset<T, students$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    task_records<T extends students$task_recordsArgs<ExtArgs> = {}>(args?: Subset<T, students$task_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */ 
  interface studentsFieldRefs {
    readonly id: FieldRef<"students", 'String'>
    readonly schoolId: FieldRef<"students", 'String'>
    readonly name: FieldRef<"students", 'String'>
    readonly className: FieldRef<"students", 'String'>
    readonly level: FieldRef<"students", 'Int'>
    readonly points: FieldRef<"students", 'Int'>
    readonly exp: FieldRef<"students", 'Int'>
    readonly avatarUrl: FieldRef<"students", 'String'>
    readonly isActive: FieldRef<"students", 'Boolean'>
    readonly createdAt: FieldRef<"students", 'DateTime'>
    readonly updatedAt: FieldRef<"students", 'DateTime'>
    readonly teamId: FieldRef<"students", 'String'>
    readonly teacherId: FieldRef<"students", 'String'>
    readonly currentLesson: FieldRef<"students", 'String'>
    readonly currentLessonTitle: FieldRef<"students", 'String'>
    readonly currentUnit: FieldRef<"students", 'String'>
    readonly currentInviteCode: FieldRef<"students", 'String'>
    readonly inviteCodeExpiresAt: FieldRef<"students", 'DateTime'>
    readonly deletedAt: FieldRef<"students", 'DateTime'>
    readonly grade: FieldRef<"students", 'String'>
    readonly semester: FieldRef<"students", 'String'>
    readonly currentProgress: FieldRef<"students", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students createManyAndReturn
   */
  export type studentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
  }

  /**
   * students.campaigns
   */
  export type students$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    where?: campaignsWhereInput
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    cursor?: campaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * students.challenge_participants
   */
  export type students$challenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenge_participants
     */
    select?: challenge_participantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challenge_participantsInclude<ExtArgs> | null
    where?: challenge_participantsWhereInput
    orderBy?: challenge_participantsOrderByWithRelationInput | challenge_participantsOrderByWithRelationInput[]
    cursor?: challenge_participantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Challenge_participantsScalarFieldEnum | Challenge_participantsScalarFieldEnum[]
  }

  /**
   * students.daily_summaries
   */
  export type students$daily_summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    where?: daily_summariesWhereInput
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    cursor?: daily_summariesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Daily_summariesScalarFieldEnum | Daily_summariesScalarFieldEnum[]
  }

  /**
   * students.habit_logs
   */
  export type students$habit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habit_logs
     */
    select?: habit_logsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habit_logsInclude<ExtArgs> | null
    where?: habit_logsWhereInput
    orderBy?: habit_logsOrderByWithRelationInput | habit_logsOrderByWithRelationInput[]
    cursor?: habit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Habit_logsScalarFieldEnum | Habit_logsScalarFieldEnum[]
  }

  /**
   * students.mistakes
   */
  export type students$mistakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mistakes
     */
    select?: mistakesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mistakesInclude<ExtArgs> | null
    where?: mistakesWhereInput
    orderBy?: mistakesOrderByWithRelationInput | mistakesOrderByWithRelationInput[]
    cursor?: mistakesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MistakesScalarFieldEnum | MistakesScalarFieldEnum[]
  }

  /**
   * students.parent_student_bindings
   */
  export type students$parent_student_bindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    where?: parent_student_bindingsWhereInput
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    cursor?: parent_student_bindingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Parent_student_bindingsScalarFieldEnum | Parent_student_bindingsScalarFieldEnum[]
  }

  /**
   * students.personalized_tutoring_plans
   */
  export type students$personalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    where?: personalized_tutoring_plansWhereInput
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    cursor?: personalized_tutoring_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * students.pk_matches_studentA
   */
  export type students$pk_matches_studentAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    where?: pk_matchesWhereInput
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    cursor?: pk_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * students.pk_matches_studentB
   */
  export type students$pk_matches_studentBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    where?: pk_matchesWhereInput
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    cursor?: pk_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * students.pk_matches_winner
   */
  export type students$pk_matches_winnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pk_matches
     */
    select?: pk_matchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pk_matchesInclude<ExtArgs> | null
    where?: pk_matchesWhereInput
    orderBy?: pk_matchesOrderByWithRelationInput | pk_matchesOrderByWithRelationInput[]
    cursor?: pk_matchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pk_matchesScalarFieldEnum | Pk_matchesScalarFieldEnum[]
  }

  /**
   * students.student_badges
   */
  export type students$student_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_badges
     */
    select?: student_badgesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_badgesInclude<ExtArgs> | null
    where?: student_badgesWhereInput
    orderBy?: student_badgesOrderByWithRelationInput | student_badgesOrderByWithRelationInput[]
    cursor?: student_badgesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_badgesScalarFieldEnum | Student_badgesScalarFieldEnum[]
  }

  /**
   * students.student_checkins
   */
  export type students$student_checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    where?: student_checkinsWhereInput
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    cursor?: student_checkinsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_checkinsScalarFieldEnum | Student_checkinsScalarFieldEnum[]
  }

  /**
   * students.teachers
   */
  export type students$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * students.task_records
   */
  export type students$task_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    where?: task_recordsWhereInput
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    cursor?: task_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Model student_checkins
   */

  export type AggregateStudent_checkins = {
    _count: Student_checkinsCountAggregateOutputType | null
    _min: Student_checkinsMinAggregateOutputType | null
    _max: Student_checkinsMaxAggregateOutputType | null
  }

  export type Student_checkinsMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    schoolId: string | null
    checkinDate: string | null
    checkedBy: string | null
    createdAt: Date | null
  }

  export type Student_checkinsMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    schoolId: string | null
    checkinDate: string | null
    checkedBy: string | null
    createdAt: Date | null
  }

  export type Student_checkinsCountAggregateOutputType = {
    id: number
    studentId: number
    schoolId: number
    checkinDate: number
    checkedBy: number
    createdAt: number
    _all: number
  }


  export type Student_checkinsMinAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    checkinDate?: true
    checkedBy?: true
    createdAt?: true
  }

  export type Student_checkinsMaxAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    checkinDate?: true
    checkedBy?: true
    createdAt?: true
  }

  export type Student_checkinsCountAggregateInputType = {
    id?: true
    studentId?: true
    schoolId?: true
    checkinDate?: true
    checkedBy?: true
    createdAt?: true
    _all?: true
  }

  export type Student_checkinsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_checkins to aggregate.
     */
    where?: student_checkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_checkins to fetch.
     */
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_checkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_checkins
    **/
    _count?: true | Student_checkinsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_checkinsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_checkinsMaxAggregateInputType
  }

  export type GetStudent_checkinsAggregateType<T extends Student_checkinsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_checkins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_checkins[P]>
      : GetScalarType<T[P], AggregateStudent_checkins[P]>
  }




  export type student_checkinsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_checkinsWhereInput
    orderBy?: student_checkinsOrderByWithAggregationInput | student_checkinsOrderByWithAggregationInput[]
    by: Student_checkinsScalarFieldEnum[] | Student_checkinsScalarFieldEnum
    having?: student_checkinsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_checkinsCountAggregateInputType | true
    _min?: Student_checkinsMinAggregateInputType
    _max?: Student_checkinsMaxAggregateInputType
  }

  export type Student_checkinsGroupByOutputType = {
    id: string
    studentId: string
    schoolId: string
    checkinDate: string
    checkedBy: string | null
    createdAt: Date
    _count: Student_checkinsCountAggregateOutputType | null
    _min: Student_checkinsMinAggregateOutputType | null
    _max: Student_checkinsMaxAggregateOutputType | null
  }

  type GetStudent_checkinsGroupByPayload<T extends student_checkinsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_checkinsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_checkinsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_checkinsGroupByOutputType[P]>
            : GetScalarType<T[P], Student_checkinsGroupByOutputType[P]>
        }
      >
    >


  export type student_checkinsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    checkinDate?: boolean
    checkedBy?: boolean
    createdAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_checkins"]>

  export type student_checkinsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    checkinDate?: boolean
    checkedBy?: boolean
    createdAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_checkins"]>

  export type student_checkinsSelectScalar = {
    id?: boolean
    studentId?: boolean
    schoolId?: boolean
    checkinDate?: boolean
    checkedBy?: boolean
    createdAt?: boolean
  }

  export type student_checkinsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type student_checkinsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $student_checkinsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_checkins"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      schoolId: string
      checkinDate: string
      checkedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["student_checkins"]>
    composites: {}
  }

  type student_checkinsGetPayload<S extends boolean | null | undefined | student_checkinsDefaultArgs> = $Result.GetResult<Prisma.$student_checkinsPayload, S>

  type student_checkinsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<student_checkinsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Student_checkinsCountAggregateInputType | true
    }

  export interface student_checkinsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_checkins'], meta: { name: 'student_checkins' } }
    /**
     * Find zero or one Student_checkins that matches the filter.
     * @param {student_checkinsFindUniqueArgs} args - Arguments to find a Student_checkins
     * @example
     * // Get one Student_checkins
     * const student_checkins = await prisma.student_checkins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_checkinsFindUniqueArgs>(args: SelectSubset<T, student_checkinsFindUniqueArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student_checkins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {student_checkinsFindUniqueOrThrowArgs} args - Arguments to find a Student_checkins
     * @example
     * // Get one Student_checkins
     * const student_checkins = await prisma.student_checkins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_checkinsFindUniqueOrThrowArgs>(args: SelectSubset<T, student_checkinsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student_checkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsFindFirstArgs} args - Arguments to find a Student_checkins
     * @example
     * // Get one Student_checkins
     * const student_checkins = await prisma.student_checkins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_checkinsFindFirstArgs>(args?: SelectSubset<T, student_checkinsFindFirstArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student_checkins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsFindFirstOrThrowArgs} args - Arguments to find a Student_checkins
     * @example
     * // Get one Student_checkins
     * const student_checkins = await prisma.student_checkins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_checkinsFindFirstOrThrowArgs>(args?: SelectSubset<T, student_checkinsFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Student_checkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_checkins
     * const student_checkins = await prisma.student_checkins.findMany()
     * 
     * // Get first 10 Student_checkins
     * const student_checkins = await prisma.student_checkins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_checkinsWithIdOnly = await prisma.student_checkins.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_checkinsFindManyArgs>(args?: SelectSubset<T, student_checkinsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student_checkins.
     * @param {student_checkinsCreateArgs} args - Arguments to create a Student_checkins.
     * @example
     * // Create one Student_checkins
     * const Student_checkins = await prisma.student_checkins.create({
     *   data: {
     *     // ... data to create a Student_checkins
     *   }
     * })
     * 
     */
    create<T extends student_checkinsCreateArgs>(args: SelectSubset<T, student_checkinsCreateArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Student_checkins.
     * @param {student_checkinsCreateManyArgs} args - Arguments to create many Student_checkins.
     * @example
     * // Create many Student_checkins
     * const student_checkins = await prisma.student_checkins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_checkinsCreateManyArgs>(args?: SelectSubset<T, student_checkinsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_checkins and returns the data saved in the database.
     * @param {student_checkinsCreateManyAndReturnArgs} args - Arguments to create many Student_checkins.
     * @example
     * // Create many Student_checkins
     * const student_checkins = await prisma.student_checkins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_checkins and only return the `id`
     * const student_checkinsWithIdOnly = await prisma.student_checkins.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_checkinsCreateManyAndReturnArgs>(args?: SelectSubset<T, student_checkinsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student_checkins.
     * @param {student_checkinsDeleteArgs} args - Arguments to delete one Student_checkins.
     * @example
     * // Delete one Student_checkins
     * const Student_checkins = await prisma.student_checkins.delete({
     *   where: {
     *     // ... filter to delete one Student_checkins
     *   }
     * })
     * 
     */
    delete<T extends student_checkinsDeleteArgs>(args: SelectSubset<T, student_checkinsDeleteArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student_checkins.
     * @param {student_checkinsUpdateArgs} args - Arguments to update one Student_checkins.
     * @example
     * // Update one Student_checkins
     * const student_checkins = await prisma.student_checkins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_checkinsUpdateArgs>(args: SelectSubset<T, student_checkinsUpdateArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Student_checkins.
     * @param {student_checkinsDeleteManyArgs} args - Arguments to filter Student_checkins to delete.
     * @example
     * // Delete a few Student_checkins
     * const { count } = await prisma.student_checkins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_checkinsDeleteManyArgs>(args?: SelectSubset<T, student_checkinsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_checkins
     * const student_checkins = await prisma.student_checkins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_checkinsUpdateManyArgs>(args: SelectSubset<T, student_checkinsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student_checkins.
     * @param {student_checkinsUpsertArgs} args - Arguments to update or create a Student_checkins.
     * @example
     * // Update or create a Student_checkins
     * const student_checkins = await prisma.student_checkins.upsert({
     *   create: {
     *     // ... data to create a Student_checkins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_checkins we want to update
     *   }
     * })
     */
    upsert<T extends student_checkinsUpsertArgs>(args: SelectSubset<T, student_checkinsUpsertArgs<ExtArgs>>): Prisma__student_checkinsClient<$Result.GetResult<Prisma.$student_checkinsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Student_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsCountArgs} args - Arguments to filter Student_checkins to count.
     * @example
     * // Count the number of Student_checkins
     * const count = await prisma.student_checkins.count({
     *   where: {
     *     // ... the filter for the Student_checkins we want to count
     *   }
     * })
    **/
    count<T extends student_checkinsCountArgs>(
      args?: Subset<T, student_checkinsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_checkinsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_checkinsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_checkinsAggregateArgs>(args: Subset<T, Student_checkinsAggregateArgs>): Prisma.PrismaPromise<GetStudent_checkinsAggregateType<T>>

    /**
     * Group by Student_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_checkinsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_checkinsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_checkinsGroupByArgs['orderBy'] }
        : { orderBy?: student_checkinsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_checkinsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_checkinsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_checkins model
   */
  readonly fields: student_checkinsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_checkins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_checkinsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_checkins model
   */ 
  interface student_checkinsFieldRefs {
    readonly id: FieldRef<"student_checkins", 'String'>
    readonly studentId: FieldRef<"student_checkins", 'String'>
    readonly schoolId: FieldRef<"student_checkins", 'String'>
    readonly checkinDate: FieldRef<"student_checkins", 'String'>
    readonly checkedBy: FieldRef<"student_checkins", 'String'>
    readonly createdAt: FieldRef<"student_checkins", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_checkins findUnique
   */
  export type student_checkinsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter, which student_checkins to fetch.
     */
    where: student_checkinsWhereUniqueInput
  }

  /**
   * student_checkins findUniqueOrThrow
   */
  export type student_checkinsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter, which student_checkins to fetch.
     */
    where: student_checkinsWhereUniqueInput
  }

  /**
   * student_checkins findFirst
   */
  export type student_checkinsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter, which student_checkins to fetch.
     */
    where?: student_checkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_checkins to fetch.
     */
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_checkins.
     */
    cursor?: student_checkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_checkins.
     */
    distinct?: Student_checkinsScalarFieldEnum | Student_checkinsScalarFieldEnum[]
  }

  /**
   * student_checkins findFirstOrThrow
   */
  export type student_checkinsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter, which student_checkins to fetch.
     */
    where?: student_checkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_checkins to fetch.
     */
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_checkins.
     */
    cursor?: student_checkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_checkins.
     */
    distinct?: Student_checkinsScalarFieldEnum | Student_checkinsScalarFieldEnum[]
  }

  /**
   * student_checkins findMany
   */
  export type student_checkinsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter, which student_checkins to fetch.
     */
    where?: student_checkinsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_checkins to fetch.
     */
    orderBy?: student_checkinsOrderByWithRelationInput | student_checkinsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_checkins.
     */
    cursor?: student_checkinsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_checkins.
     */
    skip?: number
    distinct?: Student_checkinsScalarFieldEnum | Student_checkinsScalarFieldEnum[]
  }

  /**
   * student_checkins create
   */
  export type student_checkinsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * The data needed to create a student_checkins.
     */
    data: XOR<student_checkinsCreateInput, student_checkinsUncheckedCreateInput>
  }

  /**
   * student_checkins createMany
   */
  export type student_checkinsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_checkins.
     */
    data: student_checkinsCreateManyInput | student_checkinsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_checkins createManyAndReturn
   */
  export type student_checkinsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many student_checkins.
     */
    data: student_checkinsCreateManyInput | student_checkinsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_checkins update
   */
  export type student_checkinsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * The data needed to update a student_checkins.
     */
    data: XOR<student_checkinsUpdateInput, student_checkinsUncheckedUpdateInput>
    /**
     * Choose, which student_checkins to update.
     */
    where: student_checkinsWhereUniqueInput
  }

  /**
   * student_checkins updateMany
   */
  export type student_checkinsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_checkins.
     */
    data: XOR<student_checkinsUpdateManyMutationInput, student_checkinsUncheckedUpdateManyInput>
    /**
     * Filter which student_checkins to update
     */
    where?: student_checkinsWhereInput
  }

  /**
   * student_checkins upsert
   */
  export type student_checkinsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * The filter to search for the student_checkins to update in case it exists.
     */
    where: student_checkinsWhereUniqueInput
    /**
     * In case the student_checkins found by the `where` argument doesn't exist, create a new student_checkins with this data.
     */
    create: XOR<student_checkinsCreateInput, student_checkinsUncheckedCreateInput>
    /**
     * In case the student_checkins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_checkinsUpdateInput, student_checkinsUncheckedUpdateInput>
  }

  /**
   * student_checkins delete
   */
  export type student_checkinsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
    /**
     * Filter which student_checkins to delete.
     */
    where: student_checkinsWhereUniqueInput
  }

  /**
   * student_checkins deleteMany
   */
  export type student_checkinsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_checkins to delete
     */
    where?: student_checkinsWhereInput
  }

  /**
   * student_checkins without action
   */
  export type student_checkinsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_checkins
     */
    select?: student_checkinsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_checkinsInclude<ExtArgs> | null
  }


  /**
   * Model task_library
   */

  export type AggregateTask_library = {
    _count: Task_libraryCountAggregateOutputType | null
    _avg: Task_libraryAvgAggregateOutputType | null
    _sum: Task_librarySumAggregateOutputType | null
    _min: Task_libraryMinAggregateOutputType | null
    _max: Task_libraryMaxAggregateOutputType | null
  }

  export type Task_libraryAvgAggregateOutputType = {
    defaultExp: number | null
    difficulty: number | null
  }

  export type Task_librarySumAggregateOutputType = {
    defaultExp: number | null
    difficulty: number | null
  }

  export type Task_libraryMinAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    description: string | null
    defaultExp: number | null
    type: $Enums.TaskType | null
    difficulty: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    isGlobal: boolean | null
    educationalDomain: string | null
    educationalSubcategory: string | null
  }

  export type Task_libraryMaxAggregateOutputType = {
    id: string | null
    category: string | null
    name: string | null
    description: string | null
    defaultExp: number | null
    type: $Enums.TaskType | null
    difficulty: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    schoolId: string | null
    isGlobal: boolean | null
    educationalDomain: string | null
    educationalSubcategory: string | null
  }

  export type Task_libraryCountAggregateOutputType = {
    id: number
    category: number
    name: number
    description: number
    defaultExp: number
    type: number
    difficulty: number
    isActive: number
    createdAt: number
    updatedAt: number
    schoolId: number
    isGlobal: number
    educationalDomain: number
    educationalSubcategory: number
    _all: number
  }


  export type Task_libraryAvgAggregateInputType = {
    defaultExp?: true
    difficulty?: true
  }

  export type Task_librarySumAggregateInputType = {
    defaultExp?: true
    difficulty?: true
  }

  export type Task_libraryMinAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    defaultExp?: true
    type?: true
    difficulty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    isGlobal?: true
    educationalDomain?: true
    educationalSubcategory?: true
  }

  export type Task_libraryMaxAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    defaultExp?: true
    type?: true
    difficulty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    isGlobal?: true
    educationalDomain?: true
    educationalSubcategory?: true
  }

  export type Task_libraryCountAggregateInputType = {
    id?: true
    category?: true
    name?: true
    description?: true
    defaultExp?: true
    type?: true
    difficulty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    schoolId?: true
    isGlobal?: true
    educationalDomain?: true
    educationalSubcategory?: true
    _all?: true
  }

  export type Task_libraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which task_library to aggregate.
     */
    where?: task_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_libraries to fetch.
     */
    orderBy?: task_libraryOrderByWithRelationInput | task_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: task_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned task_libraries
    **/
    _count?: true | Task_libraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Task_libraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Task_librarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Task_libraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Task_libraryMaxAggregateInputType
  }

  export type GetTask_libraryAggregateType<T extends Task_libraryAggregateArgs> = {
        [P in keyof T & keyof AggregateTask_library]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask_library[P]>
      : GetScalarType<T[P], AggregateTask_library[P]>
  }




  export type task_libraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_libraryWhereInput
    orderBy?: task_libraryOrderByWithAggregationInput | task_libraryOrderByWithAggregationInput[]
    by: Task_libraryScalarFieldEnum[] | Task_libraryScalarFieldEnum
    having?: task_libraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Task_libraryCountAggregateInputType | true
    _avg?: Task_libraryAvgAggregateInputType
    _sum?: Task_librarySumAggregateInputType
    _min?: Task_libraryMinAggregateInputType
    _max?: Task_libraryMaxAggregateInputType
  }

  export type Task_libraryGroupByOutputType = {
    id: string
    category: string
    name: string
    description: string | null
    defaultExp: number
    type: $Enums.TaskType
    difficulty: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    schoolId: string
    isGlobal: boolean
    educationalDomain: string
    educationalSubcategory: string
    _count: Task_libraryCountAggregateOutputType | null
    _avg: Task_libraryAvgAggregateOutputType | null
    _sum: Task_librarySumAggregateOutputType | null
    _min: Task_libraryMinAggregateOutputType | null
    _max: Task_libraryMaxAggregateOutputType | null
  }

  type GetTask_libraryGroupByPayload<T extends task_libraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Task_libraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Task_libraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Task_libraryGroupByOutputType[P]>
            : GetScalarType<T[P], Task_libraryGroupByOutputType[P]>
        }
      >
    >


  export type task_librarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    defaultExp?: boolean
    type?: boolean
    difficulty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    isGlobal?: boolean
    educationalDomain?: boolean
    educationalSubcategory?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task_library"]>

  export type task_librarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    defaultExp?: boolean
    type?: boolean
    difficulty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    isGlobal?: boolean
    educationalDomain?: boolean
    educationalSubcategory?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task_library"]>

  export type task_librarySelectScalar = {
    id?: boolean
    category?: boolean
    name?: boolean
    description?: boolean
    defaultExp?: boolean
    type?: boolean
    difficulty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schoolId?: boolean
    isGlobal?: boolean
    educationalDomain?: boolean
    educationalSubcategory?: boolean
  }

  export type task_libraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }
  export type task_libraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $task_libraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "task_library"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      name: string
      description: string | null
      defaultExp: number
      type: $Enums.TaskType
      difficulty: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      schoolId: string
      isGlobal: boolean
      educationalDomain: string
      educationalSubcategory: string
    }, ExtArgs["result"]["task_library"]>
    composites: {}
  }

  type task_libraryGetPayload<S extends boolean | null | undefined | task_libraryDefaultArgs> = $Result.GetResult<Prisma.$task_libraryPayload, S>

  type task_libraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<task_libraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Task_libraryCountAggregateInputType | true
    }

  export interface task_libraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['task_library'], meta: { name: 'task_library' } }
    /**
     * Find zero or one Task_library that matches the filter.
     * @param {task_libraryFindUniqueArgs} args - Arguments to find a Task_library
     * @example
     * // Get one Task_library
     * const task_library = await prisma.task_library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends task_libraryFindUniqueArgs>(args: SelectSubset<T, task_libraryFindUniqueArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task_library that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {task_libraryFindUniqueOrThrowArgs} args - Arguments to find a Task_library
     * @example
     * // Get one Task_library
     * const task_library = await prisma.task_library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends task_libraryFindUniqueOrThrowArgs>(args: SelectSubset<T, task_libraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task_library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryFindFirstArgs} args - Arguments to find a Task_library
     * @example
     * // Get one Task_library
     * const task_library = await prisma.task_library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends task_libraryFindFirstArgs>(args?: SelectSubset<T, task_libraryFindFirstArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task_library that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryFindFirstOrThrowArgs} args - Arguments to find a Task_library
     * @example
     * // Get one Task_library
     * const task_library = await prisma.task_library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends task_libraryFindFirstOrThrowArgs>(args?: SelectSubset<T, task_libraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Task_libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Task_libraries
     * const task_libraries = await prisma.task_library.findMany()
     * 
     * // Get first 10 Task_libraries
     * const task_libraries = await prisma.task_library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const task_libraryWithIdOnly = await prisma.task_library.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends task_libraryFindManyArgs>(args?: SelectSubset<T, task_libraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task_library.
     * @param {task_libraryCreateArgs} args - Arguments to create a Task_library.
     * @example
     * // Create one Task_library
     * const Task_library = await prisma.task_library.create({
     *   data: {
     *     // ... data to create a Task_library
     *   }
     * })
     * 
     */
    create<T extends task_libraryCreateArgs>(args: SelectSubset<T, task_libraryCreateArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Task_libraries.
     * @param {task_libraryCreateManyArgs} args - Arguments to create many Task_libraries.
     * @example
     * // Create many Task_libraries
     * const task_library = await prisma.task_library.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends task_libraryCreateManyArgs>(args?: SelectSubset<T, task_libraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Task_libraries and returns the data saved in the database.
     * @param {task_libraryCreateManyAndReturnArgs} args - Arguments to create many Task_libraries.
     * @example
     * // Create many Task_libraries
     * const task_library = await prisma.task_library.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Task_libraries and only return the `id`
     * const task_libraryWithIdOnly = await prisma.task_library.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends task_libraryCreateManyAndReturnArgs>(args?: SelectSubset<T, task_libraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task_library.
     * @param {task_libraryDeleteArgs} args - Arguments to delete one Task_library.
     * @example
     * // Delete one Task_library
     * const Task_library = await prisma.task_library.delete({
     *   where: {
     *     // ... filter to delete one Task_library
     *   }
     * })
     * 
     */
    delete<T extends task_libraryDeleteArgs>(args: SelectSubset<T, task_libraryDeleteArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task_library.
     * @param {task_libraryUpdateArgs} args - Arguments to update one Task_library.
     * @example
     * // Update one Task_library
     * const task_library = await prisma.task_library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends task_libraryUpdateArgs>(args: SelectSubset<T, task_libraryUpdateArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Task_libraries.
     * @param {task_libraryDeleteManyArgs} args - Arguments to filter Task_libraries to delete.
     * @example
     * // Delete a few Task_libraries
     * const { count } = await prisma.task_library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends task_libraryDeleteManyArgs>(args?: SelectSubset<T, task_libraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Task_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Task_libraries
     * const task_library = await prisma.task_library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends task_libraryUpdateManyArgs>(args: SelectSubset<T, task_libraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task_library.
     * @param {task_libraryUpsertArgs} args - Arguments to update or create a Task_library.
     * @example
     * // Update or create a Task_library
     * const task_library = await prisma.task_library.upsert({
     *   create: {
     *     // ... data to create a Task_library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task_library we want to update
     *   }
     * })
     */
    upsert<T extends task_libraryUpsertArgs>(args: SelectSubset<T, task_libraryUpsertArgs<ExtArgs>>): Prisma__task_libraryClient<$Result.GetResult<Prisma.$task_libraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Task_libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryCountArgs} args - Arguments to filter Task_libraries to count.
     * @example
     * // Count the number of Task_libraries
     * const count = await prisma.task_library.count({
     *   where: {
     *     // ... the filter for the Task_libraries we want to count
     *   }
     * })
    **/
    count<T extends task_libraryCountArgs>(
      args?: Subset<T, task_libraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Task_libraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task_library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Task_libraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Task_libraryAggregateArgs>(args: Subset<T, Task_libraryAggregateArgs>): Prisma.PrismaPromise<GetTask_libraryAggregateType<T>>

    /**
     * Group by Task_library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_libraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends task_libraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: task_libraryGroupByArgs['orderBy'] }
        : { orderBy?: task_libraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, task_libraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTask_libraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the task_library model
   */
  readonly fields: task_libraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for task_library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__task_libraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the task_library model
   */ 
  interface task_libraryFieldRefs {
    readonly id: FieldRef<"task_library", 'String'>
    readonly category: FieldRef<"task_library", 'String'>
    readonly name: FieldRef<"task_library", 'String'>
    readonly description: FieldRef<"task_library", 'String'>
    readonly defaultExp: FieldRef<"task_library", 'Int'>
    readonly type: FieldRef<"task_library", 'TaskType'>
    readonly difficulty: FieldRef<"task_library", 'Int'>
    readonly isActive: FieldRef<"task_library", 'Boolean'>
    readonly createdAt: FieldRef<"task_library", 'DateTime'>
    readonly updatedAt: FieldRef<"task_library", 'DateTime'>
    readonly schoolId: FieldRef<"task_library", 'String'>
    readonly isGlobal: FieldRef<"task_library", 'Boolean'>
    readonly educationalDomain: FieldRef<"task_library", 'String'>
    readonly educationalSubcategory: FieldRef<"task_library", 'String'>
  }
    

  // Custom InputTypes
  /**
   * task_library findUnique
   */
  export type task_libraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter, which task_library to fetch.
     */
    where: task_libraryWhereUniqueInput
  }

  /**
   * task_library findUniqueOrThrow
   */
  export type task_libraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter, which task_library to fetch.
     */
    where: task_libraryWhereUniqueInput
  }

  /**
   * task_library findFirst
   */
  export type task_libraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter, which task_library to fetch.
     */
    where?: task_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_libraries to fetch.
     */
    orderBy?: task_libraryOrderByWithRelationInput | task_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for task_libraries.
     */
    cursor?: task_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of task_libraries.
     */
    distinct?: Task_libraryScalarFieldEnum | Task_libraryScalarFieldEnum[]
  }

  /**
   * task_library findFirstOrThrow
   */
  export type task_libraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter, which task_library to fetch.
     */
    where?: task_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_libraries to fetch.
     */
    orderBy?: task_libraryOrderByWithRelationInput | task_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for task_libraries.
     */
    cursor?: task_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of task_libraries.
     */
    distinct?: Task_libraryScalarFieldEnum | Task_libraryScalarFieldEnum[]
  }

  /**
   * task_library findMany
   */
  export type task_libraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter, which task_libraries to fetch.
     */
    where?: task_libraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_libraries to fetch.
     */
    orderBy?: task_libraryOrderByWithRelationInput | task_libraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing task_libraries.
     */
    cursor?: task_libraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_libraries.
     */
    skip?: number
    distinct?: Task_libraryScalarFieldEnum | Task_libraryScalarFieldEnum[]
  }

  /**
   * task_library create
   */
  export type task_libraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * The data needed to create a task_library.
     */
    data: XOR<task_libraryCreateInput, task_libraryUncheckedCreateInput>
  }

  /**
   * task_library createMany
   */
  export type task_libraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many task_libraries.
     */
    data: task_libraryCreateManyInput | task_libraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * task_library createManyAndReturn
   */
  export type task_libraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many task_libraries.
     */
    data: task_libraryCreateManyInput | task_libraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * task_library update
   */
  export type task_libraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * The data needed to update a task_library.
     */
    data: XOR<task_libraryUpdateInput, task_libraryUncheckedUpdateInput>
    /**
     * Choose, which task_library to update.
     */
    where: task_libraryWhereUniqueInput
  }

  /**
   * task_library updateMany
   */
  export type task_libraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update task_libraries.
     */
    data: XOR<task_libraryUpdateManyMutationInput, task_libraryUncheckedUpdateManyInput>
    /**
     * Filter which task_libraries to update
     */
    where?: task_libraryWhereInput
  }

  /**
   * task_library upsert
   */
  export type task_libraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * The filter to search for the task_library to update in case it exists.
     */
    where: task_libraryWhereUniqueInput
    /**
     * In case the task_library found by the `where` argument doesn't exist, create a new task_library with this data.
     */
    create: XOR<task_libraryCreateInput, task_libraryUncheckedCreateInput>
    /**
     * In case the task_library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<task_libraryUpdateInput, task_libraryUncheckedUpdateInput>
  }

  /**
   * task_library delete
   */
  export type task_libraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
    /**
     * Filter which task_library to delete.
     */
    where: task_libraryWhereUniqueInput
  }

  /**
   * task_library deleteMany
   */
  export type task_libraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which task_libraries to delete
     */
    where?: task_libraryWhereInput
  }

  /**
   * task_library without action
   */
  export type task_libraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_library
     */
    select?: task_librarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_libraryInclude<ExtArgs> | null
  }


  /**
   * Model task_records
   */

  export type AggregateTask_records = {
    _count: Task_recordsCountAggregateOutputType | null
    _avg: Task_recordsAvgAggregateOutputType | null
    _sum: Task_recordsSumAggregateOutputType | null
    _min: Task_recordsMinAggregateOutputType | null
    _max: Task_recordsMaxAggregateOutputType | null
  }

  export type Task_recordsAvgAggregateOutputType = {
    expAwarded: number | null
    attempts: number | null
  }

  export type Task_recordsSumAggregateOutputType = {
    expAwarded: number | null
    attempts: number | null
  }

  export type Task_recordsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    type: $Enums.TaskType | null
    title: string | null
    status: $Enums.TaskStatus | null
    expAwarded: number | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lessonPlanId: string | null
    task_category: $Enums.TaskCategory | null
    is_current: boolean | null
    attempts: number | null
    subject: string | null
    isOverridden: boolean | null
    settledAt: Date | null
  }

  export type Task_recordsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    studentId: string | null
    type: $Enums.TaskType | null
    title: string | null
    status: $Enums.TaskStatus | null
    expAwarded: number | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lessonPlanId: string | null
    task_category: $Enums.TaskCategory | null
    is_current: boolean | null
    attempts: number | null
    subject: string | null
    isOverridden: boolean | null
    settledAt: Date | null
  }

  export type Task_recordsCountAggregateOutputType = {
    id: number
    schoolId: number
    studentId: number
    type: number
    title: number
    content: number
    status: number
    expAwarded: number
    submittedAt: number
    createdAt: number
    updatedAt: number
    lessonPlanId: number
    task_category: number
    is_current: number
    attempts: number
    subject: number
    isOverridden: number
    settledAt: number
    _all: number
  }


  export type Task_recordsAvgAggregateInputType = {
    expAwarded?: true
    attempts?: true
  }

  export type Task_recordsSumAggregateInputType = {
    expAwarded?: true
    attempts?: true
  }

  export type Task_recordsMinAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    type?: true
    title?: true
    status?: true
    expAwarded?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    lessonPlanId?: true
    task_category?: true
    is_current?: true
    attempts?: true
    subject?: true
    isOverridden?: true
    settledAt?: true
  }

  export type Task_recordsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    type?: true
    title?: true
    status?: true
    expAwarded?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    lessonPlanId?: true
    task_category?: true
    is_current?: true
    attempts?: true
    subject?: true
    isOverridden?: true
    settledAt?: true
  }

  export type Task_recordsCountAggregateInputType = {
    id?: true
    schoolId?: true
    studentId?: true
    type?: true
    title?: true
    content?: true
    status?: true
    expAwarded?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    lessonPlanId?: true
    task_category?: true
    is_current?: true
    attempts?: true
    subject?: true
    isOverridden?: true
    settledAt?: true
    _all?: true
  }

  export type Task_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which task_records to aggregate.
     */
    where?: task_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_records to fetch.
     */
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: task_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned task_records
    **/
    _count?: true | Task_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Task_recordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Task_recordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Task_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Task_recordsMaxAggregateInputType
  }

  export type GetTask_recordsAggregateType<T extends Task_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateTask_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask_records[P]>
      : GetScalarType<T[P], AggregateTask_records[P]>
  }




  export type task_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: task_recordsWhereInput
    orderBy?: task_recordsOrderByWithAggregationInput | task_recordsOrderByWithAggregationInput[]
    by: Task_recordsScalarFieldEnum[] | Task_recordsScalarFieldEnum
    having?: task_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Task_recordsCountAggregateInputType | true
    _avg?: Task_recordsAvgAggregateInputType
    _sum?: Task_recordsSumAggregateInputType
    _min?: Task_recordsMinAggregateInputType
    _max?: Task_recordsMaxAggregateInputType
  }

  export type Task_recordsGroupByOutputType = {
    id: string
    schoolId: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content: JsonValue | null
    status: $Enums.TaskStatus
    expAwarded: number
    submittedAt: Date | null
    createdAt: Date
    updatedAt: Date
    lessonPlanId: string | null
    task_category: $Enums.TaskCategory
    is_current: boolean
    attempts: number
    subject: string | null
    isOverridden: boolean
    settledAt: Date | null
    _count: Task_recordsCountAggregateOutputType | null
    _avg: Task_recordsAvgAggregateOutputType | null
    _sum: Task_recordsSumAggregateOutputType | null
    _min: Task_recordsMinAggregateOutputType | null
    _max: Task_recordsMaxAggregateOutputType | null
  }

  type GetTask_recordsGroupByPayload<T extends task_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Task_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Task_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Task_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Task_recordsGroupByOutputType[P]>
        }
      >
    >


  export type task_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    expAwarded?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lessonPlanId?: boolean
    task_category?: boolean
    is_current?: boolean
    attempts?: boolean
    subject?: boolean
    isOverridden?: boolean
    settledAt?: boolean
    lesson_plans?: boolean | task_records$lesson_plansArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task_records"]>

  export type task_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    expAwarded?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lessonPlanId?: boolean
    task_category?: boolean
    is_current?: boolean
    attempts?: boolean
    subject?: boolean
    isOverridden?: boolean
    settledAt?: boolean
    lesson_plans?: boolean | task_records$lesson_plansArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task_records"]>

  export type task_recordsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    expAwarded?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lessonPlanId?: boolean
    task_category?: boolean
    is_current?: boolean
    attempts?: boolean
    subject?: boolean
    isOverridden?: boolean
    settledAt?: boolean
  }

  export type task_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson_plans?: boolean | task_records$lesson_plansArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type task_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson_plans?: boolean | task_records$lesson_plansArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $task_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "task_records"
    objects: {
      lesson_plans: Prisma.$lesson_plansPayload<ExtArgs> | null
      schools: Prisma.$schoolsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      studentId: string
      type: $Enums.TaskType
      title: string
      content: Prisma.JsonValue | null
      status: $Enums.TaskStatus
      expAwarded: number
      submittedAt: Date | null
      createdAt: Date
      updatedAt: Date
      lessonPlanId: string | null
      task_category: $Enums.TaskCategory
      is_current: boolean
      attempts: number
      subject: string | null
      isOverridden: boolean
      settledAt: Date | null
    }, ExtArgs["result"]["task_records"]>
    composites: {}
  }

  type task_recordsGetPayload<S extends boolean | null | undefined | task_recordsDefaultArgs> = $Result.GetResult<Prisma.$task_recordsPayload, S>

  type task_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<task_recordsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Task_recordsCountAggregateInputType | true
    }

  export interface task_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['task_records'], meta: { name: 'task_records' } }
    /**
     * Find zero or one Task_records that matches the filter.
     * @param {task_recordsFindUniqueArgs} args - Arguments to find a Task_records
     * @example
     * // Get one Task_records
     * const task_records = await prisma.task_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends task_recordsFindUniqueArgs>(args: SelectSubset<T, task_recordsFindUniqueArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task_records that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {task_recordsFindUniqueOrThrowArgs} args - Arguments to find a Task_records
     * @example
     * // Get one Task_records
     * const task_records = await prisma.task_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends task_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, task_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsFindFirstArgs} args - Arguments to find a Task_records
     * @example
     * // Get one Task_records
     * const task_records = await prisma.task_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends task_recordsFindFirstArgs>(args?: SelectSubset<T, task_recordsFindFirstArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsFindFirstOrThrowArgs} args - Arguments to find a Task_records
     * @example
     * // Get one Task_records
     * const task_records = await prisma.task_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends task_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, task_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Task_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Task_records
     * const task_records = await prisma.task_records.findMany()
     * 
     * // Get first 10 Task_records
     * const task_records = await prisma.task_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const task_recordsWithIdOnly = await prisma.task_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends task_recordsFindManyArgs>(args?: SelectSubset<T, task_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task_records.
     * @param {task_recordsCreateArgs} args - Arguments to create a Task_records.
     * @example
     * // Create one Task_records
     * const Task_records = await prisma.task_records.create({
     *   data: {
     *     // ... data to create a Task_records
     *   }
     * })
     * 
     */
    create<T extends task_recordsCreateArgs>(args: SelectSubset<T, task_recordsCreateArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Task_records.
     * @param {task_recordsCreateManyArgs} args - Arguments to create many Task_records.
     * @example
     * // Create many Task_records
     * const task_records = await prisma.task_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends task_recordsCreateManyArgs>(args?: SelectSubset<T, task_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Task_records and returns the data saved in the database.
     * @param {task_recordsCreateManyAndReturnArgs} args - Arguments to create many Task_records.
     * @example
     * // Create many Task_records
     * const task_records = await prisma.task_records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Task_records and only return the `id`
     * const task_recordsWithIdOnly = await prisma.task_records.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends task_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, task_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task_records.
     * @param {task_recordsDeleteArgs} args - Arguments to delete one Task_records.
     * @example
     * // Delete one Task_records
     * const Task_records = await prisma.task_records.delete({
     *   where: {
     *     // ... filter to delete one Task_records
     *   }
     * })
     * 
     */
    delete<T extends task_recordsDeleteArgs>(args: SelectSubset<T, task_recordsDeleteArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task_records.
     * @param {task_recordsUpdateArgs} args - Arguments to update one Task_records.
     * @example
     * // Update one Task_records
     * const task_records = await prisma.task_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends task_recordsUpdateArgs>(args: SelectSubset<T, task_recordsUpdateArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Task_records.
     * @param {task_recordsDeleteManyArgs} args - Arguments to filter Task_records to delete.
     * @example
     * // Delete a few Task_records
     * const { count } = await prisma.task_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends task_recordsDeleteManyArgs>(args?: SelectSubset<T, task_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Task_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Task_records
     * const task_records = await prisma.task_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends task_recordsUpdateManyArgs>(args: SelectSubset<T, task_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task_records.
     * @param {task_recordsUpsertArgs} args - Arguments to update or create a Task_records.
     * @example
     * // Update or create a Task_records
     * const task_records = await prisma.task_records.upsert({
     *   create: {
     *     // ... data to create a Task_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task_records we want to update
     *   }
     * })
     */
    upsert<T extends task_recordsUpsertArgs>(args: SelectSubset<T, task_recordsUpsertArgs<ExtArgs>>): Prisma__task_recordsClient<$Result.GetResult<Prisma.$task_recordsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Task_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsCountArgs} args - Arguments to filter Task_records to count.
     * @example
     * // Count the number of Task_records
     * const count = await prisma.task_records.count({
     *   where: {
     *     // ... the filter for the Task_records we want to count
     *   }
     * })
    **/
    count<T extends task_recordsCountArgs>(
      args?: Subset<T, task_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Task_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Task_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Task_recordsAggregateArgs>(args: Subset<T, Task_recordsAggregateArgs>): Prisma.PrismaPromise<GetTask_recordsAggregateType<T>>

    /**
     * Group by Task_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {task_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends task_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: task_recordsGroupByArgs['orderBy'] }
        : { orderBy?: task_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, task_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTask_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the task_records model
   */
  readonly fields: task_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for task_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__task_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson_plans<T extends task_records$lesson_plansArgs<ExtArgs> = {}>(args?: Subset<T, task_records$lesson_plansArgs<ExtArgs>>): Prisma__lesson_plansClient<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the task_records model
   */ 
  interface task_recordsFieldRefs {
    readonly id: FieldRef<"task_records", 'String'>
    readonly schoolId: FieldRef<"task_records", 'String'>
    readonly studentId: FieldRef<"task_records", 'String'>
    readonly type: FieldRef<"task_records", 'TaskType'>
    readonly title: FieldRef<"task_records", 'String'>
    readonly content: FieldRef<"task_records", 'Json'>
    readonly status: FieldRef<"task_records", 'TaskStatus'>
    readonly expAwarded: FieldRef<"task_records", 'Int'>
    readonly submittedAt: FieldRef<"task_records", 'DateTime'>
    readonly createdAt: FieldRef<"task_records", 'DateTime'>
    readonly updatedAt: FieldRef<"task_records", 'DateTime'>
    readonly lessonPlanId: FieldRef<"task_records", 'String'>
    readonly task_category: FieldRef<"task_records", 'TaskCategory'>
    readonly is_current: FieldRef<"task_records", 'Boolean'>
    readonly attempts: FieldRef<"task_records", 'Int'>
    readonly subject: FieldRef<"task_records", 'String'>
    readonly isOverridden: FieldRef<"task_records", 'Boolean'>
    readonly settledAt: FieldRef<"task_records", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * task_records findUnique
   */
  export type task_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter, which task_records to fetch.
     */
    where: task_recordsWhereUniqueInput
  }

  /**
   * task_records findUniqueOrThrow
   */
  export type task_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter, which task_records to fetch.
     */
    where: task_recordsWhereUniqueInput
  }

  /**
   * task_records findFirst
   */
  export type task_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter, which task_records to fetch.
     */
    where?: task_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_records to fetch.
     */
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for task_records.
     */
    cursor?: task_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of task_records.
     */
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * task_records findFirstOrThrow
   */
  export type task_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter, which task_records to fetch.
     */
    where?: task_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_records to fetch.
     */
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for task_records.
     */
    cursor?: task_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of task_records.
     */
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * task_records findMany
   */
  export type task_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter, which task_records to fetch.
     */
    where?: task_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of task_records to fetch.
     */
    orderBy?: task_recordsOrderByWithRelationInput | task_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing task_records.
     */
    cursor?: task_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` task_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` task_records.
     */
    skip?: number
    distinct?: Task_recordsScalarFieldEnum | Task_recordsScalarFieldEnum[]
  }

  /**
   * task_records create
   */
  export type task_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a task_records.
     */
    data: XOR<task_recordsCreateInput, task_recordsUncheckedCreateInput>
  }

  /**
   * task_records createMany
   */
  export type task_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many task_records.
     */
    data: task_recordsCreateManyInput | task_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * task_records createManyAndReturn
   */
  export type task_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many task_records.
     */
    data: task_recordsCreateManyInput | task_recordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * task_records update
   */
  export type task_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a task_records.
     */
    data: XOR<task_recordsUpdateInput, task_recordsUncheckedUpdateInput>
    /**
     * Choose, which task_records to update.
     */
    where: task_recordsWhereUniqueInput
  }

  /**
   * task_records updateMany
   */
  export type task_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update task_records.
     */
    data: XOR<task_recordsUpdateManyMutationInput, task_recordsUncheckedUpdateManyInput>
    /**
     * Filter which task_records to update
     */
    where?: task_recordsWhereInput
  }

  /**
   * task_records upsert
   */
  export type task_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the task_records to update in case it exists.
     */
    where: task_recordsWhereUniqueInput
    /**
     * In case the task_records found by the `where` argument doesn't exist, create a new task_records with this data.
     */
    create: XOR<task_recordsCreateInput, task_recordsUncheckedCreateInput>
    /**
     * In case the task_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<task_recordsUpdateInput, task_recordsUncheckedUpdateInput>
  }

  /**
   * task_records delete
   */
  export type task_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
    /**
     * Filter which task_records to delete.
     */
    where: task_recordsWhereUniqueInput
  }

  /**
   * task_records deleteMany
   */
  export type task_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which task_records to delete
     */
    where?: task_recordsWhereInput
  }

  /**
   * task_records.lesson_plans
   */
  export type task_records$lesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    where?: lesson_plansWhereInput
  }

  /**
   * task_records without action
   */
  export type task_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the task_records
     */
    select?: task_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: task_recordsInclude<ExtArgs> | null
  }


  /**
   * Model teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    displayName: string | null
    primaryClassName: string | null
  }

  export type TeachersMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    displayName: string | null
    primaryClassName: string | null
  }

  export type TeachersCountAggregateOutputType = {
    id: number
    schoolId: number
    username: number
    password: number
    name: number
    email: number
    role: number
    createdAt: number
    updatedAt: number
    displayName: number
    primaryClassName: number
    _all: number
  }


  export type TeachersMinAggregateInputType = {
    id?: true
    schoolId?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    primaryClassName?: true
  }

  export type TeachersMaxAggregateInputType = {
    id?: true
    schoolId?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    primaryClassName?: true
  }

  export type TeachersCountAggregateInputType = {
    id?: true
    schoolId?: true
    username?: true
    password?: true
    name?: true
    email?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    displayName?: true
    primaryClassName?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to aggregate.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type teachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithAggregationInput | teachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: teachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    id: string
    schoolId: string | null
    username: string
    password: string
    name: string
    email: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    displayName: string | null
    primaryClassName: string | null
    _count: TeachersCountAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends teachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type teachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    primaryClassName?: boolean
    challenges?: boolean | teachers$challengesArgs<ExtArgs>
    lesson_plans?: boolean | teachers$lesson_plansArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | teachers$personalized_tutoring_plansArgs<ExtArgs>
    students?: boolean | teachers$studentsArgs<ExtArgs>
    schools?: boolean | teachers$schoolsArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    primaryClassName?: boolean
    schools?: boolean | teachers$schoolsArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectScalar = {
    id?: boolean
    schoolId?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    displayName?: boolean
    primaryClassName?: boolean
  }

  export type teachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenges?: boolean | teachers$challengesArgs<ExtArgs>
    lesson_plans?: boolean | teachers$lesson_plansArgs<ExtArgs>
    personalized_tutoring_plans?: boolean | teachers$personalized_tutoring_plansArgs<ExtArgs>
    students?: boolean | teachers$studentsArgs<ExtArgs>
    schools?: boolean | teachers$schoolsArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | teachers$schoolsArgs<ExtArgs>
  }

  export type $teachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teachers"
    objects: {
      challenges: Prisma.$challengesPayload<ExtArgs>[]
      lesson_plans: Prisma.$lesson_plansPayload<ExtArgs>[]
      personalized_tutoring_plans: Prisma.$personalized_tutoring_plansPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
      schools: Prisma.$schoolsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string | null
      username: string
      password: string
      name: string
      email: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      displayName: string | null
      primaryClassName: string | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type teachersGetPayload<S extends boolean | null | undefined | teachersDefaultArgs> = $Result.GetResult<Prisma.$teachersPayload, S>

  type teachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<teachersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface teachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teachers'], meta: { name: 'teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {teachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teachersFindUniqueArgs>(args: SelectSubset<T, teachersFindUniqueArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {teachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teachersFindUniqueOrThrowArgs>(args: SelectSubset<T, teachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teachersFindFirstArgs>(args?: SelectSubset<T, teachersFindFirstArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teachersFindFirstOrThrowArgs>(args?: SelectSubset<T, teachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachersWithIdOnly = await prisma.teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teachersFindManyArgs>(args?: SelectSubset<T, teachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teachers.
     * @param {teachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends teachersCreateArgs>(args: SelectSubset<T, teachersCreateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers.
     * @param {teachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teachersCreateManyArgs>(args?: SelectSubset<T, teachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {teachersCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teachersCreateManyAndReturnArgs>(args?: SelectSubset<T, teachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Teachers.
     * @param {teachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends teachersDeleteArgs>(args: SelectSubset<T, teachersDeleteArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teachers.
     * @param {teachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teachersUpdateArgs>(args: SelectSubset<T, teachersUpdateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {teachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teachersDeleteManyArgs>(args?: SelectSubset<T, teachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teachersUpdateManyArgs>(args: SelectSubset<T, teachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teachers.
     * @param {teachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends teachersUpsertArgs>(args: SelectSubset<T, teachersUpsertArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teachersCountArgs>(
      args?: Subset<T, teachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teachersGroupByArgs['orderBy'] }
        : { orderBy?: teachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teachers model
   */
  readonly fields: teachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenges<T extends teachers$challengesArgs<ExtArgs> = {}>(args?: Subset<T, teachers$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$challengesPayload<ExtArgs>, T, "findMany"> | Null>
    lesson_plans<T extends teachers$lesson_plansArgs<ExtArgs> = {}>(args?: Subset<T, teachers$lesson_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lesson_plansPayload<ExtArgs>, T, "findMany"> | Null>
    personalized_tutoring_plans<T extends teachers$personalized_tutoring_plansArgs<ExtArgs> = {}>(args?: Subset<T, teachers$personalized_tutoring_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends teachers$studentsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany"> | Null>
    schools<T extends teachers$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$schoolsArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teachers model
   */ 
  interface teachersFieldRefs {
    readonly id: FieldRef<"teachers", 'String'>
    readonly schoolId: FieldRef<"teachers", 'String'>
    readonly username: FieldRef<"teachers", 'String'>
    readonly password: FieldRef<"teachers", 'String'>
    readonly name: FieldRef<"teachers", 'String'>
    readonly email: FieldRef<"teachers", 'String'>
    readonly role: FieldRef<"teachers", 'Role'>
    readonly createdAt: FieldRef<"teachers", 'DateTime'>
    readonly updatedAt: FieldRef<"teachers", 'DateTime'>
    readonly displayName: FieldRef<"teachers", 'String'>
    readonly primaryClassName: FieldRef<"teachers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * teachers findUnique
   */
  export type teachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findUniqueOrThrow
   */
  export type teachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findFirst
   */
  export type teachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findFirstOrThrow
   */
  export type teachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findMany
   */
  export type teachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers create
   */
  export type teachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to create a teachers.
     */
    data: XOR<teachersCreateInput, teachersUncheckedCreateInput>
  }

  /**
   * teachers createMany
   */
  export type teachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teachers createManyAndReturn
   */
  export type teachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teachers update
   */
  export type teachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to update a teachers.
     */
    data: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
    /**
     * Choose, which teachers to update.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers updateMany
   */
  export type teachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
  }

  /**
   * teachers upsert
   */
  export type teachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The filter to search for the teachers to update in case it exists.
     */
    where: teachersWhereUniqueInput
    /**
     * In case the teachers found by the `where` argument doesn't exist, create a new teachers with this data.
     */
    create: XOR<teachersCreateInput, teachersUncheckedCreateInput>
    /**
     * In case the teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
  }

  /**
   * teachers delete
   */
  export type teachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter which teachers to delete.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers deleteMany
   */
  export type teachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teachersWhereInput
  }

  /**
   * teachers.challenges
   */
  export type teachers$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the challenges
     */
    select?: challengesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: challengesInclude<ExtArgs> | null
    where?: challengesWhereInput
    orderBy?: challengesOrderByWithRelationInput | challengesOrderByWithRelationInput[]
    cursor?: challengesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengesScalarFieldEnum | ChallengesScalarFieldEnum[]
  }

  /**
   * teachers.lesson_plans
   */
  export type teachers$lesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson_plans
     */
    select?: lesson_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lesson_plansInclude<ExtArgs> | null
    where?: lesson_plansWhereInput
    orderBy?: lesson_plansOrderByWithRelationInput | lesson_plansOrderByWithRelationInput[]
    cursor?: lesson_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Lesson_plansScalarFieldEnum | Lesson_plansScalarFieldEnum[]
  }

  /**
   * teachers.personalized_tutoring_plans
   */
  export type teachers$personalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    where?: personalized_tutoring_plansWhereInput
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    cursor?: personalized_tutoring_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * teachers.students
   */
  export type teachers$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * teachers.schools
   */
  export type teachers$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schools
     */
    select?: schoolsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: schoolsInclude<ExtArgs> | null
    where?: schoolsWhereInput
  }

  /**
   * teachers without action
   */
  export type teachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
  }


  /**
   * Model personalized_tutoring_plans
   */

  export type AggregatePersonalized_tutoring_plans = {
    _count: Personalized_tutoring_plansCountAggregateOutputType | null
    _avg: Personalized_tutoring_plansAvgAggregateOutputType | null
    _sum: Personalized_tutoring_plansSumAggregateOutputType | null
    _min: Personalized_tutoring_plansMinAggregateOutputType | null
    _max: Personalized_tutoring_plansMaxAggregateOutputType | null
  }

  export type Personalized_tutoring_plansAvgAggregateOutputType = {
    difficulty: number | null
    duration: number | null
    expReward: number | null
    pointsReward: number | null
    effectivenessRating: number | null
    totalSessions: number | null
    completedSessions: number | null
  }

  export type Personalized_tutoring_plansSumAggregateOutputType = {
    difficulty: number | null
    duration: number | null
    expReward: number | null
    pointsReward: number | null
    effectivenessRating: number | null
    totalSessions: number | null
    completedSessions: number | null
  }

  export type Personalized_tutoring_plansMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    schoolId: string | null
    title: string | null
    subject: string | null
    difficulty: number | null
    scheduledDate: string | null
    scheduledTime: string | null
    duration: number | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    studentId: string | null
    studentName: string | null
    studentClass: string | null
    mainProblem: string | null
    detailedContent: string | null
    teachingObjectives: string | null
    preparationMaterials: string | null
    expReward: number | null
    pointsReward: number | null
    expAwarded: boolean | null
    pointsAwarded: boolean | null
    status: string | null
    completionNotes: string | null
    studentFeedback: string | null
    parentFeedback: string | null
    effectivenessRating: number | null
    followUpRequired: boolean | null
    followUpDate: string | null
    followUpNotes: string | null
    totalSessions: number | null
    completedSessions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Personalized_tutoring_plansMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    schoolId: string | null
    title: string | null
    subject: string | null
    difficulty: number | null
    scheduledDate: string | null
    scheduledTime: string | null
    duration: number | null
    actualStartTime: Date | null
    actualEndTime: Date | null
    studentId: string | null
    studentName: string | null
    studentClass: string | null
    mainProblem: string | null
    detailedContent: string | null
    teachingObjectives: string | null
    preparationMaterials: string | null
    expReward: number | null
    pointsReward: number | null
    expAwarded: boolean | null
    pointsAwarded: boolean | null
    status: string | null
    completionNotes: string | null
    studentFeedback: string | null
    parentFeedback: string | null
    effectivenessRating: number | null
    followUpRequired: boolean | null
    followUpDate: string | null
    followUpNotes: string | null
    totalSessions: number | null
    completedSessions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Personalized_tutoring_plansCountAggregateOutputType = {
    id: number
    teacherId: number
    schoolId: number
    title: number
    subject: number
    difficulty: number
    scheduledDate: number
    scheduledTime: number
    duration: number
    actualStartTime: number
    actualEndTime: number
    studentId: number
    studentName: number
    studentClass: number
    knowledgePoints: number
    mainProblem: number
    detailedContent: number
    teachingObjectives: number
    preparationMaterials: number
    tutoringMethods: number
    expReward: number
    pointsReward: number
    expAwarded: number
    pointsAwarded: number
    status: number
    completionNotes: number
    studentFeedback: number
    parentFeedback: number
    effectivenessRating: number
    followUpRequired: number
    followUpDate: number
    followUpNotes: number
    attachments: number
    totalSessions: number
    completedSessions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Personalized_tutoring_plansAvgAggregateInputType = {
    difficulty?: true
    duration?: true
    expReward?: true
    pointsReward?: true
    effectivenessRating?: true
    totalSessions?: true
    completedSessions?: true
  }

  export type Personalized_tutoring_plansSumAggregateInputType = {
    difficulty?: true
    duration?: true
    expReward?: true
    pointsReward?: true
    effectivenessRating?: true
    totalSessions?: true
    completedSessions?: true
  }

  export type Personalized_tutoring_plansMinAggregateInputType = {
    id?: true
    teacherId?: true
    schoolId?: true
    title?: true
    subject?: true
    difficulty?: true
    scheduledDate?: true
    scheduledTime?: true
    duration?: true
    actualStartTime?: true
    actualEndTime?: true
    studentId?: true
    studentName?: true
    studentClass?: true
    mainProblem?: true
    detailedContent?: true
    teachingObjectives?: true
    preparationMaterials?: true
    expReward?: true
    pointsReward?: true
    expAwarded?: true
    pointsAwarded?: true
    status?: true
    completionNotes?: true
    studentFeedback?: true
    parentFeedback?: true
    effectivenessRating?: true
    followUpRequired?: true
    followUpDate?: true
    followUpNotes?: true
    totalSessions?: true
    completedSessions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Personalized_tutoring_plansMaxAggregateInputType = {
    id?: true
    teacherId?: true
    schoolId?: true
    title?: true
    subject?: true
    difficulty?: true
    scheduledDate?: true
    scheduledTime?: true
    duration?: true
    actualStartTime?: true
    actualEndTime?: true
    studentId?: true
    studentName?: true
    studentClass?: true
    mainProblem?: true
    detailedContent?: true
    teachingObjectives?: true
    preparationMaterials?: true
    expReward?: true
    pointsReward?: true
    expAwarded?: true
    pointsAwarded?: true
    status?: true
    completionNotes?: true
    studentFeedback?: true
    parentFeedback?: true
    effectivenessRating?: true
    followUpRequired?: true
    followUpDate?: true
    followUpNotes?: true
    totalSessions?: true
    completedSessions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Personalized_tutoring_plansCountAggregateInputType = {
    id?: true
    teacherId?: true
    schoolId?: true
    title?: true
    subject?: true
    difficulty?: true
    scheduledDate?: true
    scheduledTime?: true
    duration?: true
    actualStartTime?: true
    actualEndTime?: true
    studentId?: true
    studentName?: true
    studentClass?: true
    knowledgePoints?: true
    mainProblem?: true
    detailedContent?: true
    teachingObjectives?: true
    preparationMaterials?: true
    tutoringMethods?: true
    expReward?: true
    pointsReward?: true
    expAwarded?: true
    pointsAwarded?: true
    status?: true
    completionNotes?: true
    studentFeedback?: true
    parentFeedback?: true
    effectivenessRating?: true
    followUpRequired?: true
    followUpDate?: true
    followUpNotes?: true
    attachments?: true
    totalSessions?: true
    completedSessions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Personalized_tutoring_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personalized_tutoring_plans to aggregate.
     */
    where?: personalized_tutoring_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalized_tutoring_plans to fetch.
     */
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personalized_tutoring_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalized_tutoring_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalized_tutoring_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personalized_tutoring_plans
    **/
    _count?: true | Personalized_tutoring_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personalized_tutoring_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personalized_tutoring_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personalized_tutoring_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personalized_tutoring_plansMaxAggregateInputType
  }

  export type GetPersonalized_tutoring_plansAggregateType<T extends Personalized_tutoring_plansAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalized_tutoring_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalized_tutoring_plans[P]>
      : GetScalarType<T[P], AggregatePersonalized_tutoring_plans[P]>
  }




  export type personalized_tutoring_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalized_tutoring_plansWhereInput
    orderBy?: personalized_tutoring_plansOrderByWithAggregationInput | personalized_tutoring_plansOrderByWithAggregationInput[]
    by: Personalized_tutoring_plansScalarFieldEnum[] | Personalized_tutoring_plansScalarFieldEnum
    having?: personalized_tutoring_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personalized_tutoring_plansCountAggregateInputType | true
    _avg?: Personalized_tutoring_plansAvgAggregateInputType
    _sum?: Personalized_tutoring_plansSumAggregateInputType
    _min?: Personalized_tutoring_plansMinAggregateInputType
    _max?: Personalized_tutoring_plansMaxAggregateInputType
  }

  export type Personalized_tutoring_plansGroupByOutputType = {
    id: string
    teacherId: string
    schoolId: string
    title: string
    subject: string
    difficulty: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime: Date | null
    actualEndTime: Date | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonValue
    mainProblem: string
    detailedContent: string | null
    teachingObjectives: string | null
    preparationMaterials: string | null
    tutoringMethods: JsonValue
    expReward: number
    pointsReward: number
    expAwarded: boolean
    pointsAwarded: boolean
    status: string
    completionNotes: string | null
    studentFeedback: string | null
    parentFeedback: string | null
    effectivenessRating: number | null
    followUpRequired: boolean
    followUpDate: string | null
    followUpNotes: string | null
    attachments: JsonValue | null
    totalSessions: number
    completedSessions: number
    createdAt: Date
    updatedAt: Date
    _count: Personalized_tutoring_plansCountAggregateOutputType | null
    _avg: Personalized_tutoring_plansAvgAggregateOutputType | null
    _sum: Personalized_tutoring_plansSumAggregateOutputType | null
    _min: Personalized_tutoring_plansMinAggregateOutputType | null
    _max: Personalized_tutoring_plansMaxAggregateOutputType | null
  }

  type GetPersonalized_tutoring_plansGroupByPayload<T extends personalized_tutoring_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Personalized_tutoring_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personalized_tutoring_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personalized_tutoring_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Personalized_tutoring_plansGroupByOutputType[P]>
        }
      >
    >


  export type personalized_tutoring_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    schoolId?: boolean
    title?: boolean
    subject?: boolean
    difficulty?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    duration?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    studentId?: boolean
    studentName?: boolean
    studentClass?: boolean
    knowledgePoints?: boolean
    mainProblem?: boolean
    detailedContent?: boolean
    teachingObjectives?: boolean
    preparationMaterials?: boolean
    tutoringMethods?: boolean
    expReward?: boolean
    pointsReward?: boolean
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: boolean
    completionNotes?: boolean
    studentFeedback?: boolean
    parentFeedback?: boolean
    effectivenessRating?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    attachments?: boolean
    totalSessions?: boolean
    completedSessions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalized_tutoring_plans"]>

  export type personalized_tutoring_plansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    schoolId?: boolean
    title?: boolean
    subject?: boolean
    difficulty?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    duration?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    studentId?: boolean
    studentName?: boolean
    studentClass?: boolean
    knowledgePoints?: boolean
    mainProblem?: boolean
    detailedContent?: boolean
    teachingObjectives?: boolean
    preparationMaterials?: boolean
    tutoringMethods?: boolean
    expReward?: boolean
    pointsReward?: boolean
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: boolean
    completionNotes?: boolean
    studentFeedback?: boolean
    parentFeedback?: boolean
    effectivenessRating?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    attachments?: boolean
    totalSessions?: boolean
    completedSessions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalized_tutoring_plans"]>

  export type personalized_tutoring_plansSelectScalar = {
    id?: boolean
    teacherId?: boolean
    schoolId?: boolean
    title?: boolean
    subject?: boolean
    difficulty?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    duration?: boolean
    actualStartTime?: boolean
    actualEndTime?: boolean
    studentId?: boolean
    studentName?: boolean
    studentClass?: boolean
    knowledgePoints?: boolean
    mainProblem?: boolean
    detailedContent?: boolean
    teachingObjectives?: boolean
    preparationMaterials?: boolean
    tutoringMethods?: boolean
    expReward?: boolean
    pointsReward?: boolean
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: boolean
    completionNotes?: boolean
    studentFeedback?: boolean
    parentFeedback?: boolean
    effectivenessRating?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    followUpNotes?: boolean
    attachments?: boolean
    totalSessions?: boolean
    completedSessions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type personalized_tutoring_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type personalized_tutoring_plansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $personalized_tutoring_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "personalized_tutoring_plans"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      schoolId: string
      title: string
      subject: string
      difficulty: number
      scheduledDate: string
      scheduledTime: string
      duration: number
      actualStartTime: Date | null
      actualEndTime: Date | null
      studentId: string
      studentName: string
      studentClass: string
      knowledgePoints: Prisma.JsonValue
      mainProblem: string
      detailedContent: string | null
      teachingObjectives: string | null
      preparationMaterials: string | null
      tutoringMethods: Prisma.JsonValue
      expReward: number
      pointsReward: number
      expAwarded: boolean
      pointsAwarded: boolean
      status: string
      completionNotes: string | null
      studentFeedback: string | null
      parentFeedback: string | null
      effectivenessRating: number | null
      followUpRequired: boolean
      followUpDate: string | null
      followUpNotes: string | null
      attachments: Prisma.JsonValue | null
      totalSessions: number
      completedSessions: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["personalized_tutoring_plans"]>
    composites: {}
  }

  type personalized_tutoring_plansGetPayload<S extends boolean | null | undefined | personalized_tutoring_plansDefaultArgs> = $Result.GetResult<Prisma.$personalized_tutoring_plansPayload, S>

  type personalized_tutoring_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<personalized_tutoring_plansFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Personalized_tutoring_plansCountAggregateInputType | true
    }

  export interface personalized_tutoring_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personalized_tutoring_plans'], meta: { name: 'personalized_tutoring_plans' } }
    /**
     * Find zero or one Personalized_tutoring_plans that matches the filter.
     * @param {personalized_tutoring_plansFindUniqueArgs} args - Arguments to find a Personalized_tutoring_plans
     * @example
     * // Get one Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends personalized_tutoring_plansFindUniqueArgs>(args: SelectSubset<T, personalized_tutoring_plansFindUniqueArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Personalized_tutoring_plans that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {personalized_tutoring_plansFindUniqueOrThrowArgs} args - Arguments to find a Personalized_tutoring_plans
     * @example
     * // Get one Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends personalized_tutoring_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, personalized_tutoring_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Personalized_tutoring_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansFindFirstArgs} args - Arguments to find a Personalized_tutoring_plans
     * @example
     * // Get one Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends personalized_tutoring_plansFindFirstArgs>(args?: SelectSubset<T, personalized_tutoring_plansFindFirstArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Personalized_tutoring_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansFindFirstOrThrowArgs} args - Arguments to find a Personalized_tutoring_plans
     * @example
     * // Get one Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends personalized_tutoring_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, personalized_tutoring_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personalized_tutoring_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findMany()
     * 
     * // Get first 10 Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalized_tutoring_plansWithIdOnly = await prisma.personalized_tutoring_plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends personalized_tutoring_plansFindManyArgs>(args?: SelectSubset<T, personalized_tutoring_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansCreateArgs} args - Arguments to create a Personalized_tutoring_plans.
     * @example
     * // Create one Personalized_tutoring_plans
     * const Personalized_tutoring_plans = await prisma.personalized_tutoring_plans.create({
     *   data: {
     *     // ... data to create a Personalized_tutoring_plans
     *   }
     * })
     * 
     */
    create<T extends personalized_tutoring_plansCreateArgs>(args: SelectSubset<T, personalized_tutoring_plansCreateArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansCreateManyArgs} args - Arguments to create many Personalized_tutoring_plans.
     * @example
     * // Create many Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends personalized_tutoring_plansCreateManyArgs>(args?: SelectSubset<T, personalized_tutoring_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personalized_tutoring_plans and returns the data saved in the database.
     * @param {personalized_tutoring_plansCreateManyAndReturnArgs} args - Arguments to create many Personalized_tutoring_plans.
     * @example
     * // Create many Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personalized_tutoring_plans and only return the `id`
     * const personalized_tutoring_plansWithIdOnly = await prisma.personalized_tutoring_plans.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends personalized_tutoring_plansCreateManyAndReturnArgs>(args?: SelectSubset<T, personalized_tutoring_plansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansDeleteArgs} args - Arguments to delete one Personalized_tutoring_plans.
     * @example
     * // Delete one Personalized_tutoring_plans
     * const Personalized_tutoring_plans = await prisma.personalized_tutoring_plans.delete({
     *   where: {
     *     // ... filter to delete one Personalized_tutoring_plans
     *   }
     * })
     * 
     */
    delete<T extends personalized_tutoring_plansDeleteArgs>(args: SelectSubset<T, personalized_tutoring_plansDeleteArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansUpdateArgs} args - Arguments to update one Personalized_tutoring_plans.
     * @example
     * // Update one Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends personalized_tutoring_plansUpdateArgs>(args: SelectSubset<T, personalized_tutoring_plansUpdateArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansDeleteManyArgs} args - Arguments to filter Personalized_tutoring_plans to delete.
     * @example
     * // Delete a few Personalized_tutoring_plans
     * const { count } = await prisma.personalized_tutoring_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends personalized_tutoring_plansDeleteManyArgs>(args?: SelectSubset<T, personalized_tutoring_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personalized_tutoring_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends personalized_tutoring_plansUpdateManyArgs>(args: SelectSubset<T, personalized_tutoring_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personalized_tutoring_plans.
     * @param {personalized_tutoring_plansUpsertArgs} args - Arguments to update or create a Personalized_tutoring_plans.
     * @example
     * // Update or create a Personalized_tutoring_plans
     * const personalized_tutoring_plans = await prisma.personalized_tutoring_plans.upsert({
     *   create: {
     *     // ... data to create a Personalized_tutoring_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personalized_tutoring_plans we want to update
     *   }
     * })
     */
    upsert<T extends personalized_tutoring_plansUpsertArgs>(args: SelectSubset<T, personalized_tutoring_plansUpsertArgs<ExtArgs>>): Prisma__personalized_tutoring_plansClient<$Result.GetResult<Prisma.$personalized_tutoring_plansPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personalized_tutoring_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansCountArgs} args - Arguments to filter Personalized_tutoring_plans to count.
     * @example
     * // Count the number of Personalized_tutoring_plans
     * const count = await prisma.personalized_tutoring_plans.count({
     *   where: {
     *     // ... the filter for the Personalized_tutoring_plans we want to count
     *   }
     * })
    **/
    count<T extends personalized_tutoring_plansCountArgs>(
      args?: Subset<T, personalized_tutoring_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personalized_tutoring_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personalized_tutoring_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personalized_tutoring_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personalized_tutoring_plansAggregateArgs>(args: Subset<T, Personalized_tutoring_plansAggregateArgs>): Prisma.PrismaPromise<GetPersonalized_tutoring_plansAggregateType<T>>

    /**
     * Group by Personalized_tutoring_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalized_tutoring_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personalized_tutoring_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personalized_tutoring_plansGroupByArgs['orderBy'] }
        : { orderBy?: personalized_tutoring_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personalized_tutoring_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalized_tutoring_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the personalized_tutoring_plans model
   */
  readonly fields: personalized_tutoring_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for personalized_tutoring_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__personalized_tutoring_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the personalized_tutoring_plans model
   */ 
  interface personalized_tutoring_plansFieldRefs {
    readonly id: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly teacherId: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly schoolId: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly title: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly subject: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly difficulty: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly scheduledDate: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly scheduledTime: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly duration: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly actualStartTime: FieldRef<"personalized_tutoring_plans", 'DateTime'>
    readonly actualEndTime: FieldRef<"personalized_tutoring_plans", 'DateTime'>
    readonly studentId: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly studentName: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly studentClass: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly knowledgePoints: FieldRef<"personalized_tutoring_plans", 'Json'>
    readonly mainProblem: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly detailedContent: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly teachingObjectives: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly preparationMaterials: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly tutoringMethods: FieldRef<"personalized_tutoring_plans", 'Json'>
    readonly expReward: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly pointsReward: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly expAwarded: FieldRef<"personalized_tutoring_plans", 'Boolean'>
    readonly pointsAwarded: FieldRef<"personalized_tutoring_plans", 'Boolean'>
    readonly status: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly completionNotes: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly studentFeedback: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly parentFeedback: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly effectivenessRating: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly followUpRequired: FieldRef<"personalized_tutoring_plans", 'Boolean'>
    readonly followUpDate: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly followUpNotes: FieldRef<"personalized_tutoring_plans", 'String'>
    readonly attachments: FieldRef<"personalized_tutoring_plans", 'Json'>
    readonly totalSessions: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly completedSessions: FieldRef<"personalized_tutoring_plans", 'Int'>
    readonly createdAt: FieldRef<"personalized_tutoring_plans", 'DateTime'>
    readonly updatedAt: FieldRef<"personalized_tutoring_plans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * personalized_tutoring_plans findUnique
   */
  export type personalized_tutoring_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter, which personalized_tutoring_plans to fetch.
     */
    where: personalized_tutoring_plansWhereUniqueInput
  }

  /**
   * personalized_tutoring_plans findUniqueOrThrow
   */
  export type personalized_tutoring_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter, which personalized_tutoring_plans to fetch.
     */
    where: personalized_tutoring_plansWhereUniqueInput
  }

  /**
   * personalized_tutoring_plans findFirst
   */
  export type personalized_tutoring_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter, which personalized_tutoring_plans to fetch.
     */
    where?: personalized_tutoring_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalized_tutoring_plans to fetch.
     */
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personalized_tutoring_plans.
     */
    cursor?: personalized_tutoring_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalized_tutoring_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalized_tutoring_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personalized_tutoring_plans.
     */
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * personalized_tutoring_plans findFirstOrThrow
   */
  export type personalized_tutoring_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter, which personalized_tutoring_plans to fetch.
     */
    where?: personalized_tutoring_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalized_tutoring_plans to fetch.
     */
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personalized_tutoring_plans.
     */
    cursor?: personalized_tutoring_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalized_tutoring_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalized_tutoring_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personalized_tutoring_plans.
     */
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * personalized_tutoring_plans findMany
   */
  export type personalized_tutoring_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter, which personalized_tutoring_plans to fetch.
     */
    where?: personalized_tutoring_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalized_tutoring_plans to fetch.
     */
    orderBy?: personalized_tutoring_plansOrderByWithRelationInput | personalized_tutoring_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personalized_tutoring_plans.
     */
    cursor?: personalized_tutoring_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalized_tutoring_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalized_tutoring_plans.
     */
    skip?: number
    distinct?: Personalized_tutoring_plansScalarFieldEnum | Personalized_tutoring_plansScalarFieldEnum[]
  }

  /**
   * personalized_tutoring_plans create
   */
  export type personalized_tutoring_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a personalized_tutoring_plans.
     */
    data: XOR<personalized_tutoring_plansCreateInput, personalized_tutoring_plansUncheckedCreateInput>
  }

  /**
   * personalized_tutoring_plans createMany
   */
  export type personalized_tutoring_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personalized_tutoring_plans.
     */
    data: personalized_tutoring_plansCreateManyInput | personalized_tutoring_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * personalized_tutoring_plans createManyAndReturn
   */
  export type personalized_tutoring_plansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many personalized_tutoring_plans.
     */
    data: personalized_tutoring_plansCreateManyInput | personalized_tutoring_plansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * personalized_tutoring_plans update
   */
  export type personalized_tutoring_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a personalized_tutoring_plans.
     */
    data: XOR<personalized_tutoring_plansUpdateInput, personalized_tutoring_plansUncheckedUpdateInput>
    /**
     * Choose, which personalized_tutoring_plans to update.
     */
    where: personalized_tutoring_plansWhereUniqueInput
  }

  /**
   * personalized_tutoring_plans updateMany
   */
  export type personalized_tutoring_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personalized_tutoring_plans.
     */
    data: XOR<personalized_tutoring_plansUpdateManyMutationInput, personalized_tutoring_plansUncheckedUpdateManyInput>
    /**
     * Filter which personalized_tutoring_plans to update
     */
    where?: personalized_tutoring_plansWhereInput
  }

  /**
   * personalized_tutoring_plans upsert
   */
  export type personalized_tutoring_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the personalized_tutoring_plans to update in case it exists.
     */
    where: personalized_tutoring_plansWhereUniqueInput
    /**
     * In case the personalized_tutoring_plans found by the `where` argument doesn't exist, create a new personalized_tutoring_plans with this data.
     */
    create: XOR<personalized_tutoring_plansCreateInput, personalized_tutoring_plansUncheckedCreateInput>
    /**
     * In case the personalized_tutoring_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personalized_tutoring_plansUpdateInput, personalized_tutoring_plansUncheckedUpdateInput>
  }

  /**
   * personalized_tutoring_plans delete
   */
  export type personalized_tutoring_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
    /**
     * Filter which personalized_tutoring_plans to delete.
     */
    where: personalized_tutoring_plansWhereUniqueInput
  }

  /**
   * personalized_tutoring_plans deleteMany
   */
  export type personalized_tutoring_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personalized_tutoring_plans to delete
     */
    where?: personalized_tutoring_plansWhereInput
  }

  /**
   * personalized_tutoring_plans without action
   */
  export type personalized_tutoring_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalized_tutoring_plans
     */
    select?: personalized_tutoring_plansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalized_tutoring_plansInclude<ExtArgs> | null
  }


  /**
   * Model parents
   */

  export type AggregateParents = {
    _count: ParentsCountAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  export type ParentsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    phone: string | null
    password: string | null
    name: string | null
    identity: string | null
    lastLoginAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    phone: string | null
    password: string | null
    name: string | null
    identity: string | null
    lastLoginAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentsCountAggregateOutputType = {
    id: number
    schoolId: number
    phone: number
    password: number
    name: number
    identity: number
    lastLoginAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentsMinAggregateInputType = {
    id?: true
    schoolId?: true
    phone?: true
    password?: true
    name?: true
    identity?: true
    lastLoginAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    phone?: true
    password?: true
    name?: true
    identity?: true
    lastLoginAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentsCountAggregateInputType = {
    id?: true
    schoolId?: true
    phone?: true
    password?: true
    name?: true
    identity?: true
    lastLoginAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to aggregate.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parents
    **/
    _count?: true | ParentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentsMaxAggregateInputType
  }

  export type GetParentsAggregateType<T extends ParentsAggregateArgs> = {
        [P in keyof T & keyof AggregateParents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParents[P]>
      : GetScalarType<T[P], AggregateParents[P]>
  }




  export type parentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parentsWhereInput
    orderBy?: parentsOrderByWithAggregationInput | parentsOrderByWithAggregationInput[]
    by: ParentsScalarFieldEnum[] | ParentsScalarFieldEnum
    having?: parentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentsCountAggregateInputType | true
    _min?: ParentsMinAggregateInputType
    _max?: ParentsMaxAggregateInputType
  }

  export type ParentsGroupByOutputType = {
    id: string
    schoolId: string
    phone: string
    password: string
    name: string | null
    identity: string | null
    lastLoginAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ParentsCountAggregateOutputType | null
    _min: ParentsMinAggregateOutputType | null
    _max: ParentsMaxAggregateOutputType | null
  }

  type GetParentsGroupByPayload<T extends parentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentsGroupByOutputType[P]>
            : GetScalarType<T[P], ParentsGroupByOutputType[P]>
        }
      >
    >


  export type parentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    identity?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    daily_summaries?: boolean | parents$daily_summariesArgs<ExtArgs>
    parent_student_bindings?: boolean | parents$parent_student_bindingsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    identity?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parents"]>

  export type parentsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    identity?: boolean
    lastLoginAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type parentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    daily_summaries?: boolean | parents$daily_summariesArgs<ExtArgs>
    parent_student_bindings?: boolean | parents$parent_student_bindingsArgs<ExtArgs>
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
    _count?: boolean | ParentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type parentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $parentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parents"
    objects: {
      daily_summaries: Prisma.$daily_summariesPayload<ExtArgs>[]
      parent_student_bindings: Prisma.$parent_student_bindingsPayload<ExtArgs>[]
      schools: Prisma.$schoolsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      phone: string
      password: string
      name: string | null
      identity: string | null
      lastLoginAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parents"]>
    composites: {}
  }

  type parentsGetPayload<S extends boolean | null | undefined | parentsDefaultArgs> = $Result.GetResult<Prisma.$parentsPayload, S>

  type parentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<parentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentsCountAggregateInputType | true
    }

  export interface parentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parents'], meta: { name: 'parents' } }
    /**
     * Find zero or one Parents that matches the filter.
     * @param {parentsFindUniqueArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parentsFindUniqueArgs>(args: SelectSubset<T, parentsFindUniqueArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parents that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {parentsFindUniqueOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parentsFindUniqueOrThrowArgs>(args: SelectSubset<T, parentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parentsFindFirstArgs>(args?: SelectSubset<T, parentsFindFirstArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parents that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindFirstOrThrowArgs} args - Arguments to find a Parents
     * @example
     * // Get one Parents
     * const parents = await prisma.parents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parentsFindFirstOrThrowArgs>(args?: SelectSubset<T, parentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parents.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentsWithIdOnly = await prisma.parents.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parentsFindManyArgs>(args?: SelectSubset<T, parentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parents.
     * @param {parentsCreateArgs} args - Arguments to create a Parents.
     * @example
     * // Create one Parents
     * const Parents = await prisma.parents.create({
     *   data: {
     *     // ... data to create a Parents
     *   }
     * })
     * 
     */
    create<T extends parentsCreateArgs>(args: SelectSubset<T, parentsCreateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {parentsCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parentsCreateManyArgs>(args?: SelectSubset<T, parentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {parentsCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parents = await prisma.parents.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentsWithIdOnly = await prisma.parents.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parentsCreateManyAndReturnArgs>(args?: SelectSubset<T, parentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parents.
     * @param {parentsDeleteArgs} args - Arguments to delete one Parents.
     * @example
     * // Delete one Parents
     * const Parents = await prisma.parents.delete({
     *   where: {
     *     // ... filter to delete one Parents
     *   }
     * })
     * 
     */
    delete<T extends parentsDeleteArgs>(args: SelectSubset<T, parentsDeleteArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parents.
     * @param {parentsUpdateArgs} args - Arguments to update one Parents.
     * @example
     * // Update one Parents
     * const parents = await prisma.parents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parentsUpdateArgs>(args: SelectSubset<T, parentsUpdateArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {parentsDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parentsDeleteManyArgs>(args?: SelectSubset<T, parentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parents = await prisma.parents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parentsUpdateManyArgs>(args: SelectSubset<T, parentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parents.
     * @param {parentsUpsertArgs} args - Arguments to update or create a Parents.
     * @example
     * // Update or create a Parents
     * const parents = await prisma.parents.upsert({
     *   create: {
     *     // ... data to create a Parents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parents we want to update
     *   }
     * })
     */
    upsert<T extends parentsUpsertArgs>(args: SelectSubset<T, parentsUpsertArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parents.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends parentsCountArgs>(
      args?: Subset<T, parentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentsAggregateArgs>(args: Subset<T, ParentsAggregateArgs>): Prisma.PrismaPromise<GetParentsAggregateType<T>>

    /**
     * Group by Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parentsGroupByArgs['orderBy'] }
        : { orderBy?: parentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parents model
   */
  readonly fields: parentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    daily_summaries<T extends parents$daily_summariesArgs<ExtArgs> = {}>(args?: Subset<T, parents$daily_summariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findMany"> | Null>
    parent_student_bindings<T extends parents$parent_student_bindingsArgs<ExtArgs> = {}>(args?: Subset<T, parents$parent_student_bindingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findMany"> | Null>
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parents model
   */ 
  interface parentsFieldRefs {
    readonly id: FieldRef<"parents", 'String'>
    readonly schoolId: FieldRef<"parents", 'String'>
    readonly phone: FieldRef<"parents", 'String'>
    readonly password: FieldRef<"parents", 'String'>
    readonly name: FieldRef<"parents", 'String'>
    readonly identity: FieldRef<"parents", 'String'>
    readonly lastLoginAt: FieldRef<"parents", 'DateTime'>
    readonly isActive: FieldRef<"parents", 'Boolean'>
    readonly createdAt: FieldRef<"parents", 'DateTime'>
    readonly updatedAt: FieldRef<"parents", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * parents findUnique
   */
  export type parentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findUniqueOrThrow
   */
  export type parentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents findFirst
   */
  export type parentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findFirstOrThrow
   */
  export type parentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parents.
     */
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents findMany
   */
  export type parentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter, which parents to fetch.
     */
    where?: parentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parents to fetch.
     */
    orderBy?: parentsOrderByWithRelationInput | parentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parents.
     */
    cursor?: parentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parents.
     */
    skip?: number
    distinct?: ParentsScalarFieldEnum | ParentsScalarFieldEnum[]
  }

  /**
   * parents create
   */
  export type parentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to create a parents.
     */
    data: XOR<parentsCreateInput, parentsUncheckedCreateInput>
  }

  /**
   * parents createMany
   */
  export type parentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parents createManyAndReturn
   */
  export type parentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many parents.
     */
    data: parentsCreateManyInput | parentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parents update
   */
  export type parentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The data needed to update a parents.
     */
    data: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
    /**
     * Choose, which parents to update.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents updateMany
   */
  export type parentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parents.
     */
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyInput>
    /**
     * Filter which parents to update
     */
    where?: parentsWhereInput
  }

  /**
   * parents upsert
   */
  export type parentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * The filter to search for the parents to update in case it exists.
     */
    where: parentsWhereUniqueInput
    /**
     * In case the parents found by the `where` argument doesn't exist, create a new parents with this data.
     */
    create: XOR<parentsCreateInput, parentsUncheckedCreateInput>
    /**
     * In case the parents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parentsUpdateInput, parentsUncheckedUpdateInput>
  }

  /**
   * parents delete
   */
  export type parentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
    /**
     * Filter which parents to delete.
     */
    where: parentsWhereUniqueInput
  }

  /**
   * parents deleteMany
   */
  export type parentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parents to delete
     */
    where?: parentsWhereInput
  }

  /**
   * parents.daily_summaries
   */
  export type parents$daily_summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    where?: daily_summariesWhereInput
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    cursor?: daily_summariesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Daily_summariesScalarFieldEnum | Daily_summariesScalarFieldEnum[]
  }

  /**
   * parents.parent_student_bindings
   */
  export type parents$parent_student_bindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    where?: parent_student_bindingsWhereInput
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    cursor?: parent_student_bindingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Parent_student_bindingsScalarFieldEnum | Parent_student_bindingsScalarFieldEnum[]
  }

  /**
   * parents without action
   */
  export type parentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parents
     */
    select?: parentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parentsInclude<ExtArgs> | null
  }


  /**
   * Model parent_student_bindings
   */

  export type AggregateParent_student_bindings = {
    _count: Parent_student_bindingsCountAggregateOutputType | null
    _min: Parent_student_bindingsMinAggregateOutputType | null
    _max: Parent_student_bindingsMaxAggregateOutputType | null
  }

  export type Parent_student_bindingsMinAggregateOutputType = {
    id: string | null
    parentId: string | null
    studentId: string | null
    inviteCode: string | null
    bindingTime: Date | null
    isActive: boolean | null
  }

  export type Parent_student_bindingsMaxAggregateOutputType = {
    id: string | null
    parentId: string | null
    studentId: string | null
    inviteCode: string | null
    bindingTime: Date | null
    isActive: boolean | null
  }

  export type Parent_student_bindingsCountAggregateOutputType = {
    id: number
    parentId: number
    studentId: number
    inviteCode: number
    bindingTime: number
    isActive: number
    _all: number
  }


  export type Parent_student_bindingsMinAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
    inviteCode?: true
    bindingTime?: true
    isActive?: true
  }

  export type Parent_student_bindingsMaxAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
    inviteCode?: true
    bindingTime?: true
    isActive?: true
  }

  export type Parent_student_bindingsCountAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
    inviteCode?: true
    bindingTime?: true
    isActive?: true
    _all?: true
  }

  export type Parent_student_bindingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_student_bindings to aggregate.
     */
    where?: parent_student_bindingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_student_bindings to fetch.
     */
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parent_student_bindingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_student_bindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_student_bindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parent_student_bindings
    **/
    _count?: true | Parent_student_bindingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parent_student_bindingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parent_student_bindingsMaxAggregateInputType
  }

  export type GetParent_student_bindingsAggregateType<T extends Parent_student_bindingsAggregateArgs> = {
        [P in keyof T & keyof AggregateParent_student_bindings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent_student_bindings[P]>
      : GetScalarType<T[P], AggregateParent_student_bindings[P]>
  }




  export type parent_student_bindingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: parent_student_bindingsWhereInput
    orderBy?: parent_student_bindingsOrderByWithAggregationInput | parent_student_bindingsOrderByWithAggregationInput[]
    by: Parent_student_bindingsScalarFieldEnum[] | Parent_student_bindingsScalarFieldEnum
    having?: parent_student_bindingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parent_student_bindingsCountAggregateInputType | true
    _min?: Parent_student_bindingsMinAggregateInputType
    _max?: Parent_student_bindingsMaxAggregateInputType
  }

  export type Parent_student_bindingsGroupByOutputType = {
    id: string
    parentId: string
    studentId: string
    inviteCode: string
    bindingTime: Date
    isActive: boolean
    _count: Parent_student_bindingsCountAggregateOutputType | null
    _min: Parent_student_bindingsMinAggregateOutputType | null
    _max: Parent_student_bindingsMaxAggregateOutputType | null
  }

  type GetParent_student_bindingsGroupByPayload<T extends parent_student_bindingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Parent_student_bindingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parent_student_bindingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parent_student_bindingsGroupByOutputType[P]>
            : GetScalarType<T[P], Parent_student_bindingsGroupByOutputType[P]>
        }
      >
    >


  export type parent_student_bindingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    studentId?: boolean
    inviteCode?: boolean
    bindingTime?: boolean
    isActive?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent_student_bindings"]>

  export type parent_student_bindingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    studentId?: boolean
    inviteCode?: boolean
    bindingTime?: boolean
    isActive?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent_student_bindings"]>

  export type parent_student_bindingsSelectScalar = {
    id?: boolean
    parentId?: boolean
    studentId?: boolean
    inviteCode?: boolean
    bindingTime?: boolean
    isActive?: boolean
  }

  export type parent_student_bindingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type parent_student_bindingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $parent_student_bindingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "parent_student_bindings"
    objects: {
      parents: Prisma.$parentsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parentId: string
      studentId: string
      inviteCode: string
      bindingTime: Date
      isActive: boolean
    }, ExtArgs["result"]["parent_student_bindings"]>
    composites: {}
  }

  type parent_student_bindingsGetPayload<S extends boolean | null | undefined | parent_student_bindingsDefaultArgs> = $Result.GetResult<Prisma.$parent_student_bindingsPayload, S>

  type parent_student_bindingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<parent_student_bindingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Parent_student_bindingsCountAggregateInputType | true
    }

  export interface parent_student_bindingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['parent_student_bindings'], meta: { name: 'parent_student_bindings' } }
    /**
     * Find zero or one Parent_student_bindings that matches the filter.
     * @param {parent_student_bindingsFindUniqueArgs} args - Arguments to find a Parent_student_bindings
     * @example
     * // Get one Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends parent_student_bindingsFindUniqueArgs>(args: SelectSubset<T, parent_student_bindingsFindUniqueArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parent_student_bindings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {parent_student_bindingsFindUniqueOrThrowArgs} args - Arguments to find a Parent_student_bindings
     * @example
     * // Get one Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends parent_student_bindingsFindUniqueOrThrowArgs>(args: SelectSubset<T, parent_student_bindingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parent_student_bindings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsFindFirstArgs} args - Arguments to find a Parent_student_bindings
     * @example
     * // Get one Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends parent_student_bindingsFindFirstArgs>(args?: SelectSubset<T, parent_student_bindingsFindFirstArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parent_student_bindings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsFindFirstOrThrowArgs} args - Arguments to find a Parent_student_bindings
     * @example
     * // Get one Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends parent_student_bindingsFindFirstOrThrowArgs>(args?: SelectSubset<T, parent_student_bindingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parent_student_bindings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findMany()
     * 
     * // Get first 10 Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parent_student_bindingsWithIdOnly = await prisma.parent_student_bindings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends parent_student_bindingsFindManyArgs>(args?: SelectSubset<T, parent_student_bindingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parent_student_bindings.
     * @param {parent_student_bindingsCreateArgs} args - Arguments to create a Parent_student_bindings.
     * @example
     * // Create one Parent_student_bindings
     * const Parent_student_bindings = await prisma.parent_student_bindings.create({
     *   data: {
     *     // ... data to create a Parent_student_bindings
     *   }
     * })
     * 
     */
    create<T extends parent_student_bindingsCreateArgs>(args: SelectSubset<T, parent_student_bindingsCreateArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parent_student_bindings.
     * @param {parent_student_bindingsCreateManyArgs} args - Arguments to create many Parent_student_bindings.
     * @example
     * // Create many Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends parent_student_bindingsCreateManyArgs>(args?: SelectSubset<T, parent_student_bindingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parent_student_bindings and returns the data saved in the database.
     * @param {parent_student_bindingsCreateManyAndReturnArgs} args - Arguments to create many Parent_student_bindings.
     * @example
     * // Create many Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parent_student_bindings and only return the `id`
     * const parent_student_bindingsWithIdOnly = await prisma.parent_student_bindings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends parent_student_bindingsCreateManyAndReturnArgs>(args?: SelectSubset<T, parent_student_bindingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parent_student_bindings.
     * @param {parent_student_bindingsDeleteArgs} args - Arguments to delete one Parent_student_bindings.
     * @example
     * // Delete one Parent_student_bindings
     * const Parent_student_bindings = await prisma.parent_student_bindings.delete({
     *   where: {
     *     // ... filter to delete one Parent_student_bindings
     *   }
     * })
     * 
     */
    delete<T extends parent_student_bindingsDeleteArgs>(args: SelectSubset<T, parent_student_bindingsDeleteArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parent_student_bindings.
     * @param {parent_student_bindingsUpdateArgs} args - Arguments to update one Parent_student_bindings.
     * @example
     * // Update one Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends parent_student_bindingsUpdateArgs>(args: SelectSubset<T, parent_student_bindingsUpdateArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parent_student_bindings.
     * @param {parent_student_bindingsDeleteManyArgs} args - Arguments to filter Parent_student_bindings to delete.
     * @example
     * // Delete a few Parent_student_bindings
     * const { count } = await prisma.parent_student_bindings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends parent_student_bindingsDeleteManyArgs>(args?: SelectSubset<T, parent_student_bindingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parent_student_bindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends parent_student_bindingsUpdateManyArgs>(args: SelectSubset<T, parent_student_bindingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent_student_bindings.
     * @param {parent_student_bindingsUpsertArgs} args - Arguments to update or create a Parent_student_bindings.
     * @example
     * // Update or create a Parent_student_bindings
     * const parent_student_bindings = await prisma.parent_student_bindings.upsert({
     *   create: {
     *     // ... data to create a Parent_student_bindings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent_student_bindings we want to update
     *   }
     * })
     */
    upsert<T extends parent_student_bindingsUpsertArgs>(args: SelectSubset<T, parent_student_bindingsUpsertArgs<ExtArgs>>): Prisma__parent_student_bindingsClient<$Result.GetResult<Prisma.$parent_student_bindingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parent_student_bindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsCountArgs} args - Arguments to filter Parent_student_bindings to count.
     * @example
     * // Count the number of Parent_student_bindings
     * const count = await prisma.parent_student_bindings.count({
     *   where: {
     *     // ... the filter for the Parent_student_bindings we want to count
     *   }
     * })
    **/
    count<T extends parent_student_bindingsCountArgs>(
      args?: Subset<T, parent_student_bindingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parent_student_bindingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent_student_bindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parent_student_bindingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parent_student_bindingsAggregateArgs>(args: Subset<T, Parent_student_bindingsAggregateArgs>): Prisma.PrismaPromise<GetParent_student_bindingsAggregateType<T>>

    /**
     * Group by Parent_student_bindings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parent_student_bindingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends parent_student_bindingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: parent_student_bindingsGroupByArgs['orderBy'] }
        : { orderBy?: parent_student_bindingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, parent_student_bindingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParent_student_bindingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the parent_student_bindings model
   */
  readonly fields: parent_student_bindingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for parent_student_bindings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__parent_student_bindingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends parentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentsDefaultArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the parent_student_bindings model
   */ 
  interface parent_student_bindingsFieldRefs {
    readonly id: FieldRef<"parent_student_bindings", 'String'>
    readonly parentId: FieldRef<"parent_student_bindings", 'String'>
    readonly studentId: FieldRef<"parent_student_bindings", 'String'>
    readonly inviteCode: FieldRef<"parent_student_bindings", 'String'>
    readonly bindingTime: FieldRef<"parent_student_bindings", 'DateTime'>
    readonly isActive: FieldRef<"parent_student_bindings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * parent_student_bindings findUnique
   */
  export type parent_student_bindingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter, which parent_student_bindings to fetch.
     */
    where: parent_student_bindingsWhereUniqueInput
  }

  /**
   * parent_student_bindings findUniqueOrThrow
   */
  export type parent_student_bindingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter, which parent_student_bindings to fetch.
     */
    where: parent_student_bindingsWhereUniqueInput
  }

  /**
   * parent_student_bindings findFirst
   */
  export type parent_student_bindingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter, which parent_student_bindings to fetch.
     */
    where?: parent_student_bindingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_student_bindings to fetch.
     */
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_student_bindings.
     */
    cursor?: parent_student_bindingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_student_bindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_student_bindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_student_bindings.
     */
    distinct?: Parent_student_bindingsScalarFieldEnum | Parent_student_bindingsScalarFieldEnum[]
  }

  /**
   * parent_student_bindings findFirstOrThrow
   */
  export type parent_student_bindingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter, which parent_student_bindings to fetch.
     */
    where?: parent_student_bindingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_student_bindings to fetch.
     */
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parent_student_bindings.
     */
    cursor?: parent_student_bindingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_student_bindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_student_bindings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parent_student_bindings.
     */
    distinct?: Parent_student_bindingsScalarFieldEnum | Parent_student_bindingsScalarFieldEnum[]
  }

  /**
   * parent_student_bindings findMany
   */
  export type parent_student_bindingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter, which parent_student_bindings to fetch.
     */
    where?: parent_student_bindingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parent_student_bindings to fetch.
     */
    orderBy?: parent_student_bindingsOrderByWithRelationInput | parent_student_bindingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parent_student_bindings.
     */
    cursor?: parent_student_bindingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parent_student_bindings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parent_student_bindings.
     */
    skip?: number
    distinct?: Parent_student_bindingsScalarFieldEnum | Parent_student_bindingsScalarFieldEnum[]
  }

  /**
   * parent_student_bindings create
   */
  export type parent_student_bindingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * The data needed to create a parent_student_bindings.
     */
    data: XOR<parent_student_bindingsCreateInput, parent_student_bindingsUncheckedCreateInput>
  }

  /**
   * parent_student_bindings createMany
   */
  export type parent_student_bindingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many parent_student_bindings.
     */
    data: parent_student_bindingsCreateManyInput | parent_student_bindingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * parent_student_bindings createManyAndReturn
   */
  export type parent_student_bindingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many parent_student_bindings.
     */
    data: parent_student_bindingsCreateManyInput | parent_student_bindingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * parent_student_bindings update
   */
  export type parent_student_bindingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * The data needed to update a parent_student_bindings.
     */
    data: XOR<parent_student_bindingsUpdateInput, parent_student_bindingsUncheckedUpdateInput>
    /**
     * Choose, which parent_student_bindings to update.
     */
    where: parent_student_bindingsWhereUniqueInput
  }

  /**
   * parent_student_bindings updateMany
   */
  export type parent_student_bindingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update parent_student_bindings.
     */
    data: XOR<parent_student_bindingsUpdateManyMutationInput, parent_student_bindingsUncheckedUpdateManyInput>
    /**
     * Filter which parent_student_bindings to update
     */
    where?: parent_student_bindingsWhereInput
  }

  /**
   * parent_student_bindings upsert
   */
  export type parent_student_bindingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * The filter to search for the parent_student_bindings to update in case it exists.
     */
    where: parent_student_bindingsWhereUniqueInput
    /**
     * In case the parent_student_bindings found by the `where` argument doesn't exist, create a new parent_student_bindings with this data.
     */
    create: XOR<parent_student_bindingsCreateInput, parent_student_bindingsUncheckedCreateInput>
    /**
     * In case the parent_student_bindings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parent_student_bindingsUpdateInput, parent_student_bindingsUncheckedUpdateInput>
  }

  /**
   * parent_student_bindings delete
   */
  export type parent_student_bindingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
    /**
     * Filter which parent_student_bindings to delete.
     */
    where: parent_student_bindingsWhereUniqueInput
  }

  /**
   * parent_student_bindings deleteMany
   */
  export type parent_student_bindingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which parent_student_bindings to delete
     */
    where?: parent_student_bindingsWhereInput
  }

  /**
   * parent_student_bindings without action
   */
  export type parent_student_bindingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the parent_student_bindings
     */
    select?: parent_student_bindingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: parent_student_bindingsInclude<ExtArgs> | null
  }


  /**
   * Model daily_summaries
   */

  export type AggregateDaily_summaries = {
    _count: Daily_summariesCountAggregateOutputType | null
    _min: Daily_summariesMinAggregateOutputType | null
    _max: Daily_summariesMaxAggregateOutputType | null
  }

  export type Daily_summariesMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    date: string | null
    parentLiked: boolean | null
    parentComment: string | null
    teacherRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Daily_summariesMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    date: string | null
    parentLiked: boolean | null
    parentComment: string | null
    teacherRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Daily_summariesCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    date: number
    parentLiked: number
    parentComment: number
    teacherRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Daily_summariesMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    date?: true
    parentLiked?: true
    parentComment?: true
    teacherRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Daily_summariesMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    date?: true
    parentLiked?: true
    parentComment?: true
    teacherRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Daily_summariesCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    date?: true
    parentLiked?: true
    parentComment?: true
    teacherRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Daily_summariesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daily_summaries to aggregate.
     */
    where?: daily_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daily_summaries to fetch.
     */
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: daily_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daily_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daily_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned daily_summaries
    **/
    _count?: true | Daily_summariesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Daily_summariesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Daily_summariesMaxAggregateInputType
  }

  export type GetDaily_summariesAggregateType<T extends Daily_summariesAggregateArgs> = {
        [P in keyof T & keyof AggregateDaily_summaries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDaily_summaries[P]>
      : GetScalarType<T[P], AggregateDaily_summaries[P]>
  }




  export type daily_summariesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: daily_summariesWhereInput
    orderBy?: daily_summariesOrderByWithAggregationInput | daily_summariesOrderByWithAggregationInput[]
    by: Daily_summariesScalarFieldEnum[] | Daily_summariesScalarFieldEnum
    having?: daily_summariesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Daily_summariesCountAggregateInputType | true
    _min?: Daily_summariesMinAggregateInputType
    _max?: Daily_summariesMaxAggregateInputType
  }

  export type Daily_summariesGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    date: string
    parentLiked: boolean
    parentComment: string | null
    teacherRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: Daily_summariesCountAggregateOutputType | null
    _min: Daily_summariesMinAggregateOutputType | null
    _max: Daily_summariesMaxAggregateOutputType | null
  }

  type GetDaily_summariesGroupByPayload<T extends daily_summariesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Daily_summariesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Daily_summariesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Daily_summariesGroupByOutputType[P]>
            : GetScalarType<T[P], Daily_summariesGroupByOutputType[P]>
        }
      >
    >


  export type daily_summariesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    date?: boolean
    parentLiked?: boolean
    parentComment?: boolean
    teacherRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["daily_summaries"]>

  export type daily_summariesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    date?: boolean
    parentLiked?: boolean
    parentComment?: boolean
    teacherRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["daily_summaries"]>

  export type daily_summariesSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    date?: boolean
    parentLiked?: boolean
    parentComment?: boolean
    teacherRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type daily_summariesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type daily_summariesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | parentsDefaultArgs<ExtArgs>
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $daily_summariesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "daily_summaries"
    objects: {
      parents: Prisma.$parentsPayload<ExtArgs>
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      date: string
      parentLiked: boolean
      parentComment: string | null
      teacherRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["daily_summaries"]>
    composites: {}
  }

  type daily_summariesGetPayload<S extends boolean | null | undefined | daily_summariesDefaultArgs> = $Result.GetResult<Prisma.$daily_summariesPayload, S>

  type daily_summariesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<daily_summariesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Daily_summariesCountAggregateInputType | true
    }

  export interface daily_summariesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['daily_summaries'], meta: { name: 'daily_summaries' } }
    /**
     * Find zero or one Daily_summaries that matches the filter.
     * @param {daily_summariesFindUniqueArgs} args - Arguments to find a Daily_summaries
     * @example
     * // Get one Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends daily_summariesFindUniqueArgs>(args: SelectSubset<T, daily_summariesFindUniqueArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Daily_summaries that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {daily_summariesFindUniqueOrThrowArgs} args - Arguments to find a Daily_summaries
     * @example
     * // Get one Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends daily_summariesFindUniqueOrThrowArgs>(args: SelectSubset<T, daily_summariesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Daily_summaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesFindFirstArgs} args - Arguments to find a Daily_summaries
     * @example
     * // Get one Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends daily_summariesFindFirstArgs>(args?: SelectSubset<T, daily_summariesFindFirstArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Daily_summaries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesFindFirstOrThrowArgs} args - Arguments to find a Daily_summaries
     * @example
     * // Get one Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends daily_summariesFindFirstOrThrowArgs>(args?: SelectSubset<T, daily_summariesFindFirstOrThrowArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Daily_summaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findMany()
     * 
     * // Get first 10 Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const daily_summariesWithIdOnly = await prisma.daily_summaries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends daily_summariesFindManyArgs>(args?: SelectSubset<T, daily_summariesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Daily_summaries.
     * @param {daily_summariesCreateArgs} args - Arguments to create a Daily_summaries.
     * @example
     * // Create one Daily_summaries
     * const Daily_summaries = await prisma.daily_summaries.create({
     *   data: {
     *     // ... data to create a Daily_summaries
     *   }
     * })
     * 
     */
    create<T extends daily_summariesCreateArgs>(args: SelectSubset<T, daily_summariesCreateArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Daily_summaries.
     * @param {daily_summariesCreateManyArgs} args - Arguments to create many Daily_summaries.
     * @example
     * // Create many Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends daily_summariesCreateManyArgs>(args?: SelectSubset<T, daily_summariesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Daily_summaries and returns the data saved in the database.
     * @param {daily_summariesCreateManyAndReturnArgs} args - Arguments to create many Daily_summaries.
     * @example
     * // Create many Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Daily_summaries and only return the `id`
     * const daily_summariesWithIdOnly = await prisma.daily_summaries.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends daily_summariesCreateManyAndReturnArgs>(args?: SelectSubset<T, daily_summariesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Daily_summaries.
     * @param {daily_summariesDeleteArgs} args - Arguments to delete one Daily_summaries.
     * @example
     * // Delete one Daily_summaries
     * const Daily_summaries = await prisma.daily_summaries.delete({
     *   where: {
     *     // ... filter to delete one Daily_summaries
     *   }
     * })
     * 
     */
    delete<T extends daily_summariesDeleteArgs>(args: SelectSubset<T, daily_summariesDeleteArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Daily_summaries.
     * @param {daily_summariesUpdateArgs} args - Arguments to update one Daily_summaries.
     * @example
     * // Update one Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends daily_summariesUpdateArgs>(args: SelectSubset<T, daily_summariesUpdateArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Daily_summaries.
     * @param {daily_summariesDeleteManyArgs} args - Arguments to filter Daily_summaries to delete.
     * @example
     * // Delete a few Daily_summaries
     * const { count } = await prisma.daily_summaries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends daily_summariesDeleteManyArgs>(args?: SelectSubset<T, daily_summariesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Daily_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends daily_summariesUpdateManyArgs>(args: SelectSubset<T, daily_summariesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Daily_summaries.
     * @param {daily_summariesUpsertArgs} args - Arguments to update or create a Daily_summaries.
     * @example
     * // Update or create a Daily_summaries
     * const daily_summaries = await prisma.daily_summaries.upsert({
     *   create: {
     *     // ... data to create a Daily_summaries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Daily_summaries we want to update
     *   }
     * })
     */
    upsert<T extends daily_summariesUpsertArgs>(args: SelectSubset<T, daily_summariesUpsertArgs<ExtArgs>>): Prisma__daily_summariesClient<$Result.GetResult<Prisma.$daily_summariesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Daily_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesCountArgs} args - Arguments to filter Daily_summaries to count.
     * @example
     * // Count the number of Daily_summaries
     * const count = await prisma.daily_summaries.count({
     *   where: {
     *     // ... the filter for the Daily_summaries we want to count
     *   }
     * })
    **/
    count<T extends daily_summariesCountArgs>(
      args?: Subset<T, daily_summariesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Daily_summariesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Daily_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Daily_summariesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Daily_summariesAggregateArgs>(args: Subset<T, Daily_summariesAggregateArgs>): Prisma.PrismaPromise<GetDaily_summariesAggregateType<T>>

    /**
     * Group by Daily_summaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {daily_summariesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends daily_summariesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: daily_summariesGroupByArgs['orderBy'] }
        : { orderBy?: daily_summariesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, daily_summariesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDaily_summariesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the daily_summaries model
   */
  readonly fields: daily_summariesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for daily_summaries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__daily_summariesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parents<T extends parentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, parentsDefaultArgs<ExtArgs>>): Prisma__parentsClient<$Result.GetResult<Prisma.$parentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the daily_summaries model
   */ 
  interface daily_summariesFieldRefs {
    readonly id: FieldRef<"daily_summaries", 'String'>
    readonly studentId: FieldRef<"daily_summaries", 'String'>
    readonly parentId: FieldRef<"daily_summaries", 'String'>
    readonly date: FieldRef<"daily_summaries", 'String'>
    readonly parentLiked: FieldRef<"daily_summaries", 'Boolean'>
    readonly parentComment: FieldRef<"daily_summaries", 'String'>
    readonly teacherRead: FieldRef<"daily_summaries", 'Boolean'>
    readonly createdAt: FieldRef<"daily_summaries", 'DateTime'>
    readonly updatedAt: FieldRef<"daily_summaries", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * daily_summaries findUnique
   */
  export type daily_summariesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter, which daily_summaries to fetch.
     */
    where: daily_summariesWhereUniqueInput
  }

  /**
   * daily_summaries findUniqueOrThrow
   */
  export type daily_summariesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter, which daily_summaries to fetch.
     */
    where: daily_summariesWhereUniqueInput
  }

  /**
   * daily_summaries findFirst
   */
  export type daily_summariesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter, which daily_summaries to fetch.
     */
    where?: daily_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daily_summaries to fetch.
     */
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daily_summaries.
     */
    cursor?: daily_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daily_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daily_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daily_summaries.
     */
    distinct?: Daily_summariesScalarFieldEnum | Daily_summariesScalarFieldEnum[]
  }

  /**
   * daily_summaries findFirstOrThrow
   */
  export type daily_summariesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter, which daily_summaries to fetch.
     */
    where?: daily_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daily_summaries to fetch.
     */
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for daily_summaries.
     */
    cursor?: daily_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daily_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daily_summaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of daily_summaries.
     */
    distinct?: Daily_summariesScalarFieldEnum | Daily_summariesScalarFieldEnum[]
  }

  /**
   * daily_summaries findMany
   */
  export type daily_summariesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter, which daily_summaries to fetch.
     */
    where?: daily_summariesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of daily_summaries to fetch.
     */
    orderBy?: daily_summariesOrderByWithRelationInput | daily_summariesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing daily_summaries.
     */
    cursor?: daily_summariesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` daily_summaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` daily_summaries.
     */
    skip?: number
    distinct?: Daily_summariesScalarFieldEnum | Daily_summariesScalarFieldEnum[]
  }

  /**
   * daily_summaries create
   */
  export type daily_summariesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * The data needed to create a daily_summaries.
     */
    data: XOR<daily_summariesCreateInput, daily_summariesUncheckedCreateInput>
  }

  /**
   * daily_summaries createMany
   */
  export type daily_summariesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many daily_summaries.
     */
    data: daily_summariesCreateManyInput | daily_summariesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * daily_summaries createManyAndReturn
   */
  export type daily_summariesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many daily_summaries.
     */
    data: daily_summariesCreateManyInput | daily_summariesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * daily_summaries update
   */
  export type daily_summariesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * The data needed to update a daily_summaries.
     */
    data: XOR<daily_summariesUpdateInput, daily_summariesUncheckedUpdateInput>
    /**
     * Choose, which daily_summaries to update.
     */
    where: daily_summariesWhereUniqueInput
  }

  /**
   * daily_summaries updateMany
   */
  export type daily_summariesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update daily_summaries.
     */
    data: XOR<daily_summariesUpdateManyMutationInput, daily_summariesUncheckedUpdateManyInput>
    /**
     * Filter which daily_summaries to update
     */
    where?: daily_summariesWhereInput
  }

  /**
   * daily_summaries upsert
   */
  export type daily_summariesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * The filter to search for the daily_summaries to update in case it exists.
     */
    where: daily_summariesWhereUniqueInput
    /**
     * In case the daily_summaries found by the `where` argument doesn't exist, create a new daily_summaries with this data.
     */
    create: XOR<daily_summariesCreateInput, daily_summariesUncheckedCreateInput>
    /**
     * In case the daily_summaries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<daily_summariesUpdateInput, daily_summariesUncheckedUpdateInput>
  }

  /**
   * daily_summaries delete
   */
  export type daily_summariesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
    /**
     * Filter which daily_summaries to delete.
     */
    where: daily_summariesWhereUniqueInput
  }

  /**
   * daily_summaries deleteMany
   */
  export type daily_summariesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which daily_summaries to delete
     */
    where?: daily_summariesWhereInput
  }

  /**
   * daily_summaries without action
   */
  export type daily_summariesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the daily_summaries
     */
    select?: daily_summariesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: daily_summariesInclude<ExtArgs> | null
  }


  /**
   * Model campaigns
   */

  export type AggregateCampaigns = {
    _count: CampaignsCountAggregateOutputType | null
    _min: CampaignsMinAggregateOutputType | null
    _max: CampaignsMaxAggregateOutputType | null
  }

  export type CampaignsMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignsMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignsCountAggregateOutputType = {
    id: number
    studentId: number
    type: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignsMinAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignsMaxAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignsCountAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaigns to aggregate.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned campaigns
    **/
    _count?: true | CampaignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignsMaxAggregateInputType
  }

  export type GetCampaignsAggregateType<T extends CampaignsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaigns[P]>
      : GetScalarType<T[P], AggregateCampaigns[P]>
  }




  export type campaignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: campaignsWhereInput
    orderBy?: campaignsOrderByWithAggregationInput | campaignsOrderByWithAggregationInput[]
    by: CampaignsScalarFieldEnum[] | CampaignsScalarFieldEnum
    having?: campaignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignsCountAggregateInputType | true
    _min?: CampaignsMinAggregateInputType
    _max?: CampaignsMaxAggregateInputType
  }

  export type CampaignsGroupByOutputType = {
    id: string
    studentId: string
    type: string
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignsCountAggregateOutputType | null
    _min: CampaignsMinAggregateOutputType | null
    _max: CampaignsMaxAggregateOutputType | null
  }

  type GetCampaignsGroupByPayload<T extends campaignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignsGroupByOutputType[P]>
        }
      >
    >


  export type campaignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaigns"]>

  export type campaignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaigns"]>

  export type campaignsSelectScalar = {
    id?: boolean
    studentId?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type campaignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }
  export type campaignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
  }

  export type $campaignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "campaigns"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      type: string
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaigns"]>
    composites: {}
  }

  type campaignsGetPayload<S extends boolean | null | undefined | campaignsDefaultArgs> = $Result.GetResult<Prisma.$campaignsPayload, S>

  type campaignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<campaignsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignsCountAggregateInputType | true
    }

  export interface campaignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['campaigns'], meta: { name: 'campaigns' } }
    /**
     * Find zero or one Campaigns that matches the filter.
     * @param {campaignsFindUniqueArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends campaignsFindUniqueArgs>(args: SelectSubset<T, campaignsFindUniqueArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaigns that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {campaignsFindUniqueOrThrowArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends campaignsFindUniqueOrThrowArgs>(args: SelectSubset<T, campaignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindFirstArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends campaignsFindFirstArgs>(args?: SelectSubset<T, campaignsFindFirstArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindFirstOrThrowArgs} args - Arguments to find a Campaigns
     * @example
     * // Get one Campaigns
     * const campaigns = await prisma.campaigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends campaignsFindFirstOrThrowArgs>(args?: SelectSubset<T, campaignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaigns.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignsWithIdOnly = await prisma.campaigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends campaignsFindManyArgs>(args?: SelectSubset<T, campaignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaigns.
     * @param {campaignsCreateArgs} args - Arguments to create a Campaigns.
     * @example
     * // Create one Campaigns
     * const Campaigns = await prisma.campaigns.create({
     *   data: {
     *     // ... data to create a Campaigns
     *   }
     * })
     * 
     */
    create<T extends campaignsCreateArgs>(args: SelectSubset<T, campaignsCreateArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {campaignsCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaigns = await prisma.campaigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends campaignsCreateManyArgs>(args?: SelectSubset<T, campaignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {campaignsCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaigns = await prisma.campaigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignsWithIdOnly = await prisma.campaigns.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends campaignsCreateManyAndReturnArgs>(args?: SelectSubset<T, campaignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaigns.
     * @param {campaignsDeleteArgs} args - Arguments to delete one Campaigns.
     * @example
     * // Delete one Campaigns
     * const Campaigns = await prisma.campaigns.delete({
     *   where: {
     *     // ... filter to delete one Campaigns
     *   }
     * })
     * 
     */
    delete<T extends campaignsDeleteArgs>(args: SelectSubset<T, campaignsDeleteArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaigns.
     * @param {campaignsUpdateArgs} args - Arguments to update one Campaigns.
     * @example
     * // Update one Campaigns
     * const campaigns = await prisma.campaigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends campaignsUpdateArgs>(args: SelectSubset<T, campaignsUpdateArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {campaignsDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends campaignsDeleteManyArgs>(args?: SelectSubset<T, campaignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaigns = await prisma.campaigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends campaignsUpdateManyArgs>(args: SelectSubset<T, campaignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaigns.
     * @param {campaignsUpsertArgs} args - Arguments to update or create a Campaigns.
     * @example
     * // Update or create a Campaigns
     * const campaigns = await prisma.campaigns.upsert({
     *   create: {
     *     // ... data to create a Campaigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaigns we want to update
     *   }
     * })
     */
    upsert<T extends campaignsUpsertArgs>(args: SelectSubset<T, campaignsUpsertArgs<ExtArgs>>): Prisma__campaignsClient<$Result.GetResult<Prisma.$campaignsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaigns.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends campaignsCountArgs>(
      args?: Subset<T, campaignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignsAggregateArgs>(args: Subset<T, CampaignsAggregateArgs>): Prisma.PrismaPromise<GetCampaignsAggregateType<T>>

    /**
     * Group by Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {campaignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends campaignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: campaignsGroupByArgs['orderBy'] }
        : { orderBy?: campaignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, campaignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the campaigns model
   */
  readonly fields: campaignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for campaigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__campaignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the campaigns model
   */ 
  interface campaignsFieldRefs {
    readonly id: FieldRef<"campaigns", 'String'>
    readonly studentId: FieldRef<"campaigns", 'String'>
    readonly type: FieldRef<"campaigns", 'String'>
    readonly status: FieldRef<"campaigns", 'String'>
    readonly metadata: FieldRef<"campaigns", 'Json'>
    readonly createdAt: FieldRef<"campaigns", 'DateTime'>
    readonly updatedAt: FieldRef<"campaigns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * campaigns findUnique
   */
  export type campaignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns findUniqueOrThrow
   */
  export type campaignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns findFirst
   */
  export type campaignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns findFirstOrThrow
   */
  export type campaignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of campaigns.
     */
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns findMany
   */
  export type campaignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter, which campaigns to fetch.
     */
    where?: campaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of campaigns to fetch.
     */
    orderBy?: campaignsOrderByWithRelationInput | campaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing campaigns.
     */
    cursor?: campaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` campaigns.
     */
    skip?: number
    distinct?: CampaignsScalarFieldEnum | CampaignsScalarFieldEnum[]
  }

  /**
   * campaigns create
   */
  export type campaignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The data needed to create a campaigns.
     */
    data: XOR<campaignsCreateInput, campaignsUncheckedCreateInput>
  }

  /**
   * campaigns createMany
   */
  export type campaignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many campaigns.
     */
    data: campaignsCreateManyInput | campaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * campaigns createManyAndReturn
   */
  export type campaignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many campaigns.
     */
    data: campaignsCreateManyInput | campaignsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * campaigns update
   */
  export type campaignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The data needed to update a campaigns.
     */
    data: XOR<campaignsUpdateInput, campaignsUncheckedUpdateInput>
    /**
     * Choose, which campaigns to update.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns updateMany
   */
  export type campaignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update campaigns.
     */
    data: XOR<campaignsUpdateManyMutationInput, campaignsUncheckedUpdateManyInput>
    /**
     * Filter which campaigns to update
     */
    where?: campaignsWhereInput
  }

  /**
   * campaigns upsert
   */
  export type campaignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * The filter to search for the campaigns to update in case it exists.
     */
    where: campaignsWhereUniqueInput
    /**
     * In case the campaigns found by the `where` argument doesn't exist, create a new campaigns with this data.
     */
    create: XOR<campaignsCreateInput, campaignsUncheckedCreateInput>
    /**
     * In case the campaigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<campaignsUpdateInput, campaignsUncheckedUpdateInput>
  }

  /**
   * campaigns delete
   */
  export type campaignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
    /**
     * Filter which campaigns to delete.
     */
    where: campaignsWhereUniqueInput
  }

  /**
   * campaigns deleteMany
   */
  export type campaignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which campaigns to delete
     */
    where?: campaignsWhereInput
  }

  /**
   * campaigns without action
   */
  export type campaignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the campaigns
     */
    select?: campaignsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: campaignsInclude<ExtArgs> | null
  }


  /**
   * Model reward_configs
   */

  export type AggregateReward_configs = {
    _count: Reward_configsCountAggregateOutputType | null
    _avg: Reward_configsAvgAggregateOutputType | null
    _sum: Reward_configsSumAggregateOutputType | null
    _min: Reward_configsMinAggregateOutputType | null
    _max: Reward_configsMaxAggregateOutputType | null
  }

  export type Reward_configsAvgAggregateOutputType = {
    expReward: number | null
    pointsReward: number | null
  }

  export type Reward_configsSumAggregateOutputType = {
    expReward: number | null
    pointsReward: number | null
  }

  export type Reward_configsMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    module: string | null
    category: string | null
    action: string | null
    expReward: number | null
    pointsReward: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Reward_configsMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    module: string | null
    category: string | null
    action: string | null
    expReward: number | null
    pointsReward: number | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Reward_configsCountAggregateOutputType = {
    id: number
    schoolId: number
    module: number
    category: number
    action: number
    expReward: number
    pointsReward: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Reward_configsAvgAggregateInputType = {
    expReward?: true
    pointsReward?: true
  }

  export type Reward_configsSumAggregateInputType = {
    expReward?: true
    pointsReward?: true
  }

  export type Reward_configsMinAggregateInputType = {
    id?: true
    schoolId?: true
    module?: true
    category?: true
    action?: true
    expReward?: true
    pointsReward?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Reward_configsMaxAggregateInputType = {
    id?: true
    schoolId?: true
    module?: true
    category?: true
    action?: true
    expReward?: true
    pointsReward?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Reward_configsCountAggregateInputType = {
    id?: true
    schoolId?: true
    module?: true
    category?: true
    action?: true
    expReward?: true
    pointsReward?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Reward_configsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward_configs to aggregate.
     */
    where?: reward_configsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_configs to fetch.
     */
    orderBy?: reward_configsOrderByWithRelationInput | reward_configsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reward_configsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reward_configs
    **/
    _count?: true | Reward_configsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reward_configsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reward_configsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reward_configsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reward_configsMaxAggregateInputType
  }

  export type GetReward_configsAggregateType<T extends Reward_configsAggregateArgs> = {
        [P in keyof T & keyof AggregateReward_configs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward_configs[P]>
      : GetScalarType<T[P], AggregateReward_configs[P]>
  }




  export type reward_configsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reward_configsWhereInput
    orderBy?: reward_configsOrderByWithAggregationInput | reward_configsOrderByWithAggregationInput[]
    by: Reward_configsScalarFieldEnum[] | Reward_configsScalarFieldEnum
    having?: reward_configsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reward_configsCountAggregateInputType | true
    _avg?: Reward_configsAvgAggregateInputType
    _sum?: Reward_configsSumAggregateInputType
    _min?: Reward_configsMinAggregateInputType
    _max?: Reward_configsMaxAggregateInputType
  }

  export type Reward_configsGroupByOutputType = {
    id: string
    schoolId: string
    module: string
    category: string | null
    action: string
    expReward: number
    pointsReward: number
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: Reward_configsCountAggregateOutputType | null
    _avg: Reward_configsAvgAggregateOutputType | null
    _sum: Reward_configsSumAggregateOutputType | null
    _min: Reward_configsMinAggregateOutputType | null
    _max: Reward_configsMaxAggregateOutputType | null
  }

  type GetReward_configsGroupByPayload<T extends reward_configsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reward_configsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reward_configsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reward_configsGroupByOutputType[P]>
            : GetScalarType<T[P], Reward_configsGroupByOutputType[P]>
        }
      >
    >


  export type reward_configsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    module?: boolean
    category?: boolean
    action?: boolean
    expReward?: boolean
    pointsReward?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward_configs"]>

  export type reward_configsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    module?: boolean
    category?: boolean
    action?: boolean
    expReward?: boolean
    pointsReward?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reward_configs"]>

  export type reward_configsSelectScalar = {
    id?: boolean
    schoolId?: boolean
    module?: boolean
    category?: boolean
    action?: boolean
    expReward?: boolean
    pointsReward?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type reward_configsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }
  export type reward_configsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | schoolsDefaultArgs<ExtArgs>
  }

  export type $reward_configsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reward_configs"
    objects: {
      schools: Prisma.$schoolsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      module: string
      category: string | null
      action: string
      expReward: number
      pointsReward: number
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reward_configs"]>
    composites: {}
  }

  type reward_configsGetPayload<S extends boolean | null | undefined | reward_configsDefaultArgs> = $Result.GetResult<Prisma.$reward_configsPayload, S>

  type reward_configsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reward_configsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Reward_configsCountAggregateInputType | true
    }

  export interface reward_configsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reward_configs'], meta: { name: 'reward_configs' } }
    /**
     * Find zero or one Reward_configs that matches the filter.
     * @param {reward_configsFindUniqueArgs} args - Arguments to find a Reward_configs
     * @example
     * // Get one Reward_configs
     * const reward_configs = await prisma.reward_configs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reward_configsFindUniqueArgs>(args: SelectSubset<T, reward_configsFindUniqueArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reward_configs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reward_configsFindUniqueOrThrowArgs} args - Arguments to find a Reward_configs
     * @example
     * // Get one Reward_configs
     * const reward_configs = await prisma.reward_configs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reward_configsFindUniqueOrThrowArgs>(args: SelectSubset<T, reward_configsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reward_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsFindFirstArgs} args - Arguments to find a Reward_configs
     * @example
     * // Get one Reward_configs
     * const reward_configs = await prisma.reward_configs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reward_configsFindFirstArgs>(args?: SelectSubset<T, reward_configsFindFirstArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reward_configs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsFindFirstOrThrowArgs} args - Arguments to find a Reward_configs
     * @example
     * // Get one Reward_configs
     * const reward_configs = await prisma.reward_configs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reward_configsFindFirstOrThrowArgs>(args?: SelectSubset<T, reward_configsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reward_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reward_configs
     * const reward_configs = await prisma.reward_configs.findMany()
     * 
     * // Get first 10 Reward_configs
     * const reward_configs = await prisma.reward_configs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reward_configsWithIdOnly = await prisma.reward_configs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reward_configsFindManyArgs>(args?: SelectSubset<T, reward_configsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reward_configs.
     * @param {reward_configsCreateArgs} args - Arguments to create a Reward_configs.
     * @example
     * // Create one Reward_configs
     * const Reward_configs = await prisma.reward_configs.create({
     *   data: {
     *     // ... data to create a Reward_configs
     *   }
     * })
     * 
     */
    create<T extends reward_configsCreateArgs>(args: SelectSubset<T, reward_configsCreateArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reward_configs.
     * @param {reward_configsCreateManyArgs} args - Arguments to create many Reward_configs.
     * @example
     * // Create many Reward_configs
     * const reward_configs = await prisma.reward_configs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reward_configsCreateManyArgs>(args?: SelectSubset<T, reward_configsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reward_configs and returns the data saved in the database.
     * @param {reward_configsCreateManyAndReturnArgs} args - Arguments to create many Reward_configs.
     * @example
     * // Create many Reward_configs
     * const reward_configs = await prisma.reward_configs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reward_configs and only return the `id`
     * const reward_configsWithIdOnly = await prisma.reward_configs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reward_configsCreateManyAndReturnArgs>(args?: SelectSubset<T, reward_configsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reward_configs.
     * @param {reward_configsDeleteArgs} args - Arguments to delete one Reward_configs.
     * @example
     * // Delete one Reward_configs
     * const Reward_configs = await prisma.reward_configs.delete({
     *   where: {
     *     // ... filter to delete one Reward_configs
     *   }
     * })
     * 
     */
    delete<T extends reward_configsDeleteArgs>(args: SelectSubset<T, reward_configsDeleteArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reward_configs.
     * @param {reward_configsUpdateArgs} args - Arguments to update one Reward_configs.
     * @example
     * // Update one Reward_configs
     * const reward_configs = await prisma.reward_configs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reward_configsUpdateArgs>(args: SelectSubset<T, reward_configsUpdateArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reward_configs.
     * @param {reward_configsDeleteManyArgs} args - Arguments to filter Reward_configs to delete.
     * @example
     * // Delete a few Reward_configs
     * const { count } = await prisma.reward_configs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reward_configsDeleteManyArgs>(args?: SelectSubset<T, reward_configsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reward_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reward_configs
     * const reward_configs = await prisma.reward_configs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reward_configsUpdateManyArgs>(args: SelectSubset<T, reward_configsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward_configs.
     * @param {reward_configsUpsertArgs} args - Arguments to update or create a Reward_configs.
     * @example
     * // Update or create a Reward_configs
     * const reward_configs = await prisma.reward_configs.upsert({
     *   create: {
     *     // ... data to create a Reward_configs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward_configs we want to update
     *   }
     * })
     */
    upsert<T extends reward_configsUpsertArgs>(args: SelectSubset<T, reward_configsUpsertArgs<ExtArgs>>): Prisma__reward_configsClient<$Result.GetResult<Prisma.$reward_configsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reward_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsCountArgs} args - Arguments to filter Reward_configs to count.
     * @example
     * // Count the number of Reward_configs
     * const count = await prisma.reward_configs.count({
     *   where: {
     *     // ... the filter for the Reward_configs we want to count
     *   }
     * })
    **/
    count<T extends reward_configsCountArgs>(
      args?: Subset<T, reward_configsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reward_configsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reward_configsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reward_configsAggregateArgs>(args: Subset<T, Reward_configsAggregateArgs>): Prisma.PrismaPromise<GetReward_configsAggregateType<T>>

    /**
     * Group by Reward_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_configsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reward_configsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reward_configsGroupByArgs['orderBy'] }
        : { orderBy?: reward_configsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reward_configsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReward_configsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reward_configs model
   */
  readonly fields: reward_configsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reward_configs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reward_configsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schools<T extends schoolsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolsDefaultArgs<ExtArgs>>): Prisma__schoolsClient<$Result.GetResult<Prisma.$schoolsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reward_configs model
   */ 
  interface reward_configsFieldRefs {
    readonly id: FieldRef<"reward_configs", 'String'>
    readonly schoolId: FieldRef<"reward_configs", 'String'>
    readonly module: FieldRef<"reward_configs", 'String'>
    readonly category: FieldRef<"reward_configs", 'String'>
    readonly action: FieldRef<"reward_configs", 'String'>
    readonly expReward: FieldRef<"reward_configs", 'Int'>
    readonly pointsReward: FieldRef<"reward_configs", 'Int'>
    readonly description: FieldRef<"reward_configs", 'String'>
    readonly isActive: FieldRef<"reward_configs", 'Boolean'>
    readonly createdAt: FieldRef<"reward_configs", 'DateTime'>
    readonly updatedAt: FieldRef<"reward_configs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reward_configs findUnique
   */
  export type reward_configsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter, which reward_configs to fetch.
     */
    where: reward_configsWhereUniqueInput
  }

  /**
   * reward_configs findUniqueOrThrow
   */
  export type reward_configsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter, which reward_configs to fetch.
     */
    where: reward_configsWhereUniqueInput
  }

  /**
   * reward_configs findFirst
   */
  export type reward_configsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter, which reward_configs to fetch.
     */
    where?: reward_configsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_configs to fetch.
     */
    orderBy?: reward_configsOrderByWithRelationInput | reward_configsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_configs.
     */
    cursor?: reward_configsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_configs.
     */
    distinct?: Reward_configsScalarFieldEnum | Reward_configsScalarFieldEnum[]
  }

  /**
   * reward_configs findFirstOrThrow
   */
  export type reward_configsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter, which reward_configs to fetch.
     */
    where?: reward_configsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_configs to fetch.
     */
    orderBy?: reward_configsOrderByWithRelationInput | reward_configsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_configs.
     */
    cursor?: reward_configsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_configs.
     */
    distinct?: Reward_configsScalarFieldEnum | Reward_configsScalarFieldEnum[]
  }

  /**
   * reward_configs findMany
   */
  export type reward_configsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter, which reward_configs to fetch.
     */
    where?: reward_configsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_configs to fetch.
     */
    orderBy?: reward_configsOrderByWithRelationInput | reward_configsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reward_configs.
     */
    cursor?: reward_configsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_configs.
     */
    skip?: number
    distinct?: Reward_configsScalarFieldEnum | Reward_configsScalarFieldEnum[]
  }

  /**
   * reward_configs create
   */
  export type reward_configsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * The data needed to create a reward_configs.
     */
    data: XOR<reward_configsCreateInput, reward_configsUncheckedCreateInput>
  }

  /**
   * reward_configs createMany
   */
  export type reward_configsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reward_configs.
     */
    data: reward_configsCreateManyInput | reward_configsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reward_configs createManyAndReturn
   */
  export type reward_configsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many reward_configs.
     */
    data: reward_configsCreateManyInput | reward_configsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reward_configs update
   */
  export type reward_configsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * The data needed to update a reward_configs.
     */
    data: XOR<reward_configsUpdateInput, reward_configsUncheckedUpdateInput>
    /**
     * Choose, which reward_configs to update.
     */
    where: reward_configsWhereUniqueInput
  }

  /**
   * reward_configs updateMany
   */
  export type reward_configsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reward_configs.
     */
    data: XOR<reward_configsUpdateManyMutationInput, reward_configsUncheckedUpdateManyInput>
    /**
     * Filter which reward_configs to update
     */
    where?: reward_configsWhereInput
  }

  /**
   * reward_configs upsert
   */
  export type reward_configsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * The filter to search for the reward_configs to update in case it exists.
     */
    where: reward_configsWhereUniqueInput
    /**
     * In case the reward_configs found by the `where` argument doesn't exist, create a new reward_configs with this data.
     */
    create: XOR<reward_configsCreateInput, reward_configsUncheckedCreateInput>
    /**
     * In case the reward_configs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reward_configsUpdateInput, reward_configsUncheckedUpdateInput>
  }

  /**
   * reward_configs delete
   */
  export type reward_configsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
    /**
     * Filter which reward_configs to delete.
     */
    where: reward_configsWhereUniqueInput
  }

  /**
   * reward_configs deleteMany
   */
  export type reward_configsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward_configs to delete
     */
    where?: reward_configsWhereInput
  }

  /**
   * reward_configs without action
   */
  export type reward_configsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward_configs
     */
    select?: reward_configsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reward_configsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BadgesScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    description: 'description',
    icon: 'icon',
    category: 'category',
    requirement: 'requirement',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgesScalarFieldEnum = (typeof BadgesScalarFieldEnum)[keyof typeof BadgesScalarFieldEnum]


  export const Challenge_participantsScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    studentId: 'studentId',
    joinedAt: 'joinedAt',
    status: 'status',
    result: 'result',
    score: 'score',
    notes: 'notes',
    completedAt: 'completedAt'
  };

  export type Challenge_participantsScalarFieldEnum = (typeof Challenge_participantsScalarFieldEnum)[keyof typeof Challenge_participantsScalarFieldEnum]


  export const ChallengesScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    creatorId: 'creatorId',
    startDate: 'startDate',
    endDate: 'endDate',
    rewardPoints: 'rewardPoints',
    rewardExp: 'rewardExp',
    maxParticipants: 'maxParticipants',
    metadata: 'metadata',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengesScalarFieldEnum = (typeof ChallengesScalarFieldEnum)[keyof typeof ChallengesScalarFieldEnum]


  export const Habit_logsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    habitId: 'habitId',
    studentId: 'studentId',
    checkedAt: 'checkedAt',
    streakDays: 'streakDays',
    notes: 'notes'
  };

  export type Habit_logsScalarFieldEnum = (typeof Habit_logsScalarFieldEnum)[keyof typeof Habit_logsScalarFieldEnum]


  export const HabitsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    description: 'description',
    icon: 'icon',
    expReward: 'expReward',
    pointsReward: 'pointsReward',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HabitsScalarFieldEnum = (typeof HabitsScalarFieldEnum)[keyof typeof HabitsScalarFieldEnum]


  export const Lesson_plansScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    teacherId: 'teacherId',
    title: 'title',
    content: 'content',
    date: 'date',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isGlobal: 'isGlobal'
  };

  export type Lesson_plansScalarFieldEnum = (typeof Lesson_plansScalarFieldEnum)[keyof typeof Lesson_plansScalarFieldEnum]


  export const MistakesScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    studentId: 'studentId',
    imageUrl: 'imageUrl',
    ocrText: 'ocrText',
    status: 'status',
    category: 'category',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aiAnalysis: 'aiAnalysis',
    errorCause: 'errorCause',
    lastRetryAt: 'lastRetryAt',
    lesson: 'lesson',
    questionNo: 'questionNo',
    retryCount: 'retryCount',
    subject: 'subject',
    unit: 'unit',
    workbookPage: 'workbookPage',
    wrongCount: 'wrongCount'
  };

  export type MistakesScalarFieldEnum = (typeof MistakesScalarFieldEnum)[keyof typeof MistakesScalarFieldEnum]


  export const Pk_matchesScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    studentA: 'studentA',
    studentB: 'studentB',
    winnerId: 'winnerId',
    status: 'status',
    topic: 'topic',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Pk_matchesScalarFieldEnum = (typeof Pk_matchesScalarFieldEnum)[keyof typeof Pk_matchesScalarFieldEnum]


  export const SchoolsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    planType: 'planType',
    settings: 'settings',
    educationalPhilosophy: 'educationalPhilosophy',
    expiredAt: 'expiredAt'
  };

  export type SchoolsScalarFieldEnum = (typeof SchoolsScalarFieldEnum)[keyof typeof SchoolsScalarFieldEnum]


  export const Student_badgesScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    badgeId: 'badgeId',
    awardedBy: 'awardedBy',
    awardedAt: 'awardedAt',
    reason: 'reason'
  };

  export type Student_badgesScalarFieldEnum = (typeof Student_badgesScalarFieldEnum)[keyof typeof Student_badgesScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    className: 'className',
    level: 'level',
    points: 'points',
    exp: 'exp',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamId: 'teamId',
    teacherId: 'teacherId',
    currentLesson: 'currentLesson',
    currentLessonTitle: 'currentLessonTitle',
    currentUnit: 'currentUnit',
    currentInviteCode: 'currentInviteCode',
    inviteCodeExpiresAt: 'inviteCodeExpiresAt',
    deletedAt: 'deletedAt',
    grade: 'grade',
    semester: 'semester',
    currentProgress: 'currentProgress'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const Student_checkinsScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    schoolId: 'schoolId',
    checkinDate: 'checkinDate',
    checkedBy: 'checkedBy',
    createdAt: 'createdAt'
  };

  export type Student_checkinsScalarFieldEnum = (typeof Student_checkinsScalarFieldEnum)[keyof typeof Student_checkinsScalarFieldEnum]


  export const Task_libraryScalarFieldEnum: {
    id: 'id',
    category: 'category',
    name: 'name',
    description: 'description',
    defaultExp: 'defaultExp',
    type: 'type',
    difficulty: 'difficulty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    schoolId: 'schoolId',
    isGlobal: 'isGlobal',
    educationalDomain: 'educationalDomain',
    educationalSubcategory: 'educationalSubcategory'
  };

  export type Task_libraryScalarFieldEnum = (typeof Task_libraryScalarFieldEnum)[keyof typeof Task_libraryScalarFieldEnum]


  export const Task_recordsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    studentId: 'studentId',
    type: 'type',
    title: 'title',
    content: 'content',
    status: 'status',
    expAwarded: 'expAwarded',
    submittedAt: 'submittedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lessonPlanId: 'lessonPlanId',
    task_category: 'task_category',
    is_current: 'is_current',
    attempts: 'attempts',
    subject: 'subject',
    isOverridden: 'isOverridden',
    settledAt: 'settledAt'
  };

  export type Task_recordsScalarFieldEnum = (typeof Task_recordsScalarFieldEnum)[keyof typeof Task_recordsScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    username: 'username',
    password: 'password',
    name: 'name',
    email: 'email',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    displayName: 'displayName',
    primaryClassName: 'primaryClassName'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const Personalized_tutoring_plansScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    schoolId: 'schoolId',
    title: 'title',
    subject: 'subject',
    difficulty: 'difficulty',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    duration: 'duration',
    actualStartTime: 'actualStartTime',
    actualEndTime: 'actualEndTime',
    studentId: 'studentId',
    studentName: 'studentName',
    studentClass: 'studentClass',
    knowledgePoints: 'knowledgePoints',
    mainProblem: 'mainProblem',
    detailedContent: 'detailedContent',
    teachingObjectives: 'teachingObjectives',
    preparationMaterials: 'preparationMaterials',
    tutoringMethods: 'tutoringMethods',
    expReward: 'expReward',
    pointsReward: 'pointsReward',
    expAwarded: 'expAwarded',
    pointsAwarded: 'pointsAwarded',
    status: 'status',
    completionNotes: 'completionNotes',
    studentFeedback: 'studentFeedback',
    parentFeedback: 'parentFeedback',
    effectivenessRating: 'effectivenessRating',
    followUpRequired: 'followUpRequired',
    followUpDate: 'followUpDate',
    followUpNotes: 'followUpNotes',
    attachments: 'attachments',
    totalSessions: 'totalSessions',
    completedSessions: 'completedSessions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Personalized_tutoring_plansScalarFieldEnum = (typeof Personalized_tutoring_plansScalarFieldEnum)[keyof typeof Personalized_tutoring_plansScalarFieldEnum]


  export const ParentsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    phone: 'phone',
    password: 'password',
    name: 'name',
    identity: 'identity',
    lastLoginAt: 'lastLoginAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentsScalarFieldEnum = (typeof ParentsScalarFieldEnum)[keyof typeof ParentsScalarFieldEnum]


  export const Parent_student_bindingsScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    studentId: 'studentId',
    inviteCode: 'inviteCode',
    bindingTime: 'bindingTime',
    isActive: 'isActive'
  };

  export type Parent_student_bindingsScalarFieldEnum = (typeof Parent_student_bindingsScalarFieldEnum)[keyof typeof Parent_student_bindingsScalarFieldEnum]


  export const Daily_summariesScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    date: 'date',
    parentLiked: 'parentLiked',
    parentComment: 'parentComment',
    teacherRead: 'teacherRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Daily_summariesScalarFieldEnum = (typeof Daily_summariesScalarFieldEnum)[keyof typeof Daily_summariesScalarFieldEnum]


  export const CampaignsScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    type: 'type',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignsScalarFieldEnum = (typeof CampaignsScalarFieldEnum)[keyof typeof CampaignsScalarFieldEnum]


  export const Reward_configsScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    module: 'module',
    category: 'category',
    action: 'action',
    expReward: 'expReward',
    pointsReward: 'pointsReward',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Reward_configsScalarFieldEnum = (typeof Reward_configsScalarFieldEnum)[keyof typeof Reward_configsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ParticipantStatus'
   */
  export type EnumParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantStatus'>
    


  /**
   * Reference to a field of type 'ParticipantStatus[]'
   */
  export type ListEnumParticipantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantStatus[]'>
    


  /**
   * Reference to a field of type 'ParticipantResult'
   */
  export type EnumParticipantResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantResult'>
    


  /**
   * Reference to a field of type 'ParticipantResult[]'
   */
  export type ListEnumParticipantResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantResult[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ChallengeType'
   */
  export type EnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType'>
    


  /**
   * Reference to a field of type 'ChallengeType[]'
   */
  export type ListEnumChallengeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeType[]'>
    


  /**
   * Reference to a field of type 'ChallengeStatus'
   */
  export type EnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus'>
    


  /**
   * Reference to a field of type 'ChallengeStatus[]'
   */
  export type ListEnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeStatus[]'>
    


  /**
   * Reference to a field of type 'MistakeStatus'
   */
  export type EnumMistakeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MistakeStatus'>
    


  /**
   * Reference to a field of type 'MistakeStatus[]'
   */
  export type ListEnumMistakeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MistakeStatus[]'>
    


  /**
   * Reference to a field of type 'PKStatus'
   */
  export type EnumPKStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PKStatus'>
    


  /**
   * Reference to a field of type 'PKStatus[]'
   */
  export type ListEnumPKStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PKStatus[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'TaskCategory'
   */
  export type EnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory'>
    


  /**
   * Reference to a field of type 'TaskCategory[]'
   */
  export type ListEnumTaskCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskCategory[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type badgesWhereInput = {
    AND?: badgesWhereInput | badgesWhereInput[]
    OR?: badgesWhereInput[]
    NOT?: badgesWhereInput | badgesWhereInput[]
    id?: StringFilter<"badges"> | string
    schoolId?: StringFilter<"badges"> | string
    name?: StringFilter<"badges"> | string
    description?: StringNullableFilter<"badges"> | string | null
    icon?: StringNullableFilter<"badges"> | string | null
    category?: StringFilter<"badges"> | string
    requirement?: JsonNullableFilter<"badges">
    isActive?: BoolFilter<"badges"> | boolean
    createdAt?: DateTimeFilter<"badges"> | Date | string
    updatedAt?: DateTimeFilter<"badges"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    student_badges?: Student_badgesListRelationFilter
  }

  export type badgesOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    requirement?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    student_badges?: student_badgesOrderByRelationAggregateInput
  }

  export type badgesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: badgesSchoolIdNameCompoundUniqueInput
    AND?: badgesWhereInput | badgesWhereInput[]
    OR?: badgesWhereInput[]
    NOT?: badgesWhereInput | badgesWhereInput[]
    schoolId?: StringFilter<"badges"> | string
    name?: StringFilter<"badges"> | string
    description?: StringNullableFilter<"badges"> | string | null
    icon?: StringNullableFilter<"badges"> | string | null
    category?: StringFilter<"badges"> | string
    requirement?: JsonNullableFilter<"badges">
    isActive?: BoolFilter<"badges"> | boolean
    createdAt?: DateTimeFilter<"badges"> | Date | string
    updatedAt?: DateTimeFilter<"badges"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    student_badges?: Student_badgesListRelationFilter
  }, "id" | "schoolId_name">

  export type badgesOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    requirement?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: badgesCountOrderByAggregateInput
    _max?: badgesMaxOrderByAggregateInput
    _min?: badgesMinOrderByAggregateInput
  }

  export type badgesScalarWhereWithAggregatesInput = {
    AND?: badgesScalarWhereWithAggregatesInput | badgesScalarWhereWithAggregatesInput[]
    OR?: badgesScalarWhereWithAggregatesInput[]
    NOT?: badgesScalarWhereWithAggregatesInput | badgesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"badges"> | string
    schoolId?: StringWithAggregatesFilter<"badges"> | string
    name?: StringWithAggregatesFilter<"badges"> | string
    description?: StringNullableWithAggregatesFilter<"badges"> | string | null
    icon?: StringNullableWithAggregatesFilter<"badges"> | string | null
    category?: StringWithAggregatesFilter<"badges"> | string
    requirement?: JsonNullableWithAggregatesFilter<"badges">
    isActive?: BoolWithAggregatesFilter<"badges"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"badges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"badges"> | Date | string
  }

  export type challenge_participantsWhereInput = {
    AND?: challenge_participantsWhereInput | challenge_participantsWhereInput[]
    OR?: challenge_participantsWhereInput[]
    NOT?: challenge_participantsWhereInput | challenge_participantsWhereInput[]
    id?: StringFilter<"challenge_participants"> | string
    challengeId?: StringFilter<"challenge_participants"> | string
    studentId?: StringFilter<"challenge_participants"> | string
    joinedAt?: DateTimeFilter<"challenge_participants"> | Date | string
    status?: EnumParticipantStatusFilter<"challenge_participants"> | $Enums.ParticipantStatus
    result?: EnumParticipantResultNullableFilter<"challenge_participants"> | $Enums.ParticipantResult | null
    score?: IntNullableFilter<"challenge_participants"> | number | null
    notes?: StringNullableFilter<"challenge_participants"> | string | null
    completedAt?: DateTimeNullableFilter<"challenge_participants"> | Date | string | null
    challenges?: XOR<ChallengesRelationFilter, challengesWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type challenge_participantsOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    challenges?: challengesOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type challenge_participantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challengeId_studentId?: challenge_participantsChallengeIdStudentIdCompoundUniqueInput
    AND?: challenge_participantsWhereInput | challenge_participantsWhereInput[]
    OR?: challenge_participantsWhereInput[]
    NOT?: challenge_participantsWhereInput | challenge_participantsWhereInput[]
    challengeId?: StringFilter<"challenge_participants"> | string
    studentId?: StringFilter<"challenge_participants"> | string
    joinedAt?: DateTimeFilter<"challenge_participants"> | Date | string
    status?: EnumParticipantStatusFilter<"challenge_participants"> | $Enums.ParticipantStatus
    result?: EnumParticipantResultNullableFilter<"challenge_participants"> | $Enums.ParticipantResult | null
    score?: IntNullableFilter<"challenge_participants"> | number | null
    notes?: StringNullableFilter<"challenge_participants"> | string | null
    completedAt?: DateTimeNullableFilter<"challenge_participants"> | Date | string | null
    challenges?: XOR<ChallengesRelationFilter, challengesWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id" | "challengeId_studentId">

  export type challenge_participantsOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: challenge_participantsCountOrderByAggregateInput
    _avg?: challenge_participantsAvgOrderByAggregateInput
    _max?: challenge_participantsMaxOrderByAggregateInput
    _min?: challenge_participantsMinOrderByAggregateInput
    _sum?: challenge_participantsSumOrderByAggregateInput
  }

  export type challenge_participantsScalarWhereWithAggregatesInput = {
    AND?: challenge_participantsScalarWhereWithAggregatesInput | challenge_participantsScalarWhereWithAggregatesInput[]
    OR?: challenge_participantsScalarWhereWithAggregatesInput[]
    NOT?: challenge_participantsScalarWhereWithAggregatesInput | challenge_participantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"challenge_participants"> | string
    challengeId?: StringWithAggregatesFilter<"challenge_participants"> | string
    studentId?: StringWithAggregatesFilter<"challenge_participants"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"challenge_participants"> | Date | string
    status?: EnumParticipantStatusWithAggregatesFilter<"challenge_participants"> | $Enums.ParticipantStatus
    result?: EnumParticipantResultNullableWithAggregatesFilter<"challenge_participants"> | $Enums.ParticipantResult | null
    score?: IntNullableWithAggregatesFilter<"challenge_participants"> | number | null
    notes?: StringNullableWithAggregatesFilter<"challenge_participants"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"challenge_participants"> | Date | string | null
  }

  export type challengesWhereInput = {
    AND?: challengesWhereInput | challengesWhereInput[]
    OR?: challengesWhereInput[]
    NOT?: challengesWhereInput | challengesWhereInput[]
    id?: StringFilter<"challenges"> | string
    schoolId?: StringFilter<"challenges"> | string
    title?: StringFilter<"challenges"> | string
    description?: StringNullableFilter<"challenges"> | string | null
    type?: EnumChallengeTypeFilter<"challenges"> | $Enums.ChallengeType
    status?: EnumChallengeStatusFilter<"challenges"> | $Enums.ChallengeStatus
    creatorId?: StringFilter<"challenges"> | string
    startDate?: DateTimeFilter<"challenges"> | Date | string
    endDate?: DateTimeNullableFilter<"challenges"> | Date | string | null
    rewardPoints?: IntFilter<"challenges"> | number
    rewardExp?: IntFilter<"challenges"> | number
    maxParticipants?: IntFilter<"challenges"> | number
    metadata?: JsonNullableFilter<"challenges">
    isActive?: BoolFilter<"challenges"> | boolean
    createdAt?: DateTimeFilter<"challenges"> | Date | string
    updatedAt?: DateTimeFilter<"challenges"> | Date | string
    challenge_participants?: Challenge_participantsListRelationFilter
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }

  export type challengesOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    challenge_participants?: challenge_participantsOrderByRelationAggregateInput
    teachers?: teachersOrderByWithRelationInput
    schools?: schoolsOrderByWithRelationInput
  }

  export type challengesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: challengesWhereInput | challengesWhereInput[]
    OR?: challengesWhereInput[]
    NOT?: challengesWhereInput | challengesWhereInput[]
    schoolId?: StringFilter<"challenges"> | string
    title?: StringFilter<"challenges"> | string
    description?: StringNullableFilter<"challenges"> | string | null
    type?: EnumChallengeTypeFilter<"challenges"> | $Enums.ChallengeType
    status?: EnumChallengeStatusFilter<"challenges"> | $Enums.ChallengeStatus
    creatorId?: StringFilter<"challenges"> | string
    startDate?: DateTimeFilter<"challenges"> | Date | string
    endDate?: DateTimeNullableFilter<"challenges"> | Date | string | null
    rewardPoints?: IntFilter<"challenges"> | number
    rewardExp?: IntFilter<"challenges"> | number
    maxParticipants?: IntFilter<"challenges"> | number
    metadata?: JsonNullableFilter<"challenges">
    isActive?: BoolFilter<"challenges"> | boolean
    createdAt?: DateTimeFilter<"challenges"> | Date | string
    updatedAt?: DateTimeFilter<"challenges"> | Date | string
    challenge_participants?: Challenge_participantsListRelationFilter
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }, "id">

  export type challengesOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: challengesCountOrderByAggregateInput
    _avg?: challengesAvgOrderByAggregateInput
    _max?: challengesMaxOrderByAggregateInput
    _min?: challengesMinOrderByAggregateInput
    _sum?: challengesSumOrderByAggregateInput
  }

  export type challengesScalarWhereWithAggregatesInput = {
    AND?: challengesScalarWhereWithAggregatesInput | challengesScalarWhereWithAggregatesInput[]
    OR?: challengesScalarWhereWithAggregatesInput[]
    NOT?: challengesScalarWhereWithAggregatesInput | challengesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"challenges"> | string
    schoolId?: StringWithAggregatesFilter<"challenges"> | string
    title?: StringWithAggregatesFilter<"challenges"> | string
    description?: StringNullableWithAggregatesFilter<"challenges"> | string | null
    type?: EnumChallengeTypeWithAggregatesFilter<"challenges"> | $Enums.ChallengeType
    status?: EnumChallengeStatusWithAggregatesFilter<"challenges"> | $Enums.ChallengeStatus
    creatorId?: StringWithAggregatesFilter<"challenges"> | string
    startDate?: DateTimeWithAggregatesFilter<"challenges"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"challenges"> | Date | string | null
    rewardPoints?: IntWithAggregatesFilter<"challenges"> | number
    rewardExp?: IntWithAggregatesFilter<"challenges"> | number
    maxParticipants?: IntWithAggregatesFilter<"challenges"> | number
    metadata?: JsonNullableWithAggregatesFilter<"challenges">
    isActive?: BoolWithAggregatesFilter<"challenges"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"challenges"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"challenges"> | Date | string
  }

  export type habit_logsWhereInput = {
    AND?: habit_logsWhereInput | habit_logsWhereInput[]
    OR?: habit_logsWhereInput[]
    NOT?: habit_logsWhereInput | habit_logsWhereInput[]
    id?: StringFilter<"habit_logs"> | string
    schoolId?: StringFilter<"habit_logs"> | string
    habitId?: StringFilter<"habit_logs"> | string
    studentId?: StringFilter<"habit_logs"> | string
    checkedAt?: DateTimeFilter<"habit_logs"> | Date | string
    streakDays?: IntFilter<"habit_logs"> | number
    notes?: StringNullableFilter<"habit_logs"> | string | null
    habits?: XOR<HabitsRelationFilter, habitsWhereInput>
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type habit_logsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    habitId?: SortOrder
    studentId?: SortOrder
    checkedAt?: SortOrder
    streakDays?: SortOrder
    notes?: SortOrderInput | SortOrder
    habits?: habitsOrderByWithRelationInput
    schools?: schoolsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type habit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: habit_logsWhereInput | habit_logsWhereInput[]
    OR?: habit_logsWhereInput[]
    NOT?: habit_logsWhereInput | habit_logsWhereInput[]
    schoolId?: StringFilter<"habit_logs"> | string
    habitId?: StringFilter<"habit_logs"> | string
    studentId?: StringFilter<"habit_logs"> | string
    checkedAt?: DateTimeFilter<"habit_logs"> | Date | string
    streakDays?: IntFilter<"habit_logs"> | number
    notes?: StringNullableFilter<"habit_logs"> | string | null
    habits?: XOR<HabitsRelationFilter, habitsWhereInput>
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id">

  export type habit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    habitId?: SortOrder
    studentId?: SortOrder
    checkedAt?: SortOrder
    streakDays?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: habit_logsCountOrderByAggregateInput
    _avg?: habit_logsAvgOrderByAggregateInput
    _max?: habit_logsMaxOrderByAggregateInput
    _min?: habit_logsMinOrderByAggregateInput
    _sum?: habit_logsSumOrderByAggregateInput
  }

  export type habit_logsScalarWhereWithAggregatesInput = {
    AND?: habit_logsScalarWhereWithAggregatesInput | habit_logsScalarWhereWithAggregatesInput[]
    OR?: habit_logsScalarWhereWithAggregatesInput[]
    NOT?: habit_logsScalarWhereWithAggregatesInput | habit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"habit_logs"> | string
    schoolId?: StringWithAggregatesFilter<"habit_logs"> | string
    habitId?: StringWithAggregatesFilter<"habit_logs"> | string
    studentId?: StringWithAggregatesFilter<"habit_logs"> | string
    checkedAt?: DateTimeWithAggregatesFilter<"habit_logs"> | Date | string
    streakDays?: IntWithAggregatesFilter<"habit_logs"> | number
    notes?: StringNullableWithAggregatesFilter<"habit_logs"> | string | null
  }

  export type habitsWhereInput = {
    AND?: habitsWhereInput | habitsWhereInput[]
    OR?: habitsWhereInput[]
    NOT?: habitsWhereInput | habitsWhereInput[]
    id?: StringFilter<"habits"> | string
    schoolId?: StringFilter<"habits"> | string
    name?: StringFilter<"habits"> | string
    description?: StringNullableFilter<"habits"> | string | null
    icon?: StringNullableFilter<"habits"> | string | null
    expReward?: IntFilter<"habits"> | number
    pointsReward?: IntNullableFilter<"habits"> | number | null
    isActive?: BoolFilter<"habits"> | boolean
    createdAt?: DateTimeFilter<"habits"> | Date | string
    updatedAt?: DateTimeFilter<"habits"> | Date | string
    habit_logs?: Habit_logsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }

  export type habitsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    habit_logs?: habit_logsOrderByRelationAggregateInput
    schools?: schoolsOrderByWithRelationInput
  }

  export type habitsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: habitsSchoolIdNameCompoundUniqueInput
    AND?: habitsWhereInput | habitsWhereInput[]
    OR?: habitsWhereInput[]
    NOT?: habitsWhereInput | habitsWhereInput[]
    schoolId?: StringFilter<"habits"> | string
    name?: StringFilter<"habits"> | string
    description?: StringNullableFilter<"habits"> | string | null
    icon?: StringNullableFilter<"habits"> | string | null
    expReward?: IntFilter<"habits"> | number
    pointsReward?: IntNullableFilter<"habits"> | number | null
    isActive?: BoolFilter<"habits"> | boolean
    createdAt?: DateTimeFilter<"habits"> | Date | string
    updatedAt?: DateTimeFilter<"habits"> | Date | string
    habit_logs?: Habit_logsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }, "id" | "schoolId_name">

  export type habitsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: habitsCountOrderByAggregateInput
    _avg?: habitsAvgOrderByAggregateInput
    _max?: habitsMaxOrderByAggregateInput
    _min?: habitsMinOrderByAggregateInput
    _sum?: habitsSumOrderByAggregateInput
  }

  export type habitsScalarWhereWithAggregatesInput = {
    AND?: habitsScalarWhereWithAggregatesInput | habitsScalarWhereWithAggregatesInput[]
    OR?: habitsScalarWhereWithAggregatesInput[]
    NOT?: habitsScalarWhereWithAggregatesInput | habitsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"habits"> | string
    schoolId?: StringWithAggregatesFilter<"habits"> | string
    name?: StringWithAggregatesFilter<"habits"> | string
    description?: StringNullableWithAggregatesFilter<"habits"> | string | null
    icon?: StringNullableWithAggregatesFilter<"habits"> | string | null
    expReward?: IntWithAggregatesFilter<"habits"> | number
    pointsReward?: IntNullableWithAggregatesFilter<"habits"> | number | null
    isActive?: BoolWithAggregatesFilter<"habits"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"habits"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"habits"> | Date | string
  }

  export type lesson_plansWhereInput = {
    AND?: lesson_plansWhereInput | lesson_plansWhereInput[]
    OR?: lesson_plansWhereInput[]
    NOT?: lesson_plansWhereInput | lesson_plansWhereInput[]
    id?: StringFilter<"lesson_plans"> | string
    schoolId?: StringFilter<"lesson_plans"> | string
    teacherId?: StringFilter<"lesson_plans"> | string
    title?: StringFilter<"lesson_plans"> | string
    content?: JsonFilter<"lesson_plans">
    date?: DateTimeFilter<"lesson_plans"> | Date | string
    isActive?: BoolFilter<"lesson_plans"> | boolean
    createdAt?: DateTimeFilter<"lesson_plans"> | Date | string
    updatedAt?: DateTimeFilter<"lesson_plans"> | Date | string
    isGlobal?: BoolFilter<"lesson_plans"> | boolean
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
    task_records?: Task_recordsListRelationFilter
  }

  export type lesson_plansOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGlobal?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    task_records?: task_recordsOrderByRelationAggregateInput
  }

  export type lesson_plansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: lesson_plansWhereInput | lesson_plansWhereInput[]
    OR?: lesson_plansWhereInput[]
    NOT?: lesson_plansWhereInput | lesson_plansWhereInput[]
    schoolId?: StringFilter<"lesson_plans"> | string
    teacherId?: StringFilter<"lesson_plans"> | string
    title?: StringFilter<"lesson_plans"> | string
    content?: JsonFilter<"lesson_plans">
    date?: DateTimeFilter<"lesson_plans"> | Date | string
    isActive?: BoolFilter<"lesson_plans"> | boolean
    createdAt?: DateTimeFilter<"lesson_plans"> | Date | string
    updatedAt?: DateTimeFilter<"lesson_plans"> | Date | string
    isGlobal?: BoolFilter<"lesson_plans"> | boolean
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
    task_records?: Task_recordsListRelationFilter
  }, "id">

  export type lesson_plansOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGlobal?: SortOrder
    _count?: lesson_plansCountOrderByAggregateInput
    _max?: lesson_plansMaxOrderByAggregateInput
    _min?: lesson_plansMinOrderByAggregateInput
  }

  export type lesson_plansScalarWhereWithAggregatesInput = {
    AND?: lesson_plansScalarWhereWithAggregatesInput | lesson_plansScalarWhereWithAggregatesInput[]
    OR?: lesson_plansScalarWhereWithAggregatesInput[]
    NOT?: lesson_plansScalarWhereWithAggregatesInput | lesson_plansScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"lesson_plans"> | string
    schoolId?: StringWithAggregatesFilter<"lesson_plans"> | string
    teacherId?: StringWithAggregatesFilter<"lesson_plans"> | string
    title?: StringWithAggregatesFilter<"lesson_plans"> | string
    content?: JsonWithAggregatesFilter<"lesson_plans">
    date?: DateTimeWithAggregatesFilter<"lesson_plans"> | Date | string
    isActive?: BoolWithAggregatesFilter<"lesson_plans"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"lesson_plans"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"lesson_plans"> | Date | string
    isGlobal?: BoolWithAggregatesFilter<"lesson_plans"> | boolean
  }

  export type mistakesWhereInput = {
    AND?: mistakesWhereInput | mistakesWhereInput[]
    OR?: mistakesWhereInput[]
    NOT?: mistakesWhereInput | mistakesWhereInput[]
    id?: StringFilter<"mistakes"> | string
    schoolId?: StringFilter<"mistakes"> | string
    studentId?: StringFilter<"mistakes"> | string
    imageUrl?: StringNullableFilter<"mistakes"> | string | null
    ocrText?: StringNullableFilter<"mistakes"> | string | null
    status?: EnumMistakeStatusFilter<"mistakes"> | $Enums.MistakeStatus
    category?: StringNullableFilter<"mistakes"> | string | null
    notes?: StringNullableFilter<"mistakes"> | string | null
    createdAt?: DateTimeFilter<"mistakes"> | Date | string
    updatedAt?: DateTimeFilter<"mistakes"> | Date | string
    aiAnalysis?: JsonNullableFilter<"mistakes">
    errorCause?: StringNullableFilter<"mistakes"> | string | null
    lastRetryAt?: DateTimeNullableFilter<"mistakes"> | Date | string | null
    lesson?: StringNullableFilter<"mistakes"> | string | null
    questionNo?: IntNullableFilter<"mistakes"> | number | null
    retryCount?: IntFilter<"mistakes"> | number
    subject?: StringNullableFilter<"mistakes"> | string | null
    unit?: StringNullableFilter<"mistakes"> | string | null
    workbookPage?: IntNullableFilter<"mistakes"> | number | null
    wrongCount?: IntFilter<"mistakes"> | number
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type mistakesOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    ocrText?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    errorCause?: SortOrderInput | SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    lesson?: SortOrderInput | SortOrder
    questionNo?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    subject?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    workbookPage?: SortOrderInput | SortOrder
    wrongCount?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type mistakesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mistakesWhereInput | mistakesWhereInput[]
    OR?: mistakesWhereInput[]
    NOT?: mistakesWhereInput | mistakesWhereInput[]
    schoolId?: StringFilter<"mistakes"> | string
    studentId?: StringFilter<"mistakes"> | string
    imageUrl?: StringNullableFilter<"mistakes"> | string | null
    ocrText?: StringNullableFilter<"mistakes"> | string | null
    status?: EnumMistakeStatusFilter<"mistakes"> | $Enums.MistakeStatus
    category?: StringNullableFilter<"mistakes"> | string | null
    notes?: StringNullableFilter<"mistakes"> | string | null
    createdAt?: DateTimeFilter<"mistakes"> | Date | string
    updatedAt?: DateTimeFilter<"mistakes"> | Date | string
    aiAnalysis?: JsonNullableFilter<"mistakes">
    errorCause?: StringNullableFilter<"mistakes"> | string | null
    lastRetryAt?: DateTimeNullableFilter<"mistakes"> | Date | string | null
    lesson?: StringNullableFilter<"mistakes"> | string | null
    questionNo?: IntNullableFilter<"mistakes"> | number | null
    retryCount?: IntFilter<"mistakes"> | number
    subject?: StringNullableFilter<"mistakes"> | string | null
    unit?: StringNullableFilter<"mistakes"> | string | null
    workbookPage?: IntNullableFilter<"mistakes"> | number | null
    wrongCount?: IntFilter<"mistakes"> | number
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id">

  export type mistakesOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    ocrText?: SortOrderInput | SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiAnalysis?: SortOrderInput | SortOrder
    errorCause?: SortOrderInput | SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    lesson?: SortOrderInput | SortOrder
    questionNo?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    subject?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    workbookPage?: SortOrderInput | SortOrder
    wrongCount?: SortOrder
    _count?: mistakesCountOrderByAggregateInput
    _avg?: mistakesAvgOrderByAggregateInput
    _max?: mistakesMaxOrderByAggregateInput
    _min?: mistakesMinOrderByAggregateInput
    _sum?: mistakesSumOrderByAggregateInput
  }

  export type mistakesScalarWhereWithAggregatesInput = {
    AND?: mistakesScalarWhereWithAggregatesInput | mistakesScalarWhereWithAggregatesInput[]
    OR?: mistakesScalarWhereWithAggregatesInput[]
    NOT?: mistakesScalarWhereWithAggregatesInput | mistakesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"mistakes"> | string
    schoolId?: StringWithAggregatesFilter<"mistakes"> | string
    studentId?: StringWithAggregatesFilter<"mistakes"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    ocrText?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    status?: EnumMistakeStatusWithAggregatesFilter<"mistakes"> | $Enums.MistakeStatus
    category?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    notes?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"mistakes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"mistakes"> | Date | string
    aiAnalysis?: JsonNullableWithAggregatesFilter<"mistakes">
    errorCause?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    lastRetryAt?: DateTimeNullableWithAggregatesFilter<"mistakes"> | Date | string | null
    lesson?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    questionNo?: IntNullableWithAggregatesFilter<"mistakes"> | number | null
    retryCount?: IntWithAggregatesFilter<"mistakes"> | number
    subject?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    unit?: StringNullableWithAggregatesFilter<"mistakes"> | string | null
    workbookPage?: IntNullableWithAggregatesFilter<"mistakes"> | number | null
    wrongCount?: IntWithAggregatesFilter<"mistakes"> | number
  }

  export type pk_matchesWhereInput = {
    AND?: pk_matchesWhereInput | pk_matchesWhereInput[]
    OR?: pk_matchesWhereInput[]
    NOT?: pk_matchesWhereInput | pk_matchesWhereInput[]
    id?: StringFilter<"pk_matches"> | string
    schoolId?: StringFilter<"pk_matches"> | string
    studentA?: StringFilter<"pk_matches"> | string
    studentB?: StringFilter<"pk_matches"> | string
    winnerId?: StringNullableFilter<"pk_matches"> | string | null
    status?: EnumPKStatusFilter<"pk_matches"> | $Enums.PKStatus
    topic?: StringFilter<"pk_matches"> | string
    metadata?: JsonNullableFilter<"pk_matches">
    createdAt?: DateTimeFilter<"pk_matches"> | Date | string
    updatedAt?: DateTimeFilter<"pk_matches"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    playerA?: XOR<StudentsRelationFilter, studentsWhereInput>
    playerB?: XOR<StudentsRelationFilter, studentsWhereInput>
    winner?: XOR<StudentsNullableRelationFilter, studentsWhereInput> | null
  }

  export type pk_matchesOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentA?: SortOrder
    studentB?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    status?: SortOrder
    topic?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    playerA?: studentsOrderByWithRelationInput
    playerB?: studentsOrderByWithRelationInput
    winner?: studentsOrderByWithRelationInput
  }

  export type pk_matchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: pk_matchesWhereInput | pk_matchesWhereInput[]
    OR?: pk_matchesWhereInput[]
    NOT?: pk_matchesWhereInput | pk_matchesWhereInput[]
    schoolId?: StringFilter<"pk_matches"> | string
    studentA?: StringFilter<"pk_matches"> | string
    studentB?: StringFilter<"pk_matches"> | string
    winnerId?: StringNullableFilter<"pk_matches"> | string | null
    status?: EnumPKStatusFilter<"pk_matches"> | $Enums.PKStatus
    topic?: StringFilter<"pk_matches"> | string
    metadata?: JsonNullableFilter<"pk_matches">
    createdAt?: DateTimeFilter<"pk_matches"> | Date | string
    updatedAt?: DateTimeFilter<"pk_matches"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    playerA?: XOR<StudentsRelationFilter, studentsWhereInput>
    playerB?: XOR<StudentsRelationFilter, studentsWhereInput>
    winner?: XOR<StudentsNullableRelationFilter, studentsWhereInput> | null
  }, "id">

  export type pk_matchesOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentA?: SortOrder
    studentB?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    status?: SortOrder
    topic?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pk_matchesCountOrderByAggregateInput
    _max?: pk_matchesMaxOrderByAggregateInput
    _min?: pk_matchesMinOrderByAggregateInput
  }

  export type pk_matchesScalarWhereWithAggregatesInput = {
    AND?: pk_matchesScalarWhereWithAggregatesInput | pk_matchesScalarWhereWithAggregatesInput[]
    OR?: pk_matchesScalarWhereWithAggregatesInput[]
    NOT?: pk_matchesScalarWhereWithAggregatesInput | pk_matchesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pk_matches"> | string
    schoolId?: StringWithAggregatesFilter<"pk_matches"> | string
    studentA?: StringWithAggregatesFilter<"pk_matches"> | string
    studentB?: StringWithAggregatesFilter<"pk_matches"> | string
    winnerId?: StringNullableWithAggregatesFilter<"pk_matches"> | string | null
    status?: EnumPKStatusWithAggregatesFilter<"pk_matches"> | $Enums.PKStatus
    topic?: StringWithAggregatesFilter<"pk_matches"> | string
    metadata?: JsonNullableWithAggregatesFilter<"pk_matches">
    createdAt?: DateTimeWithAggregatesFilter<"pk_matches"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"pk_matches"> | Date | string
  }

  export type schoolsWhereInput = {
    AND?: schoolsWhereInput | schoolsWhereInput[]
    OR?: schoolsWhereInput[]
    NOT?: schoolsWhereInput | schoolsWhereInput[]
    id?: StringFilter<"schools"> | string
    name?: StringFilter<"schools"> | string
    createdAt?: DateTimeFilter<"schools"> | Date | string
    updatedAt?: DateTimeFilter<"schools"> | Date | string
    isActive?: BoolFilter<"schools"> | boolean
    planType?: EnumPlanTypeFilter<"schools"> | $Enums.PlanType
    settings?: JsonNullableFilter<"schools">
    educationalPhilosophy?: StringFilter<"schools"> | string
    expiredAt?: DateTimeNullableFilter<"schools"> | Date | string | null
    badges?: BadgesListRelationFilter
    challenges?: ChallengesListRelationFilter
    habit_logs?: Habit_logsListRelationFilter
    habits?: HabitsListRelationFilter
    lesson_plans?: Lesson_plansListRelationFilter
    mistakes?: MistakesListRelationFilter
    parents?: ParentsListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    pk_matches?: Pk_matchesListRelationFilter
    reward_configs?: Reward_configsListRelationFilter
    student_checkins?: Student_checkinsListRelationFilter
    students?: StudentsListRelationFilter
    task_library?: Task_libraryListRelationFilter
    task_records?: Task_recordsListRelationFilter
    teachers?: TeachersListRelationFilter
  }

  export type schoolsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    planType?: SortOrder
    settings?: SortOrderInput | SortOrder
    educationalPhilosophy?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    badges?: badgesOrderByRelationAggregateInput
    challenges?: challengesOrderByRelationAggregateInput
    habit_logs?: habit_logsOrderByRelationAggregateInput
    habits?: habitsOrderByRelationAggregateInput
    lesson_plans?: lesson_plansOrderByRelationAggregateInput
    mistakes?: mistakesOrderByRelationAggregateInput
    parents?: parentsOrderByRelationAggregateInput
    personalized_tutoring_plans?: personalized_tutoring_plansOrderByRelationAggregateInput
    pk_matches?: pk_matchesOrderByRelationAggregateInput
    reward_configs?: reward_configsOrderByRelationAggregateInput
    student_checkins?: student_checkinsOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
    task_library?: task_libraryOrderByRelationAggregateInput
    task_records?: task_recordsOrderByRelationAggregateInput
    teachers?: teachersOrderByRelationAggregateInput
  }

  export type schoolsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: schoolsWhereInput | schoolsWhereInput[]
    OR?: schoolsWhereInput[]
    NOT?: schoolsWhereInput | schoolsWhereInput[]
    name?: StringFilter<"schools"> | string
    createdAt?: DateTimeFilter<"schools"> | Date | string
    updatedAt?: DateTimeFilter<"schools"> | Date | string
    isActive?: BoolFilter<"schools"> | boolean
    planType?: EnumPlanTypeFilter<"schools"> | $Enums.PlanType
    settings?: JsonNullableFilter<"schools">
    educationalPhilosophy?: StringFilter<"schools"> | string
    expiredAt?: DateTimeNullableFilter<"schools"> | Date | string | null
    badges?: BadgesListRelationFilter
    challenges?: ChallengesListRelationFilter
    habit_logs?: Habit_logsListRelationFilter
    habits?: HabitsListRelationFilter
    lesson_plans?: Lesson_plansListRelationFilter
    mistakes?: MistakesListRelationFilter
    parents?: ParentsListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    pk_matches?: Pk_matchesListRelationFilter
    reward_configs?: Reward_configsListRelationFilter
    student_checkins?: Student_checkinsListRelationFilter
    students?: StudentsListRelationFilter
    task_library?: Task_libraryListRelationFilter
    task_records?: Task_recordsListRelationFilter
    teachers?: TeachersListRelationFilter
  }, "id">

  export type schoolsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    planType?: SortOrder
    settings?: SortOrderInput | SortOrder
    educationalPhilosophy?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    _count?: schoolsCountOrderByAggregateInput
    _max?: schoolsMaxOrderByAggregateInput
    _min?: schoolsMinOrderByAggregateInput
  }

  export type schoolsScalarWhereWithAggregatesInput = {
    AND?: schoolsScalarWhereWithAggregatesInput | schoolsScalarWhereWithAggregatesInput[]
    OR?: schoolsScalarWhereWithAggregatesInput[]
    NOT?: schoolsScalarWhereWithAggregatesInput | schoolsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"schools"> | string
    name?: StringWithAggregatesFilter<"schools"> | string
    createdAt?: DateTimeWithAggregatesFilter<"schools"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"schools"> | Date | string
    isActive?: BoolWithAggregatesFilter<"schools"> | boolean
    planType?: EnumPlanTypeWithAggregatesFilter<"schools"> | $Enums.PlanType
    settings?: JsonNullableWithAggregatesFilter<"schools">
    educationalPhilosophy?: StringWithAggregatesFilter<"schools"> | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"schools"> | Date | string | null
  }

  export type student_badgesWhereInput = {
    AND?: student_badgesWhereInput | student_badgesWhereInput[]
    OR?: student_badgesWhereInput[]
    NOT?: student_badgesWhereInput | student_badgesWhereInput[]
    id?: StringFilter<"student_badges"> | string
    studentId?: StringFilter<"student_badges"> | string
    badgeId?: StringFilter<"student_badges"> | string
    awardedBy?: StringNullableFilter<"student_badges"> | string | null
    awardedAt?: DateTimeFilter<"student_badges"> | Date | string
    reason?: StringNullableFilter<"student_badges"> | string | null
    badges?: XOR<BadgesRelationFilter, badgesWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type student_badgesOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    badgeId?: SortOrder
    awardedBy?: SortOrderInput | SortOrder
    awardedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    badges?: badgesOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type student_badgesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: student_badgesWhereInput | student_badgesWhereInput[]
    OR?: student_badgesWhereInput[]
    NOT?: student_badgesWhereInput | student_badgesWhereInput[]
    studentId?: StringFilter<"student_badges"> | string
    badgeId?: StringFilter<"student_badges"> | string
    awardedBy?: StringNullableFilter<"student_badges"> | string | null
    awardedAt?: DateTimeFilter<"student_badges"> | Date | string
    reason?: StringNullableFilter<"student_badges"> | string | null
    badges?: XOR<BadgesRelationFilter, badgesWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id">

  export type student_badgesOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    badgeId?: SortOrder
    awardedBy?: SortOrderInput | SortOrder
    awardedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: student_badgesCountOrderByAggregateInput
    _max?: student_badgesMaxOrderByAggregateInput
    _min?: student_badgesMinOrderByAggregateInput
  }

  export type student_badgesScalarWhereWithAggregatesInput = {
    AND?: student_badgesScalarWhereWithAggregatesInput | student_badgesScalarWhereWithAggregatesInput[]
    OR?: student_badgesScalarWhereWithAggregatesInput[]
    NOT?: student_badgesScalarWhereWithAggregatesInput | student_badgesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"student_badges"> | string
    studentId?: StringWithAggregatesFilter<"student_badges"> | string
    badgeId?: StringWithAggregatesFilter<"student_badges"> | string
    awardedBy?: StringNullableWithAggregatesFilter<"student_badges"> | string | null
    awardedAt?: DateTimeWithAggregatesFilter<"student_badges"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"student_badges"> | string | null
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    id?: StringFilter<"students"> | string
    schoolId?: StringFilter<"students"> | string
    name?: StringFilter<"students"> | string
    className?: StringNullableFilter<"students"> | string | null
    level?: IntFilter<"students"> | number
    points?: IntFilter<"students"> | number
    exp?: IntFilter<"students"> | number
    avatarUrl?: StringNullableFilter<"students"> | string | null
    isActive?: BoolFilter<"students"> | boolean
    createdAt?: DateTimeFilter<"students"> | Date | string
    updatedAt?: DateTimeFilter<"students"> | Date | string
    teamId?: StringNullableFilter<"students"> | string | null
    teacherId?: StringNullableFilter<"students"> | string | null
    currentLesson?: StringNullableFilter<"students"> | string | null
    currentLessonTitle?: StringNullableFilter<"students"> | string | null
    currentUnit?: StringNullableFilter<"students"> | string | null
    currentInviteCode?: StringNullableFilter<"students"> | string | null
    inviteCodeExpiresAt?: DateTimeNullableFilter<"students"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"students"> | Date | string | null
    grade?: StringNullableFilter<"students"> | string | null
    semester?: StringNullableFilter<"students"> | string | null
    currentProgress?: JsonNullableFilter<"students">
    campaigns?: CampaignsListRelationFilter
    challenge_participants?: Challenge_participantsListRelationFilter
    daily_summaries?: Daily_summariesListRelationFilter
    habit_logs?: Habit_logsListRelationFilter
    mistakes?: MistakesListRelationFilter
    parent_student_bindings?: Parent_student_bindingsListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    pk_matches_studentA?: Pk_matchesListRelationFilter
    pk_matches_studentB?: Pk_matchesListRelationFilter
    pk_matches_winner?: Pk_matchesListRelationFilter
    student_badges?: Student_badgesListRelationFilter
    student_checkins?: Student_checkinsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    teachers?: XOR<TeachersNullableRelationFilter, teachersWhereInput> | null
    task_records?: Task_recordsListRelationFilter
  }

  export type studentsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    className?: SortOrderInput | SortOrder
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    currentLesson?: SortOrderInput | SortOrder
    currentLessonTitle?: SortOrderInput | SortOrder
    currentUnit?: SortOrderInput | SortOrder
    currentInviteCode?: SortOrderInput | SortOrder
    inviteCodeExpiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    currentProgress?: SortOrderInput | SortOrder
    campaigns?: campaignsOrderByRelationAggregateInput
    challenge_participants?: challenge_participantsOrderByRelationAggregateInput
    daily_summaries?: daily_summariesOrderByRelationAggregateInput
    habit_logs?: habit_logsOrderByRelationAggregateInput
    mistakes?: mistakesOrderByRelationAggregateInput
    parent_student_bindings?: parent_student_bindingsOrderByRelationAggregateInput
    personalized_tutoring_plans?: personalized_tutoring_plansOrderByRelationAggregateInput
    pk_matches_studentA?: pk_matchesOrderByRelationAggregateInput
    pk_matches_studentB?: pk_matchesOrderByRelationAggregateInput
    pk_matches_winner?: pk_matchesOrderByRelationAggregateInput
    student_badges?: student_badgesOrderByRelationAggregateInput
    student_checkins?: student_checkinsOrderByRelationAggregateInput
    schools?: schoolsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
    task_records?: task_recordsOrderByRelationAggregateInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_name?: studentsSchoolIdNameCompoundUniqueInput
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    schoolId?: StringFilter<"students"> | string
    name?: StringFilter<"students"> | string
    className?: StringNullableFilter<"students"> | string | null
    level?: IntFilter<"students"> | number
    points?: IntFilter<"students"> | number
    exp?: IntFilter<"students"> | number
    avatarUrl?: StringNullableFilter<"students"> | string | null
    isActive?: BoolFilter<"students"> | boolean
    createdAt?: DateTimeFilter<"students"> | Date | string
    updatedAt?: DateTimeFilter<"students"> | Date | string
    teamId?: StringNullableFilter<"students"> | string | null
    teacherId?: StringNullableFilter<"students"> | string | null
    currentLesson?: StringNullableFilter<"students"> | string | null
    currentLessonTitle?: StringNullableFilter<"students"> | string | null
    currentUnit?: StringNullableFilter<"students"> | string | null
    currentInviteCode?: StringNullableFilter<"students"> | string | null
    inviteCodeExpiresAt?: DateTimeNullableFilter<"students"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"students"> | Date | string | null
    grade?: StringNullableFilter<"students"> | string | null
    semester?: StringNullableFilter<"students"> | string | null
    currentProgress?: JsonNullableFilter<"students">
    campaigns?: CampaignsListRelationFilter
    challenge_participants?: Challenge_participantsListRelationFilter
    daily_summaries?: Daily_summariesListRelationFilter
    habit_logs?: Habit_logsListRelationFilter
    mistakes?: MistakesListRelationFilter
    parent_student_bindings?: Parent_student_bindingsListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    pk_matches_studentA?: Pk_matchesListRelationFilter
    pk_matches_studentB?: Pk_matchesListRelationFilter
    pk_matches_winner?: Pk_matchesListRelationFilter
    student_badges?: Student_badgesListRelationFilter
    student_checkins?: Student_checkinsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    teachers?: XOR<TeachersNullableRelationFilter, teachersWhereInput> | null
    task_records?: Task_recordsListRelationFilter
  }, "id" | "schoolId_name">

  export type studentsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    className?: SortOrderInput | SortOrder
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    currentLesson?: SortOrderInput | SortOrder
    currentLessonTitle?: SortOrderInput | SortOrder
    currentUnit?: SortOrderInput | SortOrder
    currentInviteCode?: SortOrderInput | SortOrder
    inviteCodeExpiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    currentProgress?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _avg?: studentsAvgOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
    _sum?: studentsSumOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"students"> | string
    schoolId?: StringWithAggregatesFilter<"students"> | string
    name?: StringWithAggregatesFilter<"students"> | string
    className?: StringNullableWithAggregatesFilter<"students"> | string | null
    level?: IntWithAggregatesFilter<"students"> | number
    points?: IntWithAggregatesFilter<"students"> | number
    exp?: IntWithAggregatesFilter<"students"> | number
    avatarUrl?: StringNullableWithAggregatesFilter<"students"> | string | null
    isActive?: BoolWithAggregatesFilter<"students"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"students"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"students"> | Date | string
    teamId?: StringNullableWithAggregatesFilter<"students"> | string | null
    teacherId?: StringNullableWithAggregatesFilter<"students"> | string | null
    currentLesson?: StringNullableWithAggregatesFilter<"students"> | string | null
    currentLessonTitle?: StringNullableWithAggregatesFilter<"students"> | string | null
    currentUnit?: StringNullableWithAggregatesFilter<"students"> | string | null
    currentInviteCode?: StringNullableWithAggregatesFilter<"students"> | string | null
    inviteCodeExpiresAt?: DateTimeNullableWithAggregatesFilter<"students"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"students"> | Date | string | null
    grade?: StringNullableWithAggregatesFilter<"students"> | string | null
    semester?: StringNullableWithAggregatesFilter<"students"> | string | null
    currentProgress?: JsonNullableWithAggregatesFilter<"students">
  }

  export type student_checkinsWhereInput = {
    AND?: student_checkinsWhereInput | student_checkinsWhereInput[]
    OR?: student_checkinsWhereInput[]
    NOT?: student_checkinsWhereInput | student_checkinsWhereInput[]
    id?: StringFilter<"student_checkins"> | string
    studentId?: StringFilter<"student_checkins"> | string
    schoolId?: StringFilter<"student_checkins"> | string
    checkinDate?: StringFilter<"student_checkins"> | string
    checkedBy?: StringNullableFilter<"student_checkins"> | string | null
    createdAt?: DateTimeFilter<"student_checkins"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type student_checkinsOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    checkinDate?: SortOrder
    checkedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type student_checkinsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_checkinDate?: student_checkinsStudentIdCheckinDateCompoundUniqueInput
    AND?: student_checkinsWhereInput | student_checkinsWhereInput[]
    OR?: student_checkinsWhereInput[]
    NOT?: student_checkinsWhereInput | student_checkinsWhereInput[]
    studentId?: StringFilter<"student_checkins"> | string
    schoolId?: StringFilter<"student_checkins"> | string
    checkinDate?: StringFilter<"student_checkins"> | string
    checkedBy?: StringNullableFilter<"student_checkins"> | string | null
    createdAt?: DateTimeFilter<"student_checkins"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id" | "studentId_checkinDate">

  export type student_checkinsOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    checkinDate?: SortOrder
    checkedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: student_checkinsCountOrderByAggregateInput
    _max?: student_checkinsMaxOrderByAggregateInput
    _min?: student_checkinsMinOrderByAggregateInput
  }

  export type student_checkinsScalarWhereWithAggregatesInput = {
    AND?: student_checkinsScalarWhereWithAggregatesInput | student_checkinsScalarWhereWithAggregatesInput[]
    OR?: student_checkinsScalarWhereWithAggregatesInput[]
    NOT?: student_checkinsScalarWhereWithAggregatesInput | student_checkinsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"student_checkins"> | string
    studentId?: StringWithAggregatesFilter<"student_checkins"> | string
    schoolId?: StringWithAggregatesFilter<"student_checkins"> | string
    checkinDate?: StringWithAggregatesFilter<"student_checkins"> | string
    checkedBy?: StringNullableWithAggregatesFilter<"student_checkins"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"student_checkins"> | Date | string
  }

  export type task_libraryWhereInput = {
    AND?: task_libraryWhereInput | task_libraryWhereInput[]
    OR?: task_libraryWhereInput[]
    NOT?: task_libraryWhereInput | task_libraryWhereInput[]
    id?: StringFilter<"task_library"> | string
    category?: StringFilter<"task_library"> | string
    name?: StringFilter<"task_library"> | string
    description?: StringNullableFilter<"task_library"> | string | null
    defaultExp?: IntFilter<"task_library"> | number
    type?: EnumTaskTypeFilter<"task_library"> | $Enums.TaskType
    difficulty?: IntNullableFilter<"task_library"> | number | null
    isActive?: BoolFilter<"task_library"> | boolean
    createdAt?: DateTimeFilter<"task_library"> | Date | string
    updatedAt?: DateTimeFilter<"task_library"> | Date | string
    schoolId?: StringFilter<"task_library"> | string
    isGlobal?: BoolFilter<"task_library"> | boolean
    educationalDomain?: StringFilter<"task_library"> | string
    educationalSubcategory?: StringFilter<"task_library"> | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }

  export type task_libraryOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultExp?: SortOrder
    type?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    isGlobal?: SortOrder
    educationalDomain?: SortOrder
    educationalSubcategory?: SortOrder
    schools?: schoolsOrderByWithRelationInput
  }

  export type task_libraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_educationalDomain_educationalSubcategory_name?: task_librarySchoolIdEducationalDomainEducationalSubcategoryNameCompoundUniqueInput
    AND?: task_libraryWhereInput | task_libraryWhereInput[]
    OR?: task_libraryWhereInput[]
    NOT?: task_libraryWhereInput | task_libraryWhereInput[]
    category?: StringFilter<"task_library"> | string
    name?: StringFilter<"task_library"> | string
    description?: StringNullableFilter<"task_library"> | string | null
    defaultExp?: IntFilter<"task_library"> | number
    type?: EnumTaskTypeFilter<"task_library"> | $Enums.TaskType
    difficulty?: IntNullableFilter<"task_library"> | number | null
    isActive?: BoolFilter<"task_library"> | boolean
    createdAt?: DateTimeFilter<"task_library"> | Date | string
    updatedAt?: DateTimeFilter<"task_library"> | Date | string
    schoolId?: StringFilter<"task_library"> | string
    isGlobal?: BoolFilter<"task_library"> | boolean
    educationalDomain?: StringFilter<"task_library"> | string
    educationalSubcategory?: StringFilter<"task_library"> | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }, "id" | "schoolId_educationalDomain_educationalSubcategory_name">

  export type task_libraryOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultExp?: SortOrder
    type?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    isGlobal?: SortOrder
    educationalDomain?: SortOrder
    educationalSubcategory?: SortOrder
    _count?: task_libraryCountOrderByAggregateInput
    _avg?: task_libraryAvgOrderByAggregateInput
    _max?: task_libraryMaxOrderByAggregateInput
    _min?: task_libraryMinOrderByAggregateInput
    _sum?: task_librarySumOrderByAggregateInput
  }

  export type task_libraryScalarWhereWithAggregatesInput = {
    AND?: task_libraryScalarWhereWithAggregatesInput | task_libraryScalarWhereWithAggregatesInput[]
    OR?: task_libraryScalarWhereWithAggregatesInput[]
    NOT?: task_libraryScalarWhereWithAggregatesInput | task_libraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"task_library"> | string
    category?: StringWithAggregatesFilter<"task_library"> | string
    name?: StringWithAggregatesFilter<"task_library"> | string
    description?: StringNullableWithAggregatesFilter<"task_library"> | string | null
    defaultExp?: IntWithAggregatesFilter<"task_library"> | number
    type?: EnumTaskTypeWithAggregatesFilter<"task_library"> | $Enums.TaskType
    difficulty?: IntNullableWithAggregatesFilter<"task_library"> | number | null
    isActive?: BoolWithAggregatesFilter<"task_library"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"task_library"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"task_library"> | Date | string
    schoolId?: StringWithAggregatesFilter<"task_library"> | string
    isGlobal?: BoolWithAggregatesFilter<"task_library"> | boolean
    educationalDomain?: StringWithAggregatesFilter<"task_library"> | string
    educationalSubcategory?: StringWithAggregatesFilter<"task_library"> | string
  }

  export type task_recordsWhereInput = {
    AND?: task_recordsWhereInput | task_recordsWhereInput[]
    OR?: task_recordsWhereInput[]
    NOT?: task_recordsWhereInput | task_recordsWhereInput[]
    id?: StringFilter<"task_records"> | string
    schoolId?: StringFilter<"task_records"> | string
    studentId?: StringFilter<"task_records"> | string
    type?: EnumTaskTypeFilter<"task_records"> | $Enums.TaskType
    title?: StringFilter<"task_records"> | string
    content?: JsonNullableFilter<"task_records">
    status?: EnumTaskStatusFilter<"task_records"> | $Enums.TaskStatus
    expAwarded?: IntFilter<"task_records"> | number
    submittedAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
    createdAt?: DateTimeFilter<"task_records"> | Date | string
    updatedAt?: DateTimeFilter<"task_records"> | Date | string
    lessonPlanId?: StringNullableFilter<"task_records"> | string | null
    task_category?: EnumTaskCategoryFilter<"task_records"> | $Enums.TaskCategory
    is_current?: BoolFilter<"task_records"> | boolean
    attempts?: IntFilter<"task_records"> | number
    subject?: StringNullableFilter<"task_records"> | string | null
    isOverridden?: BoolFilter<"task_records"> | boolean
    settledAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
    lesson_plans?: XOR<Lesson_plansNullableRelationFilter, lesson_plansWhereInput> | null
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type task_recordsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    expAwarded?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessonPlanId?: SortOrderInput | SortOrder
    task_category?: SortOrder
    is_current?: SortOrder
    attempts?: SortOrder
    subject?: SortOrderInput | SortOrder
    isOverridden?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    lesson_plans?: lesson_plansOrderByWithRelationInput
    schools?: schoolsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type task_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: task_recordsWhereInput | task_recordsWhereInput[]
    OR?: task_recordsWhereInput[]
    NOT?: task_recordsWhereInput | task_recordsWhereInput[]
    schoolId?: StringFilter<"task_records"> | string
    studentId?: StringFilter<"task_records"> | string
    type?: EnumTaskTypeFilter<"task_records"> | $Enums.TaskType
    title?: StringFilter<"task_records"> | string
    content?: JsonNullableFilter<"task_records">
    status?: EnumTaskStatusFilter<"task_records"> | $Enums.TaskStatus
    expAwarded?: IntFilter<"task_records"> | number
    submittedAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
    createdAt?: DateTimeFilter<"task_records"> | Date | string
    updatedAt?: DateTimeFilter<"task_records"> | Date | string
    lessonPlanId?: StringNullableFilter<"task_records"> | string | null
    task_category?: EnumTaskCategoryFilter<"task_records"> | $Enums.TaskCategory
    is_current?: BoolFilter<"task_records"> | boolean
    attempts?: IntFilter<"task_records"> | number
    subject?: StringNullableFilter<"task_records"> | string | null
    isOverridden?: BoolFilter<"task_records"> | boolean
    settledAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
    lesson_plans?: XOR<Lesson_plansNullableRelationFilter, lesson_plansWhereInput> | null
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id">

  export type task_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    expAwarded?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessonPlanId?: SortOrderInput | SortOrder
    task_category?: SortOrder
    is_current?: SortOrder
    attempts?: SortOrder
    subject?: SortOrderInput | SortOrder
    isOverridden?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    _count?: task_recordsCountOrderByAggregateInput
    _avg?: task_recordsAvgOrderByAggregateInput
    _max?: task_recordsMaxOrderByAggregateInput
    _min?: task_recordsMinOrderByAggregateInput
    _sum?: task_recordsSumOrderByAggregateInput
  }

  export type task_recordsScalarWhereWithAggregatesInput = {
    AND?: task_recordsScalarWhereWithAggregatesInput | task_recordsScalarWhereWithAggregatesInput[]
    OR?: task_recordsScalarWhereWithAggregatesInput[]
    NOT?: task_recordsScalarWhereWithAggregatesInput | task_recordsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"task_records"> | string
    schoolId?: StringWithAggregatesFilter<"task_records"> | string
    studentId?: StringWithAggregatesFilter<"task_records"> | string
    type?: EnumTaskTypeWithAggregatesFilter<"task_records"> | $Enums.TaskType
    title?: StringWithAggregatesFilter<"task_records"> | string
    content?: JsonNullableWithAggregatesFilter<"task_records">
    status?: EnumTaskStatusWithAggregatesFilter<"task_records"> | $Enums.TaskStatus
    expAwarded?: IntWithAggregatesFilter<"task_records"> | number
    submittedAt?: DateTimeNullableWithAggregatesFilter<"task_records"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"task_records"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"task_records"> | Date | string
    lessonPlanId?: StringNullableWithAggregatesFilter<"task_records"> | string | null
    task_category?: EnumTaskCategoryWithAggregatesFilter<"task_records"> | $Enums.TaskCategory
    is_current?: BoolWithAggregatesFilter<"task_records"> | boolean
    attempts?: IntWithAggregatesFilter<"task_records"> | number
    subject?: StringNullableWithAggregatesFilter<"task_records"> | string | null
    isOverridden?: BoolWithAggregatesFilter<"task_records"> | boolean
    settledAt?: DateTimeNullableWithAggregatesFilter<"task_records"> | Date | string | null
  }

  export type teachersWhereInput = {
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    id?: StringFilter<"teachers"> | string
    schoolId?: StringNullableFilter<"teachers"> | string | null
    username?: StringFilter<"teachers"> | string
    password?: StringFilter<"teachers"> | string
    name?: StringFilter<"teachers"> | string
    email?: StringNullableFilter<"teachers"> | string | null
    role?: EnumRoleFilter<"teachers"> | $Enums.Role
    createdAt?: DateTimeFilter<"teachers"> | Date | string
    updatedAt?: DateTimeFilter<"teachers"> | Date | string
    displayName?: StringNullableFilter<"teachers"> | string | null
    primaryClassName?: StringNullableFilter<"teachers"> | string | null
    challenges?: ChallengesListRelationFilter
    lesson_plans?: Lesson_plansListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    students?: StudentsListRelationFilter
    schools?: XOR<SchoolsNullableRelationFilter, schoolsWhereInput> | null
  }

  export type teachersOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrderInput | SortOrder
    primaryClassName?: SortOrderInput | SortOrder
    challenges?: challengesOrderByRelationAggregateInput
    lesson_plans?: lesson_plansOrderByRelationAggregateInput
    personalized_tutoring_plans?: personalized_tutoring_plansOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
    schools?: schoolsOrderByWithRelationInput
  }

  export type teachersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    schoolId?: StringNullableFilter<"teachers"> | string | null
    password?: StringFilter<"teachers"> | string
    name?: StringFilter<"teachers"> | string
    role?: EnumRoleFilter<"teachers"> | $Enums.Role
    createdAt?: DateTimeFilter<"teachers"> | Date | string
    updatedAt?: DateTimeFilter<"teachers"> | Date | string
    displayName?: StringNullableFilter<"teachers"> | string | null
    primaryClassName?: StringNullableFilter<"teachers"> | string | null
    challenges?: ChallengesListRelationFilter
    lesson_plans?: Lesson_plansListRelationFilter
    personalized_tutoring_plans?: Personalized_tutoring_plansListRelationFilter
    students?: StudentsListRelationFilter
    schools?: XOR<SchoolsNullableRelationFilter, schoolsWhereInput> | null
  }, "id" | "username" | "email">

  export type teachersOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrderInput | SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrderInput | SortOrder
    primaryClassName?: SortOrderInput | SortOrder
    _count?: teachersCountOrderByAggregateInput
    _max?: teachersMaxOrderByAggregateInput
    _min?: teachersMinOrderByAggregateInput
  }

  export type teachersScalarWhereWithAggregatesInput = {
    AND?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    OR?: teachersScalarWhereWithAggregatesInput[]
    NOT?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"teachers"> | string
    schoolId?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    username?: StringWithAggregatesFilter<"teachers"> | string
    password?: StringWithAggregatesFilter<"teachers"> | string
    name?: StringWithAggregatesFilter<"teachers"> | string
    email?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    role?: EnumRoleWithAggregatesFilter<"teachers"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"teachers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"teachers"> | Date | string
    displayName?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    primaryClassName?: StringNullableWithAggregatesFilter<"teachers"> | string | null
  }

  export type personalized_tutoring_plansWhereInput = {
    AND?: personalized_tutoring_plansWhereInput | personalized_tutoring_plansWhereInput[]
    OR?: personalized_tutoring_plansWhereInput[]
    NOT?: personalized_tutoring_plansWhereInput | personalized_tutoring_plansWhereInput[]
    id?: StringFilter<"personalized_tutoring_plans"> | string
    teacherId?: StringFilter<"personalized_tutoring_plans"> | string
    schoolId?: StringFilter<"personalized_tutoring_plans"> | string
    title?: StringFilter<"personalized_tutoring_plans"> | string
    subject?: StringFilter<"personalized_tutoring_plans"> | string
    difficulty?: IntFilter<"personalized_tutoring_plans"> | number
    scheduledDate?: StringFilter<"personalized_tutoring_plans"> | string
    scheduledTime?: StringFilter<"personalized_tutoring_plans"> | string
    duration?: IntFilter<"personalized_tutoring_plans"> | number
    actualStartTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    studentId?: StringFilter<"personalized_tutoring_plans"> | string
    studentName?: StringFilter<"personalized_tutoring_plans"> | string
    studentClass?: StringFilter<"personalized_tutoring_plans"> | string
    knowledgePoints?: JsonFilter<"personalized_tutoring_plans">
    mainProblem?: StringFilter<"personalized_tutoring_plans"> | string
    detailedContent?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    teachingObjectives?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    preparationMaterials?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    tutoringMethods?: JsonFilter<"personalized_tutoring_plans">
    expReward?: IntFilter<"personalized_tutoring_plans"> | number
    pointsReward?: IntFilter<"personalized_tutoring_plans"> | number
    expAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    pointsAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    status?: StringFilter<"personalized_tutoring_plans"> | string
    completionNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    studentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    parentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    effectivenessRating?: IntNullableFilter<"personalized_tutoring_plans"> | number | null
    followUpRequired?: BoolFilter<"personalized_tutoring_plans"> | boolean
    followUpDate?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    followUpNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    attachments?: JsonNullableFilter<"personalized_tutoring_plans">
    totalSessions?: IntFilter<"personalized_tutoring_plans"> | number
    completedSessions?: IntFilter<"personalized_tutoring_plans"> | number
    createdAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
    updatedAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
  }

  export type personalized_tutoring_plansOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    duration?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    studentClass?: SortOrder
    knowledgePoints?: SortOrder
    mainProblem?: SortOrder
    detailedContent?: SortOrderInput | SortOrder
    teachingObjectives?: SortOrderInput | SortOrder
    preparationMaterials?: SortOrderInput | SortOrder
    tutoringMethods?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    expAwarded?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    completionNotes?: SortOrderInput | SortOrder
    studentFeedback?: SortOrderInput | SortOrder
    parentFeedback?: SortOrderInput | SortOrder
    effectivenessRating?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schools?: schoolsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
  }

  export type personalized_tutoring_plansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: personalized_tutoring_plansWhereInput | personalized_tutoring_plansWhereInput[]
    OR?: personalized_tutoring_plansWhereInput[]
    NOT?: personalized_tutoring_plansWhereInput | personalized_tutoring_plansWhereInput[]
    teacherId?: StringFilter<"personalized_tutoring_plans"> | string
    schoolId?: StringFilter<"personalized_tutoring_plans"> | string
    title?: StringFilter<"personalized_tutoring_plans"> | string
    subject?: StringFilter<"personalized_tutoring_plans"> | string
    difficulty?: IntFilter<"personalized_tutoring_plans"> | number
    scheduledDate?: StringFilter<"personalized_tutoring_plans"> | string
    scheduledTime?: StringFilter<"personalized_tutoring_plans"> | string
    duration?: IntFilter<"personalized_tutoring_plans"> | number
    actualStartTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    studentId?: StringFilter<"personalized_tutoring_plans"> | string
    studentName?: StringFilter<"personalized_tutoring_plans"> | string
    studentClass?: StringFilter<"personalized_tutoring_plans"> | string
    knowledgePoints?: JsonFilter<"personalized_tutoring_plans">
    mainProblem?: StringFilter<"personalized_tutoring_plans"> | string
    detailedContent?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    teachingObjectives?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    preparationMaterials?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    tutoringMethods?: JsonFilter<"personalized_tutoring_plans">
    expReward?: IntFilter<"personalized_tutoring_plans"> | number
    pointsReward?: IntFilter<"personalized_tutoring_plans"> | number
    expAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    pointsAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    status?: StringFilter<"personalized_tutoring_plans"> | string
    completionNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    studentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    parentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    effectivenessRating?: IntNullableFilter<"personalized_tutoring_plans"> | number | null
    followUpRequired?: BoolFilter<"personalized_tutoring_plans"> | boolean
    followUpDate?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    followUpNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    attachments?: JsonNullableFilter<"personalized_tutoring_plans">
    totalSessions?: IntFilter<"personalized_tutoring_plans"> | number
    completedSessions?: IntFilter<"personalized_tutoring_plans"> | number
    createdAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
    updatedAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
    teachers?: XOR<TeachersRelationFilter, teachersWhereInput>
  }, "id">

  export type personalized_tutoring_plansOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    duration?: SortOrder
    actualStartTime?: SortOrderInput | SortOrder
    actualEndTime?: SortOrderInput | SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    studentClass?: SortOrder
    knowledgePoints?: SortOrder
    mainProblem?: SortOrder
    detailedContent?: SortOrderInput | SortOrder
    teachingObjectives?: SortOrderInput | SortOrder
    preparationMaterials?: SortOrderInput | SortOrder
    tutoringMethods?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    expAwarded?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    completionNotes?: SortOrderInput | SortOrder
    studentFeedback?: SortOrderInput | SortOrder
    parentFeedback?: SortOrderInput | SortOrder
    effectivenessRating?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: personalized_tutoring_plansCountOrderByAggregateInput
    _avg?: personalized_tutoring_plansAvgOrderByAggregateInput
    _max?: personalized_tutoring_plansMaxOrderByAggregateInput
    _min?: personalized_tutoring_plansMinOrderByAggregateInput
    _sum?: personalized_tutoring_plansSumOrderByAggregateInput
  }

  export type personalized_tutoring_plansScalarWhereWithAggregatesInput = {
    AND?: personalized_tutoring_plansScalarWhereWithAggregatesInput | personalized_tutoring_plansScalarWhereWithAggregatesInput[]
    OR?: personalized_tutoring_plansScalarWhereWithAggregatesInput[]
    NOT?: personalized_tutoring_plansScalarWhereWithAggregatesInput | personalized_tutoring_plansScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    teacherId?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    schoolId?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    title?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    subject?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    difficulty?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    scheduledDate?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    scheduledTime?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    duration?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    actualStartTime?: DateTimeNullableWithAggregatesFilter<"personalized_tutoring_plans"> | Date | string | null
    actualEndTime?: DateTimeNullableWithAggregatesFilter<"personalized_tutoring_plans"> | Date | string | null
    studentId?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    studentName?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    studentClass?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    knowledgePoints?: JsonWithAggregatesFilter<"personalized_tutoring_plans">
    mainProblem?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    detailedContent?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    teachingObjectives?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    preparationMaterials?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    tutoringMethods?: JsonWithAggregatesFilter<"personalized_tutoring_plans">
    expReward?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    pointsReward?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    expAwarded?: BoolWithAggregatesFilter<"personalized_tutoring_plans"> | boolean
    pointsAwarded?: BoolWithAggregatesFilter<"personalized_tutoring_plans"> | boolean
    status?: StringWithAggregatesFilter<"personalized_tutoring_plans"> | string
    completionNotes?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    studentFeedback?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    parentFeedback?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    effectivenessRating?: IntNullableWithAggregatesFilter<"personalized_tutoring_plans"> | number | null
    followUpRequired?: BoolWithAggregatesFilter<"personalized_tutoring_plans"> | boolean
    followUpDate?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    followUpNotes?: StringNullableWithAggregatesFilter<"personalized_tutoring_plans"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"personalized_tutoring_plans">
    totalSessions?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    completedSessions?: IntWithAggregatesFilter<"personalized_tutoring_plans"> | number
    createdAt?: DateTimeWithAggregatesFilter<"personalized_tutoring_plans"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"personalized_tutoring_plans"> | Date | string
  }

  export type parentsWhereInput = {
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    id?: StringFilter<"parents"> | string
    schoolId?: StringFilter<"parents"> | string
    phone?: StringFilter<"parents"> | string
    password?: StringFilter<"parents"> | string
    name?: StringNullableFilter<"parents"> | string | null
    identity?: StringNullableFilter<"parents"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"parents"> | Date | string | null
    isActive?: BoolFilter<"parents"> | boolean
    createdAt?: DateTimeFilter<"parents"> | Date | string
    updatedAt?: DateTimeFilter<"parents"> | Date | string
    daily_summaries?: Daily_summariesListRelationFilter
    parent_student_bindings?: Parent_student_bindingsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }

  export type parentsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    identity?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    daily_summaries?: daily_summariesOrderByRelationAggregateInput
    parent_student_bindings?: parent_student_bindingsOrderByRelationAggregateInput
    schools?: schoolsOrderByWithRelationInput
  }

  export type parentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_phone?: parentsSchoolIdPhoneCompoundUniqueInput
    AND?: parentsWhereInput | parentsWhereInput[]
    OR?: parentsWhereInput[]
    NOT?: parentsWhereInput | parentsWhereInput[]
    schoolId?: StringFilter<"parents"> | string
    phone?: StringFilter<"parents"> | string
    password?: StringFilter<"parents"> | string
    name?: StringNullableFilter<"parents"> | string | null
    identity?: StringNullableFilter<"parents"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"parents"> | Date | string | null
    isActive?: BoolFilter<"parents"> | boolean
    createdAt?: DateTimeFilter<"parents"> | Date | string
    updatedAt?: DateTimeFilter<"parents"> | Date | string
    daily_summaries?: Daily_summariesListRelationFilter
    parent_student_bindings?: Parent_student_bindingsListRelationFilter
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }, "id" | "schoolId_phone">

  export type parentsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    identity?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: parentsCountOrderByAggregateInput
    _max?: parentsMaxOrderByAggregateInput
    _min?: parentsMinOrderByAggregateInput
  }

  export type parentsScalarWhereWithAggregatesInput = {
    AND?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    OR?: parentsScalarWhereWithAggregatesInput[]
    NOT?: parentsScalarWhereWithAggregatesInput | parentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"parents"> | string
    schoolId?: StringWithAggregatesFilter<"parents"> | string
    phone?: StringWithAggregatesFilter<"parents"> | string
    password?: StringWithAggregatesFilter<"parents"> | string
    name?: StringNullableWithAggregatesFilter<"parents"> | string | null
    identity?: StringNullableWithAggregatesFilter<"parents"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"parents"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"parents"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"parents"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"parents"> | Date | string
  }

  export type parent_student_bindingsWhereInput = {
    AND?: parent_student_bindingsWhereInput | parent_student_bindingsWhereInput[]
    OR?: parent_student_bindingsWhereInput[]
    NOT?: parent_student_bindingsWhereInput | parent_student_bindingsWhereInput[]
    id?: StringFilter<"parent_student_bindings"> | string
    parentId?: StringFilter<"parent_student_bindings"> | string
    studentId?: StringFilter<"parent_student_bindings"> | string
    inviteCode?: StringFilter<"parent_student_bindings"> | string
    bindingTime?: DateTimeFilter<"parent_student_bindings"> | Date | string
    isActive?: BoolFilter<"parent_student_bindings"> | boolean
    parents?: XOR<ParentsRelationFilter, parentsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type parent_student_bindingsOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    inviteCode?: SortOrder
    bindingTime?: SortOrder
    isActive?: SortOrder
    parents?: parentsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type parent_student_bindingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parentId_studentId?: parent_student_bindingsParentIdStudentIdCompoundUniqueInput
    AND?: parent_student_bindingsWhereInput | parent_student_bindingsWhereInput[]
    OR?: parent_student_bindingsWhereInput[]
    NOT?: parent_student_bindingsWhereInput | parent_student_bindingsWhereInput[]
    parentId?: StringFilter<"parent_student_bindings"> | string
    studentId?: StringFilter<"parent_student_bindings"> | string
    inviteCode?: StringFilter<"parent_student_bindings"> | string
    bindingTime?: DateTimeFilter<"parent_student_bindings"> | Date | string
    isActive?: BoolFilter<"parent_student_bindings"> | boolean
    parents?: XOR<ParentsRelationFilter, parentsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id" | "parentId_studentId">

  export type parent_student_bindingsOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    inviteCode?: SortOrder
    bindingTime?: SortOrder
    isActive?: SortOrder
    _count?: parent_student_bindingsCountOrderByAggregateInput
    _max?: parent_student_bindingsMaxOrderByAggregateInput
    _min?: parent_student_bindingsMinOrderByAggregateInput
  }

  export type parent_student_bindingsScalarWhereWithAggregatesInput = {
    AND?: parent_student_bindingsScalarWhereWithAggregatesInput | parent_student_bindingsScalarWhereWithAggregatesInput[]
    OR?: parent_student_bindingsScalarWhereWithAggregatesInput[]
    NOT?: parent_student_bindingsScalarWhereWithAggregatesInput | parent_student_bindingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"parent_student_bindings"> | string
    parentId?: StringWithAggregatesFilter<"parent_student_bindings"> | string
    studentId?: StringWithAggregatesFilter<"parent_student_bindings"> | string
    inviteCode?: StringWithAggregatesFilter<"parent_student_bindings"> | string
    bindingTime?: DateTimeWithAggregatesFilter<"parent_student_bindings"> | Date | string
    isActive?: BoolWithAggregatesFilter<"parent_student_bindings"> | boolean
  }

  export type daily_summariesWhereInput = {
    AND?: daily_summariesWhereInput | daily_summariesWhereInput[]
    OR?: daily_summariesWhereInput[]
    NOT?: daily_summariesWhereInput | daily_summariesWhereInput[]
    id?: StringFilter<"daily_summaries"> | string
    studentId?: StringFilter<"daily_summaries"> | string
    parentId?: StringFilter<"daily_summaries"> | string
    date?: StringFilter<"daily_summaries"> | string
    parentLiked?: BoolFilter<"daily_summaries"> | boolean
    parentComment?: StringNullableFilter<"daily_summaries"> | string | null
    teacherRead?: BoolFilter<"daily_summaries"> | boolean
    createdAt?: DateTimeFilter<"daily_summaries"> | Date | string
    updatedAt?: DateTimeFilter<"daily_summaries"> | Date | string
    parents?: XOR<ParentsRelationFilter, parentsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type daily_summariesOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    parentLiked?: SortOrder
    parentComment?: SortOrderInput | SortOrder
    teacherRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parents?: parentsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type daily_summariesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_parentId_date?: daily_summariesStudentIdParentIdDateCompoundUniqueInput
    AND?: daily_summariesWhereInput | daily_summariesWhereInput[]
    OR?: daily_summariesWhereInput[]
    NOT?: daily_summariesWhereInput | daily_summariesWhereInput[]
    studentId?: StringFilter<"daily_summaries"> | string
    parentId?: StringFilter<"daily_summaries"> | string
    date?: StringFilter<"daily_summaries"> | string
    parentLiked?: BoolFilter<"daily_summaries"> | boolean
    parentComment?: StringNullableFilter<"daily_summaries"> | string | null
    teacherRead?: BoolFilter<"daily_summaries"> | boolean
    createdAt?: DateTimeFilter<"daily_summaries"> | Date | string
    updatedAt?: DateTimeFilter<"daily_summaries"> | Date | string
    parents?: XOR<ParentsRelationFilter, parentsWhereInput>
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id" | "studentId_parentId_date">

  export type daily_summariesOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    parentLiked?: SortOrder
    parentComment?: SortOrderInput | SortOrder
    teacherRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: daily_summariesCountOrderByAggregateInput
    _max?: daily_summariesMaxOrderByAggregateInput
    _min?: daily_summariesMinOrderByAggregateInput
  }

  export type daily_summariesScalarWhereWithAggregatesInput = {
    AND?: daily_summariesScalarWhereWithAggregatesInput | daily_summariesScalarWhereWithAggregatesInput[]
    OR?: daily_summariesScalarWhereWithAggregatesInput[]
    NOT?: daily_summariesScalarWhereWithAggregatesInput | daily_summariesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"daily_summaries"> | string
    studentId?: StringWithAggregatesFilter<"daily_summaries"> | string
    parentId?: StringWithAggregatesFilter<"daily_summaries"> | string
    date?: StringWithAggregatesFilter<"daily_summaries"> | string
    parentLiked?: BoolWithAggregatesFilter<"daily_summaries"> | boolean
    parentComment?: StringNullableWithAggregatesFilter<"daily_summaries"> | string | null
    teacherRead?: BoolWithAggregatesFilter<"daily_summaries"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"daily_summaries"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"daily_summaries"> | Date | string
  }

  export type campaignsWhereInput = {
    AND?: campaignsWhereInput | campaignsWhereInput[]
    OR?: campaignsWhereInput[]
    NOT?: campaignsWhereInput | campaignsWhereInput[]
    id?: StringFilter<"campaigns"> | string
    studentId?: StringFilter<"campaigns"> | string
    type?: StringFilter<"campaigns"> | string
    status?: StringFilter<"campaigns"> | string
    metadata?: JsonNullableFilter<"campaigns">
    createdAt?: DateTimeFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeFilter<"campaigns"> | Date | string
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }

  export type campaignsOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type campaignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: campaignsWhereInput | campaignsWhereInput[]
    OR?: campaignsWhereInput[]
    NOT?: campaignsWhereInput | campaignsWhereInput[]
    studentId?: StringFilter<"campaigns"> | string
    type?: StringFilter<"campaigns"> | string
    status?: StringFilter<"campaigns"> | string
    metadata?: JsonNullableFilter<"campaigns">
    createdAt?: DateTimeFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeFilter<"campaigns"> | Date | string
    students?: XOR<StudentsRelationFilter, studentsWhereInput>
  }, "id">

  export type campaignsOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: campaignsCountOrderByAggregateInput
    _max?: campaignsMaxOrderByAggregateInput
    _min?: campaignsMinOrderByAggregateInput
  }

  export type campaignsScalarWhereWithAggregatesInput = {
    AND?: campaignsScalarWhereWithAggregatesInput | campaignsScalarWhereWithAggregatesInput[]
    OR?: campaignsScalarWhereWithAggregatesInput[]
    NOT?: campaignsScalarWhereWithAggregatesInput | campaignsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"campaigns"> | string
    studentId?: StringWithAggregatesFilter<"campaigns"> | string
    type?: StringWithAggregatesFilter<"campaigns"> | string
    status?: StringWithAggregatesFilter<"campaigns"> | string
    metadata?: JsonNullableWithAggregatesFilter<"campaigns">
    createdAt?: DateTimeWithAggregatesFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"campaigns"> | Date | string
  }

  export type reward_configsWhereInput = {
    AND?: reward_configsWhereInput | reward_configsWhereInput[]
    OR?: reward_configsWhereInput[]
    NOT?: reward_configsWhereInput | reward_configsWhereInput[]
    id?: StringFilter<"reward_configs"> | string
    schoolId?: StringFilter<"reward_configs"> | string
    module?: StringFilter<"reward_configs"> | string
    category?: StringNullableFilter<"reward_configs"> | string | null
    action?: StringFilter<"reward_configs"> | string
    expReward?: IntFilter<"reward_configs"> | number
    pointsReward?: IntFilter<"reward_configs"> | number
    description?: StringNullableFilter<"reward_configs"> | string | null
    isActive?: BoolFilter<"reward_configs"> | boolean
    createdAt?: DateTimeFilter<"reward_configs"> | Date | string
    updatedAt?: DateTimeFilter<"reward_configs"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }

  export type reward_configsOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    module?: SortOrder
    category?: SortOrderInput | SortOrder
    action?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schools?: schoolsOrderByWithRelationInput
  }

  export type reward_configsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId_module_action?: reward_configsSchoolIdModuleActionCompoundUniqueInput
    AND?: reward_configsWhereInput | reward_configsWhereInput[]
    OR?: reward_configsWhereInput[]
    NOT?: reward_configsWhereInput | reward_configsWhereInput[]
    schoolId?: StringFilter<"reward_configs"> | string
    module?: StringFilter<"reward_configs"> | string
    category?: StringNullableFilter<"reward_configs"> | string | null
    action?: StringFilter<"reward_configs"> | string
    expReward?: IntFilter<"reward_configs"> | number
    pointsReward?: IntFilter<"reward_configs"> | number
    description?: StringNullableFilter<"reward_configs"> | string | null
    isActive?: BoolFilter<"reward_configs"> | boolean
    createdAt?: DateTimeFilter<"reward_configs"> | Date | string
    updatedAt?: DateTimeFilter<"reward_configs"> | Date | string
    schools?: XOR<SchoolsRelationFilter, schoolsWhereInput>
  }, "id" | "schoolId_module_action">

  export type reward_configsOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    module?: SortOrder
    category?: SortOrderInput | SortOrder
    action?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: reward_configsCountOrderByAggregateInput
    _avg?: reward_configsAvgOrderByAggregateInput
    _max?: reward_configsMaxOrderByAggregateInput
    _min?: reward_configsMinOrderByAggregateInput
    _sum?: reward_configsSumOrderByAggregateInput
  }

  export type reward_configsScalarWhereWithAggregatesInput = {
    AND?: reward_configsScalarWhereWithAggregatesInput | reward_configsScalarWhereWithAggregatesInput[]
    OR?: reward_configsScalarWhereWithAggregatesInput[]
    NOT?: reward_configsScalarWhereWithAggregatesInput | reward_configsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reward_configs"> | string
    schoolId?: StringWithAggregatesFilter<"reward_configs"> | string
    module?: StringWithAggregatesFilter<"reward_configs"> | string
    category?: StringNullableWithAggregatesFilter<"reward_configs"> | string | null
    action?: StringWithAggregatesFilter<"reward_configs"> | string
    expReward?: IntWithAggregatesFilter<"reward_configs"> | number
    pointsReward?: IntWithAggregatesFilter<"reward_configs"> | number
    description?: StringNullableWithAggregatesFilter<"reward_configs"> | string | null
    isActive?: BoolWithAggregatesFilter<"reward_configs"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"reward_configs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"reward_configs"> | Date | string
  }

  export type badgesCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutBadgesInput
    student_badges?: student_badgesCreateNestedManyWithoutBadgesInput
  }

  export type badgesUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutBadgesInput
  }

  export type badgesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutBadgesNestedInput
    student_badges?: student_badgesUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student_badges?: student_badgesUncheckedUpdateManyWithoutBadgesNestedInput
  }

  export type badgesCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type badgesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type badgesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type challenge_participantsCreateInput = {
    id?: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
    challenges: challengesCreateNestedOneWithoutChallenge_participantsInput
    students: studentsCreateNestedOneWithoutChallenge_participantsInput
  }

  export type challenge_participantsUncheckedCreateInput = {
    id?: string
    challengeId: string
    studentId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type challenge_participantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenges?: challengesUpdateOneRequiredWithoutChallenge_participantsNestedInput
    students?: studentsUpdateOneRequiredWithoutChallenge_participantsNestedInput
  }

  export type challenge_participantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challenge_participantsCreateManyInput = {
    id?: string
    challengeId: string
    studentId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type challenge_participantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challenge_participantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challengesCreateInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsCreateNestedManyWithoutChallengesInput
    teachers: teachersCreateNestedOneWithoutChallengesInput
    schools: schoolsCreateNestedOneWithoutChallengesInput
  }

  export type challengesUncheckedCreateInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    creatorId: string
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutChallengesInput
  }

  export type challengesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUpdateManyWithoutChallengesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutChallengesNestedInput
    schools?: schoolsUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutChallengesNestedInput
  }

  export type challengesCreateManyInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    creatorId: string
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type challengesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type challengesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type habit_logsCreateInput = {
    id?: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
    habits: habitsCreateNestedOneWithoutHabit_logsInput
    schools: schoolsCreateNestedOneWithoutHabit_logsInput
    students: studentsCreateNestedOneWithoutHabit_logsInput
  }

  export type habit_logsUncheckedCreateInput = {
    id?: string
    schoolId: string
    habitId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    habits?: habitsUpdateOneRequiredWithoutHabit_logsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutHabit_logsNestedInput
    students?: studentsUpdateOneRequiredWithoutHabit_logsNestedInput
  }

  export type habit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habit_logsCreateManyInput = {
    id?: string
    schoolId: string
    habitId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habitsCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    habit_logs?: habit_logsCreateNestedManyWithoutHabitsInput
    schools: schoolsCreateNestedOneWithoutHabitsInput
  }

  export type habitsUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutHabitsInput
  }

  export type habitsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit_logs?: habit_logsUpdateManyWithoutHabitsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutHabitsNestedInput
  }

  export type habitsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit_logs?: habit_logsUncheckedUpdateManyWithoutHabitsNestedInput
  }

  export type habitsCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type habitsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type habitsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lesson_plansCreateInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    schools: schoolsCreateNestedOneWithoutLesson_plansInput
    teachers: teachersCreateNestedOneWithoutLesson_plansInput
    task_records?: task_recordsCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansUncheckedCreateInput = {
    id?: string
    schoolId: string
    teacherId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    task_records?: task_recordsUncheckedCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    schools?: schoolsUpdateOneRequiredWithoutLesson_plansNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLesson_plansNestedInput
    task_records?: task_recordsUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    task_records?: task_recordsUncheckedUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansCreateManyInput = {
    id?: string
    schoolId: string
    teacherId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
  }

  export type lesson_plansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type lesson_plansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type mistakesCreateInput = {
    id?: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
    schools: schoolsCreateNestedOneWithoutMistakesInput
    students: studentsCreateNestedOneWithoutMistakesInput
  }

  export type mistakesUncheckedCreateInput = {
    id?: string
    schoolId: string
    studentId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type mistakesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
    schools?: schoolsUpdateOneRequiredWithoutMistakesNestedInput
    students?: studentsUpdateOneRequiredWithoutMistakesNestedInput
  }

  export type mistakesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type mistakesCreateManyInput = {
    id?: string
    schoolId: string
    studentId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type mistakesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type mistakesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type pk_matchesCreateInput = {
    id?: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPk_matchesInput
    playerA: studentsCreateNestedOneWithoutPk_matches_studentAInput
    playerB: studentsCreateNestedOneWithoutPk_matches_studentBInput
    winner?: studentsCreateNestedOneWithoutPk_matches_winnerInput
  }

  export type pk_matchesUncheckedCreateInput = {
    id?: string
    schoolId: string
    studentA: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPk_matchesNestedInput
    playerA?: studentsUpdateOneRequiredWithoutPk_matches_studentANestedInput
    playerB?: studentsUpdateOneRequiredWithoutPk_matches_studentBNestedInput
    winner?: studentsUpdateOneWithoutPk_matches_winnerNestedInput
  }

  export type pk_matchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesCreateManyInput = {
    id?: string
    schoolId: string
    studentA: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
  }

  export type schoolsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type schoolsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_badgesCreateInput = {
    id?: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
    badges: badgesCreateNestedOneWithoutStudent_badgesInput
    students: studentsCreateNestedOneWithoutStudent_badgesInput
  }

  export type student_badgesUncheckedCreateInput = {
    id?: string
    studentId: string
    badgeId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_badgesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: badgesUpdateOneRequiredWithoutStudent_badgesNestedInput
    students?: studentsUpdateOneRequiredWithoutStudent_badgesNestedInput
  }

  export type student_badgesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_badgesCreateManyInput = {
    id?: string
    studentId: string
    badgeId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_badgesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_badgesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type studentsCreateInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type studentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type studentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type student_checkinsCreateInput = {
    id?: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
    schools: schoolsCreateNestedOneWithoutStudent_checkinsInput
    students: studentsCreateNestedOneWithoutStudent_checkinsInput
  }

  export type student_checkinsUncheckedCreateInput = {
    id?: string
    studentId: string
    schoolId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type student_checkinsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutStudent_checkinsNestedInput
    students?: studentsUpdateOneRequiredWithoutStudent_checkinsNestedInput
  }

  export type student_checkinsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_checkinsCreateManyInput = {
    id?: string
    studentId: string
    schoolId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type student_checkinsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_checkinsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type task_libraryCreateInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
    schools: schoolsCreateNestedOneWithoutTask_libraryInput
  }

  export type task_libraryUncheckedCreateInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
  }

  export type task_libraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
    schools?: schoolsUpdateOneRequiredWithoutTask_libraryNestedInput
  }

  export type task_libraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_libraryCreateManyInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolId: string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
  }

  export type task_libraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_libraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_recordsCreateInput = {
    id?: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
    lesson_plans?: lesson_plansCreateNestedOneWithoutTask_recordsInput
    schools: schoolsCreateNestedOneWithoutTask_recordsInput
    students: studentsCreateNestedOneWithoutTask_recordsInput
  }

  export type task_recordsUncheckedCreateInput = {
    id?: string
    schoolId: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson_plans?: lesson_plansUpdateOneWithoutTask_recordsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutTask_recordsNestedInput
    students?: studentsUpdateOneRequiredWithoutTask_recordsNestedInput
  }

  export type task_recordsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type task_recordsCreateManyInput = {
    id?: string
    schoolId: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type task_recordsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teachersCreateInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutTeachersInput
    students?: studentsCreateNestedManyWithoutTeachersInput
    schools?: schoolsCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput
    students?: studentsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput
    students?: studentsUpdateManyWithoutTeachersNestedInput
    schools?: schoolsUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUncheckedUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput
    students?: studentsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersCreateManyInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
  }

  export type teachersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teachersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type personalized_tutoring_plansCreateInput = {
    id?: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPersonalized_tutoring_plansInput
    students: studentsCreateNestedOneWithoutPersonalized_tutoring_plansInput
    teachers: teachersCreateNestedOneWithoutPersonalized_tutoring_plansInput
  }

  export type personalized_tutoring_plansUncheckedCreateInput = {
    id?: string
    teacherId: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
    students?: studentsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
    teachers?: teachersUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
  }

  export type personalized_tutoring_plansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansCreateManyInput = {
    id?: string
    teacherId: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parentsCreateInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesCreateNestedManyWithoutParentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutParentsInput
    schools: schoolsCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateInput = {
    id?: string
    schoolId: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutParentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUpdateManyWithoutParentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutParentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutParentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsCreateManyInput = {
    id?: string
    schoolId: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type parentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parent_student_bindingsCreateInput = {
    id?: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
    parents: parentsCreateNestedOneWithoutParent_student_bindingsInput
    students: studentsCreateNestedOneWithoutParent_student_bindingsInput
  }

  export type parent_student_bindingsUncheckedCreateInput = {
    id?: string
    parentId: string
    studentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type parent_student_bindingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parents?: parentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput
    students?: studentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput
  }

  export type parent_student_bindingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type parent_student_bindingsCreateManyInput = {
    id?: string
    parentId: string
    studentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type parent_student_bindingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type parent_student_bindingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type daily_summariesCreateInput = {
    id?: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parents: parentsCreateNestedOneWithoutDaily_summariesInput
    students: studentsCreateNestedOneWithoutDaily_summariesInput
  }

  export type daily_summariesUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type daily_summariesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: parentsUpdateOneRequiredWithoutDaily_summariesNestedInput
    students?: studentsUpdateOneRequiredWithoutDaily_summariesNestedInput
  }

  export type daily_summariesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type daily_summariesCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type daily_summariesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type daily_summariesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignsCreateInput = {
    id?: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    students: studentsCreateNestedOneWithoutCampaignsInput
  }

  export type campaignsUncheckedCreateInput = {
    id?: string
    studentId: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type campaignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type campaignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignsCreateManyInput = {
    id?: string
    studentId: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type campaignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsCreateInput = {
    id?: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutReward_configsInput
  }

  export type reward_configsUncheckedCreateInput = {
    id?: string
    schoolId: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reward_configsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutReward_configsNestedInput
  }

  export type reward_configsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsCreateManyInput = {
    id?: string
    schoolId: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reward_configsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SchoolsRelationFilter = {
    is?: schoolsWhereInput
    isNot?: schoolsWhereInput
  }

  export type Student_badgesListRelationFilter = {
    every?: student_badgesWhereInput
    some?: student_badgesWhereInput
    none?: student_badgesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type student_badgesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type badgesSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type badgesCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    requirement?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgesMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type badgesMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusFilter<$PrismaModel> | $Enums.ParticipantStatus
  }

  export type EnumParticipantResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantResult | EnumParticipantResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumParticipantResultNullableFilter<$PrismaModel> | $Enums.ParticipantResult | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChallengesRelationFilter = {
    is?: challengesWhereInput
    isNot?: challengesWhereInput
  }

  export type StudentsRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type challenge_participantsChallengeIdStudentIdCompoundUniqueInput = {
    challengeId: string
    studentId: string
  }

  export type challenge_participantsCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    result?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
  }

  export type challenge_participantsAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type challenge_participantsMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    result?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
  }

  export type challenge_participantsMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    result?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
  }

  export type challenge_participantsSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumParticipantStatusFilter<$PrismaModel>
  }

  export type EnumParticipantResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantResult | EnumParticipantResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumParticipantResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumParticipantResultNullableFilter<$PrismaModel>
    _max?: NestedEnumParticipantResultNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type EnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Challenge_participantsListRelationFilter = {
    every?: challenge_participantsWhereInput
    some?: challenge_participantsWhereInput
    none?: challenge_participantsWhereInput
  }

  export type TeachersRelationFilter = {
    is?: teachersWhereInput
    isNot?: teachersWhereInput
  }

  export type challenge_participantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type challengesCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
    metadata?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type challengesAvgOrderByAggregateInput = {
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
  }

  export type challengesMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type challengesMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type challengesSumOrderByAggregateInput = {
    rewardPoints?: SortOrder
    rewardExp?: SortOrder
    maxParticipants?: SortOrder
  }

  export type EnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type EnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type HabitsRelationFilter = {
    is?: habitsWhereInput
    isNot?: habitsWhereInput
  }

  export type habit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    habitId?: SortOrder
    studentId?: SortOrder
    checkedAt?: SortOrder
    streakDays?: SortOrder
    notes?: SortOrder
  }

  export type habit_logsAvgOrderByAggregateInput = {
    streakDays?: SortOrder
  }

  export type habit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    habitId?: SortOrder
    studentId?: SortOrder
    checkedAt?: SortOrder
    streakDays?: SortOrder
    notes?: SortOrder
  }

  export type habit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    habitId?: SortOrder
    studentId?: SortOrder
    checkedAt?: SortOrder
    streakDays?: SortOrder
    notes?: SortOrder
  }

  export type habit_logsSumOrderByAggregateInput = {
    streakDays?: SortOrder
  }

  export type Habit_logsListRelationFilter = {
    every?: habit_logsWhereInput
    some?: habit_logsWhereInput
    none?: habit_logsWhereInput
  }

  export type habit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type habitsSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type habitsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type habitsAvgOrderByAggregateInput = {
    expReward?: SortOrder
    pointsReward?: SortOrder
  }

  export type habitsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type habitsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type habitsSumOrderByAggregateInput = {
    expReward?: SortOrder
    pointsReward?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Task_recordsListRelationFilter = {
    every?: task_recordsWhereInput
    some?: task_recordsWhereInput
    none?: task_recordsWhereInput
  }

  export type task_recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lesson_plansCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGlobal?: SortOrder
  }

  export type lesson_plansMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGlobal?: SortOrder
  }

  export type lesson_plansMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    teacherId?: SortOrder
    title?: SortOrder
    date?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isGlobal?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMistakeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MistakeStatus | EnumMistakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMistakeStatusFilter<$PrismaModel> | $Enums.MistakeStatus
  }

  export type mistakesCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    imageUrl?: SortOrder
    ocrText?: SortOrder
    status?: SortOrder
    category?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiAnalysis?: SortOrder
    errorCause?: SortOrder
    lastRetryAt?: SortOrder
    lesson?: SortOrder
    questionNo?: SortOrder
    retryCount?: SortOrder
    subject?: SortOrder
    unit?: SortOrder
    workbookPage?: SortOrder
    wrongCount?: SortOrder
  }

  export type mistakesAvgOrderByAggregateInput = {
    questionNo?: SortOrder
    retryCount?: SortOrder
    workbookPage?: SortOrder
    wrongCount?: SortOrder
  }

  export type mistakesMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    imageUrl?: SortOrder
    ocrText?: SortOrder
    status?: SortOrder
    category?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorCause?: SortOrder
    lastRetryAt?: SortOrder
    lesson?: SortOrder
    questionNo?: SortOrder
    retryCount?: SortOrder
    subject?: SortOrder
    unit?: SortOrder
    workbookPage?: SortOrder
    wrongCount?: SortOrder
  }

  export type mistakesMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    imageUrl?: SortOrder
    ocrText?: SortOrder
    status?: SortOrder
    category?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    errorCause?: SortOrder
    lastRetryAt?: SortOrder
    lesson?: SortOrder
    questionNo?: SortOrder
    retryCount?: SortOrder
    subject?: SortOrder
    unit?: SortOrder
    workbookPage?: SortOrder
    wrongCount?: SortOrder
  }

  export type mistakesSumOrderByAggregateInput = {
    questionNo?: SortOrder
    retryCount?: SortOrder
    workbookPage?: SortOrder
    wrongCount?: SortOrder
  }

  export type EnumMistakeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MistakeStatus | EnumMistakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMistakeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MistakeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMistakeStatusFilter<$PrismaModel>
    _max?: NestedEnumMistakeStatusFilter<$PrismaModel>
  }

  export type EnumPKStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PKStatus | EnumPKStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPKStatusFilter<$PrismaModel> | $Enums.PKStatus
  }

  export type StudentsNullableRelationFilter = {
    is?: studentsWhereInput | null
    isNot?: studentsWhereInput | null
  }

  export type pk_matchesCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentA?: SortOrder
    studentB?: SortOrder
    winnerId?: SortOrder
    status?: SortOrder
    topic?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pk_matchesMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentA?: SortOrder
    studentB?: SortOrder
    winnerId?: SortOrder
    status?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pk_matchesMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentA?: SortOrder
    studentB?: SortOrder
    winnerId?: SortOrder
    status?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPKStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PKStatus | EnumPKStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPKStatusWithAggregatesFilter<$PrismaModel> | $Enums.PKStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPKStatusFilter<$PrismaModel>
    _max?: NestedEnumPKStatusFilter<$PrismaModel>
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type BadgesListRelationFilter = {
    every?: badgesWhereInput
    some?: badgesWhereInput
    none?: badgesWhereInput
  }

  export type ChallengesListRelationFilter = {
    every?: challengesWhereInput
    some?: challengesWhereInput
    none?: challengesWhereInput
  }

  export type HabitsListRelationFilter = {
    every?: habitsWhereInput
    some?: habitsWhereInput
    none?: habitsWhereInput
  }

  export type Lesson_plansListRelationFilter = {
    every?: lesson_plansWhereInput
    some?: lesson_plansWhereInput
    none?: lesson_plansWhereInput
  }

  export type MistakesListRelationFilter = {
    every?: mistakesWhereInput
    some?: mistakesWhereInput
    none?: mistakesWhereInput
  }

  export type ParentsListRelationFilter = {
    every?: parentsWhereInput
    some?: parentsWhereInput
    none?: parentsWhereInput
  }

  export type Personalized_tutoring_plansListRelationFilter = {
    every?: personalized_tutoring_plansWhereInput
    some?: personalized_tutoring_plansWhereInput
    none?: personalized_tutoring_plansWhereInput
  }

  export type Pk_matchesListRelationFilter = {
    every?: pk_matchesWhereInput
    some?: pk_matchesWhereInput
    none?: pk_matchesWhereInput
  }

  export type Reward_configsListRelationFilter = {
    every?: reward_configsWhereInput
    some?: reward_configsWhereInput
    none?: reward_configsWhereInput
  }

  export type Student_checkinsListRelationFilter = {
    every?: student_checkinsWhereInput
    some?: student_checkinsWhereInput
    none?: student_checkinsWhereInput
  }

  export type StudentsListRelationFilter = {
    every?: studentsWhereInput
    some?: studentsWhereInput
    none?: studentsWhereInput
  }

  export type Task_libraryListRelationFilter = {
    every?: task_libraryWhereInput
    some?: task_libraryWhereInput
    none?: task_libraryWhereInput
  }

  export type TeachersListRelationFilter = {
    every?: teachersWhereInput
    some?: teachersWhereInput
    none?: teachersWhereInput
  }

  export type badgesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type challengesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type habitsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lesson_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mistakesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type personalized_tutoring_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pk_matchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reward_configsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_checkinsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type task_libraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teachersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type schoolsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    planType?: SortOrder
    settings?: SortOrder
    educationalPhilosophy?: SortOrder
    expiredAt?: SortOrder
  }

  export type schoolsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    planType?: SortOrder
    educationalPhilosophy?: SortOrder
    expiredAt?: SortOrder
  }

  export type schoolsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    planType?: SortOrder
    educationalPhilosophy?: SortOrder
    expiredAt?: SortOrder
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type BadgesRelationFilter = {
    is?: badgesWhereInput
    isNot?: badgesWhereInput
  }

  export type student_badgesCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    badgeId?: SortOrder
    awardedBy?: SortOrder
    awardedAt?: SortOrder
    reason?: SortOrder
  }

  export type student_badgesMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    badgeId?: SortOrder
    awardedBy?: SortOrder
    awardedAt?: SortOrder
    reason?: SortOrder
  }

  export type student_badgesMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    badgeId?: SortOrder
    awardedBy?: SortOrder
    awardedAt?: SortOrder
    reason?: SortOrder
  }

  export type CampaignsListRelationFilter = {
    every?: campaignsWhereInput
    some?: campaignsWhereInput
    none?: campaignsWhereInput
  }

  export type Daily_summariesListRelationFilter = {
    every?: daily_summariesWhereInput
    some?: daily_summariesWhereInput
    none?: daily_summariesWhereInput
  }

  export type Parent_student_bindingsListRelationFilter = {
    every?: parent_student_bindingsWhereInput
    some?: parent_student_bindingsWhereInput
    none?: parent_student_bindingsWhereInput
  }

  export type TeachersNullableRelationFilter = {
    is?: teachersWhereInput | null
    isNot?: teachersWhereInput | null
  }

  export type campaignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type daily_summariesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parent_student_bindingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsSchoolIdNameCompoundUniqueInput = {
    schoolId: string
    name: string
  }

  export type studentsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    className?: SortOrder
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    teacherId?: SortOrder
    currentLesson?: SortOrder
    currentLessonTitle?: SortOrder
    currentUnit?: SortOrder
    currentInviteCode?: SortOrder
    inviteCodeExpiresAt?: SortOrder
    deletedAt?: SortOrder
    grade?: SortOrder
    semester?: SortOrder
    currentProgress?: SortOrder
  }

  export type studentsAvgOrderByAggregateInput = {
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    className?: SortOrder
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    teacherId?: SortOrder
    currentLesson?: SortOrder
    currentLessonTitle?: SortOrder
    currentUnit?: SortOrder
    currentInviteCode?: SortOrder
    inviteCodeExpiresAt?: SortOrder
    deletedAt?: SortOrder
    grade?: SortOrder
    semester?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    className?: SortOrder
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamId?: SortOrder
    teacherId?: SortOrder
    currentLesson?: SortOrder
    currentLessonTitle?: SortOrder
    currentUnit?: SortOrder
    currentInviteCode?: SortOrder
    inviteCodeExpiresAt?: SortOrder
    deletedAt?: SortOrder
    grade?: SortOrder
    semester?: SortOrder
  }

  export type studentsSumOrderByAggregateInput = {
    level?: SortOrder
    points?: SortOrder
    exp?: SortOrder
  }

  export type student_checkinsStudentIdCheckinDateCompoundUniqueInput = {
    studentId: string
    checkinDate: string
  }

  export type student_checkinsCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    checkinDate?: SortOrder
    checkedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type student_checkinsMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    checkinDate?: SortOrder
    checkedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type student_checkinsMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    schoolId?: SortOrder
    checkinDate?: SortOrder
    checkedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type task_librarySchoolIdEducationalDomainEducationalSubcategoryNameCompoundUniqueInput = {
    schoolId: string
    educationalDomain: string
    educationalSubcategory: string
    name: string
  }

  export type task_libraryCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultExp?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    isGlobal?: SortOrder
    educationalDomain?: SortOrder
    educationalSubcategory?: SortOrder
  }

  export type task_libraryAvgOrderByAggregateInput = {
    defaultExp?: SortOrder
    difficulty?: SortOrder
  }

  export type task_libraryMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultExp?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    isGlobal?: SortOrder
    educationalDomain?: SortOrder
    educationalSubcategory?: SortOrder
  }

  export type task_libraryMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    description?: SortOrder
    defaultExp?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schoolId?: SortOrder
    isGlobal?: SortOrder
    educationalDomain?: SortOrder
    educationalSubcategory?: SortOrder
  }

  export type task_librarySumOrderByAggregateInput = {
    defaultExp?: SortOrder
    difficulty?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumTaskCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCategoryFilter<$PrismaModel> | $Enums.TaskCategory
  }

  export type Lesson_plansNullableRelationFilter = {
    is?: lesson_plansWhereInput | null
    isNot?: lesson_plansWhereInput | null
  }

  export type task_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    expAwarded?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessonPlanId?: SortOrder
    task_category?: SortOrder
    is_current?: SortOrder
    attempts?: SortOrder
    subject?: SortOrder
    isOverridden?: SortOrder
    settledAt?: SortOrder
  }

  export type task_recordsAvgOrderByAggregateInput = {
    expAwarded?: SortOrder
    attempts?: SortOrder
  }

  export type task_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    status?: SortOrder
    expAwarded?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessonPlanId?: SortOrder
    task_category?: SortOrder
    is_current?: SortOrder
    attempts?: SortOrder
    subject?: SortOrder
    isOverridden?: SortOrder
    settledAt?: SortOrder
  }

  export type task_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    status?: SortOrder
    expAwarded?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessonPlanId?: SortOrder
    task_category?: SortOrder
    is_current?: SortOrder
    attempts?: SortOrder
    subject?: SortOrder
    isOverridden?: SortOrder
    settledAt?: SortOrder
  }

  export type task_recordsSumOrderByAggregateInput = {
    expAwarded?: SortOrder
    attempts?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumTaskCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TaskCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskCategoryFilter<$PrismaModel>
    _max?: NestedEnumTaskCategoryFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SchoolsNullableRelationFilter = {
    is?: schoolsWhereInput | null
    isNot?: schoolsWhereInput | null
  }

  export type teachersCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    primaryClassName?: SortOrder
  }

  export type teachersMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    primaryClassName?: SortOrder
  }

  export type teachersMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    displayName?: SortOrder
    primaryClassName?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type personalized_tutoring_plansCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    duration?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    studentClass?: SortOrder
    knowledgePoints?: SortOrder
    mainProblem?: SortOrder
    detailedContent?: SortOrder
    teachingObjectives?: SortOrder
    preparationMaterials?: SortOrder
    tutoringMethods?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    expAwarded?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    completionNotes?: SortOrder
    studentFeedback?: SortOrder
    parentFeedback?: SortOrder
    effectivenessRating?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    attachments?: SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type personalized_tutoring_plansAvgOrderByAggregateInput = {
    difficulty?: SortOrder
    duration?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    effectivenessRating?: SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
  }

  export type personalized_tutoring_plansMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    duration?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    studentClass?: SortOrder
    mainProblem?: SortOrder
    detailedContent?: SortOrder
    teachingObjectives?: SortOrder
    preparationMaterials?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    expAwarded?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    completionNotes?: SortOrder
    studentFeedback?: SortOrder
    parentFeedback?: SortOrder
    effectivenessRating?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type personalized_tutoring_plansMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    duration?: SortOrder
    actualStartTime?: SortOrder
    actualEndTime?: SortOrder
    studentId?: SortOrder
    studentName?: SortOrder
    studentClass?: SortOrder
    mainProblem?: SortOrder
    detailedContent?: SortOrder
    teachingObjectives?: SortOrder
    preparationMaterials?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    expAwarded?: SortOrder
    pointsAwarded?: SortOrder
    status?: SortOrder
    completionNotes?: SortOrder
    studentFeedback?: SortOrder
    parentFeedback?: SortOrder
    effectivenessRating?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    followUpNotes?: SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type personalized_tutoring_plansSumOrderByAggregateInput = {
    difficulty?: SortOrder
    duration?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    effectivenessRating?: SortOrder
    totalSessions?: SortOrder
    completedSessions?: SortOrder
  }

  export type parentsSchoolIdPhoneCompoundUniqueInput = {
    schoolId: string
    phone: string
  }

  export type parentsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type parentsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type parentsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    identity?: SortOrder
    lastLoginAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentsRelationFilter = {
    is?: parentsWhereInput
    isNot?: parentsWhereInput
  }

  export type parent_student_bindingsParentIdStudentIdCompoundUniqueInput = {
    parentId: string
    studentId: string
  }

  export type parent_student_bindingsCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    inviteCode?: SortOrder
    bindingTime?: SortOrder
    isActive?: SortOrder
  }

  export type parent_student_bindingsMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    inviteCode?: SortOrder
    bindingTime?: SortOrder
    isActive?: SortOrder
  }

  export type parent_student_bindingsMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    inviteCode?: SortOrder
    bindingTime?: SortOrder
    isActive?: SortOrder
  }

  export type daily_summariesStudentIdParentIdDateCompoundUniqueInput = {
    studentId: string
    parentId: string
    date: string
  }

  export type daily_summariesCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    parentLiked?: SortOrder
    parentComment?: SortOrder
    teacherRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type daily_summariesMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    parentLiked?: SortOrder
    parentComment?: SortOrder
    teacherRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type daily_summariesMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    parentLiked?: SortOrder
    parentComment?: SortOrder
    teacherRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type campaignsCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type campaignsMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type campaignsMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type reward_configsSchoolIdModuleActionCompoundUniqueInput = {
    schoolId: string
    module: string
    action: string
  }

  export type reward_configsCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    module?: SortOrder
    category?: SortOrder
    action?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type reward_configsAvgOrderByAggregateInput = {
    expReward?: SortOrder
    pointsReward?: SortOrder
  }

  export type reward_configsMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    module?: SortOrder
    category?: SortOrder
    action?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type reward_configsMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    module?: SortOrder
    category?: SortOrder
    action?: SortOrder
    expReward?: SortOrder
    pointsReward?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type reward_configsSumOrderByAggregateInput = {
    expReward?: SortOrder
    pointsReward?: SortOrder
  }

  export type schoolsCreateNestedOneWithoutBadgesInput = {
    create?: XOR<schoolsCreateWithoutBadgesInput, schoolsUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutBadgesInput
    connect?: schoolsWhereUniqueInput
  }

  export type student_badgesCreateNestedManyWithoutBadgesInput = {
    create?: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput> | student_badgesCreateWithoutBadgesInput[] | student_badgesUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutBadgesInput | student_badgesCreateOrConnectWithoutBadgesInput[]
    createMany?: student_badgesCreateManyBadgesInputEnvelope
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
  }

  export type student_badgesUncheckedCreateNestedManyWithoutBadgesInput = {
    create?: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput> | student_badgesCreateWithoutBadgesInput[] | student_badgesUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutBadgesInput | student_badgesCreateOrConnectWithoutBadgesInput[]
    createMany?: student_badgesCreateManyBadgesInputEnvelope
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type schoolsUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<schoolsCreateWithoutBadgesInput, schoolsUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutBadgesInput
    upsert?: schoolsUpsertWithoutBadgesInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutBadgesInput, schoolsUpdateWithoutBadgesInput>, schoolsUncheckedUpdateWithoutBadgesInput>
  }

  export type student_badgesUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput> | student_badgesCreateWithoutBadgesInput[] | student_badgesUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutBadgesInput | student_badgesCreateOrConnectWithoutBadgesInput[]
    upsert?: student_badgesUpsertWithWhereUniqueWithoutBadgesInput | student_badgesUpsertWithWhereUniqueWithoutBadgesInput[]
    createMany?: student_badgesCreateManyBadgesInputEnvelope
    set?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    disconnect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    delete?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    update?: student_badgesUpdateWithWhereUniqueWithoutBadgesInput | student_badgesUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: student_badgesUpdateManyWithWhereWithoutBadgesInput | student_badgesUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
  }

  export type student_badgesUncheckedUpdateManyWithoutBadgesNestedInput = {
    create?: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput> | student_badgesCreateWithoutBadgesInput[] | student_badgesUncheckedCreateWithoutBadgesInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutBadgesInput | student_badgesCreateOrConnectWithoutBadgesInput[]
    upsert?: student_badgesUpsertWithWhereUniqueWithoutBadgesInput | student_badgesUpsertWithWhereUniqueWithoutBadgesInput[]
    createMany?: student_badgesCreateManyBadgesInputEnvelope
    set?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    disconnect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    delete?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    update?: student_badgesUpdateWithWhereUniqueWithoutBadgesInput | student_badgesUpdateWithWhereUniqueWithoutBadgesInput[]
    updateMany?: student_badgesUpdateManyWithWhereWithoutBadgesInput | student_badgesUpdateManyWithWhereWithoutBadgesInput[]
    deleteMany?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
  }

  export type challengesCreateNestedOneWithoutChallenge_participantsInput = {
    create?: XOR<challengesCreateWithoutChallenge_participantsInput, challengesUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: challengesCreateOrConnectWithoutChallenge_participantsInput
    connect?: challengesWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutChallenge_participantsInput = {
    create?: XOR<studentsCreateWithoutChallenge_participantsInput, studentsUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutChallenge_participantsInput
    connect?: studentsWhereUniqueInput
  }

  export type EnumParticipantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantStatus
  }

  export type NullableEnumParticipantResultFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantResult | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type challengesUpdateOneRequiredWithoutChallenge_participantsNestedInput = {
    create?: XOR<challengesCreateWithoutChallenge_participantsInput, challengesUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: challengesCreateOrConnectWithoutChallenge_participantsInput
    upsert?: challengesUpsertWithoutChallenge_participantsInput
    connect?: challengesWhereUniqueInput
    update?: XOR<XOR<challengesUpdateToOneWithWhereWithoutChallenge_participantsInput, challengesUpdateWithoutChallenge_participantsInput>, challengesUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type studentsUpdateOneRequiredWithoutChallenge_participantsNestedInput = {
    create?: XOR<studentsCreateWithoutChallenge_participantsInput, studentsUncheckedCreateWithoutChallenge_participantsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutChallenge_participantsInput
    upsert?: studentsUpsertWithoutChallenge_participantsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutChallenge_participantsInput, studentsUpdateWithoutChallenge_participantsInput>, studentsUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type challenge_participantsCreateNestedManyWithoutChallengesInput = {
    create?: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput> | challenge_participantsCreateWithoutChallengesInput[] | challenge_participantsUncheckedCreateWithoutChallengesInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutChallengesInput | challenge_participantsCreateOrConnectWithoutChallengesInput[]
    createMany?: challenge_participantsCreateManyChallengesInputEnvelope
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
  }

  export type teachersCreateNestedOneWithoutChallengesInput = {
    create?: XOR<teachersCreateWithoutChallengesInput, teachersUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutChallengesInput
    connect?: teachersWhereUniqueInput
  }

  export type schoolsCreateNestedOneWithoutChallengesInput = {
    create?: XOR<schoolsCreateWithoutChallengesInput, schoolsUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutChallengesInput
    connect?: schoolsWhereUniqueInput
  }

  export type challenge_participantsUncheckedCreateNestedManyWithoutChallengesInput = {
    create?: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput> | challenge_participantsCreateWithoutChallengesInput[] | challenge_participantsUncheckedCreateWithoutChallengesInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutChallengesInput | challenge_participantsCreateOrConnectWithoutChallengesInput[]
    createMany?: challenge_participantsCreateManyChallengesInputEnvelope
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
  }

  export type EnumChallengeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeType
  }

  export type EnumChallengeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type challenge_participantsUpdateManyWithoutChallengesNestedInput = {
    create?: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput> | challenge_participantsCreateWithoutChallengesInput[] | challenge_participantsUncheckedCreateWithoutChallengesInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutChallengesInput | challenge_participantsCreateOrConnectWithoutChallengesInput[]
    upsert?: challenge_participantsUpsertWithWhereUniqueWithoutChallengesInput | challenge_participantsUpsertWithWhereUniqueWithoutChallengesInput[]
    createMany?: challenge_participantsCreateManyChallengesInputEnvelope
    set?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    disconnect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    delete?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    update?: challenge_participantsUpdateWithWhereUniqueWithoutChallengesInput | challenge_participantsUpdateWithWhereUniqueWithoutChallengesInput[]
    updateMany?: challenge_participantsUpdateManyWithWhereWithoutChallengesInput | challenge_participantsUpdateManyWithWhereWithoutChallengesInput[]
    deleteMany?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
  }

  export type teachersUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<teachersCreateWithoutChallengesInput, teachersUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: teachersCreateOrConnectWithoutChallengesInput
    upsert?: teachersUpsertWithoutChallengesInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutChallengesInput, teachersUpdateWithoutChallengesInput>, teachersUncheckedUpdateWithoutChallengesInput>
  }

  export type schoolsUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<schoolsCreateWithoutChallengesInput, schoolsUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutChallengesInput
    upsert?: schoolsUpsertWithoutChallengesInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutChallengesInput, schoolsUpdateWithoutChallengesInput>, schoolsUncheckedUpdateWithoutChallengesInput>
  }

  export type challenge_participantsUncheckedUpdateManyWithoutChallengesNestedInput = {
    create?: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput> | challenge_participantsCreateWithoutChallengesInput[] | challenge_participantsUncheckedCreateWithoutChallengesInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutChallengesInput | challenge_participantsCreateOrConnectWithoutChallengesInput[]
    upsert?: challenge_participantsUpsertWithWhereUniqueWithoutChallengesInput | challenge_participantsUpsertWithWhereUniqueWithoutChallengesInput[]
    createMany?: challenge_participantsCreateManyChallengesInputEnvelope
    set?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    disconnect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    delete?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    update?: challenge_participantsUpdateWithWhereUniqueWithoutChallengesInput | challenge_participantsUpdateWithWhereUniqueWithoutChallengesInput[]
    updateMany?: challenge_participantsUpdateManyWithWhereWithoutChallengesInput | challenge_participantsUpdateManyWithWhereWithoutChallengesInput[]
    deleteMany?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
  }

  export type habitsCreateNestedOneWithoutHabit_logsInput = {
    create?: XOR<habitsCreateWithoutHabit_logsInput, habitsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: habitsCreateOrConnectWithoutHabit_logsInput
    connect?: habitsWhereUniqueInput
  }

  export type schoolsCreateNestedOneWithoutHabit_logsInput = {
    create?: XOR<schoolsCreateWithoutHabit_logsInput, schoolsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutHabit_logsInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutHabit_logsInput = {
    create?: XOR<studentsCreateWithoutHabit_logsInput, studentsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutHabit_logsInput
    connect?: studentsWhereUniqueInput
  }

  export type habitsUpdateOneRequiredWithoutHabit_logsNestedInput = {
    create?: XOR<habitsCreateWithoutHabit_logsInput, habitsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: habitsCreateOrConnectWithoutHabit_logsInput
    upsert?: habitsUpsertWithoutHabit_logsInput
    connect?: habitsWhereUniqueInput
    update?: XOR<XOR<habitsUpdateToOneWithWhereWithoutHabit_logsInput, habitsUpdateWithoutHabit_logsInput>, habitsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type schoolsUpdateOneRequiredWithoutHabit_logsNestedInput = {
    create?: XOR<schoolsCreateWithoutHabit_logsInput, schoolsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutHabit_logsInput
    upsert?: schoolsUpsertWithoutHabit_logsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutHabit_logsInput, schoolsUpdateWithoutHabit_logsInput>, schoolsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type studentsUpdateOneRequiredWithoutHabit_logsNestedInput = {
    create?: XOR<studentsCreateWithoutHabit_logsInput, studentsUncheckedCreateWithoutHabit_logsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutHabit_logsInput
    upsert?: studentsUpsertWithoutHabit_logsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutHabit_logsInput, studentsUpdateWithoutHabit_logsInput>, studentsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type habit_logsCreateNestedManyWithoutHabitsInput = {
    create?: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput> | habit_logsCreateWithoutHabitsInput[] | habit_logsUncheckedCreateWithoutHabitsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutHabitsInput | habit_logsCreateOrConnectWithoutHabitsInput[]
    createMany?: habit_logsCreateManyHabitsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type schoolsCreateNestedOneWithoutHabitsInput = {
    create?: XOR<schoolsCreateWithoutHabitsInput, schoolsUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutHabitsInput
    connect?: schoolsWhereUniqueInput
  }

  export type habit_logsUncheckedCreateNestedManyWithoutHabitsInput = {
    create?: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput> | habit_logsCreateWithoutHabitsInput[] | habit_logsUncheckedCreateWithoutHabitsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutHabitsInput | habit_logsCreateOrConnectWithoutHabitsInput[]
    createMany?: habit_logsCreateManyHabitsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type habit_logsUpdateManyWithoutHabitsNestedInput = {
    create?: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput> | habit_logsCreateWithoutHabitsInput[] | habit_logsUncheckedCreateWithoutHabitsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutHabitsInput | habit_logsCreateOrConnectWithoutHabitsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutHabitsInput | habit_logsUpsertWithWhereUniqueWithoutHabitsInput[]
    createMany?: habit_logsCreateManyHabitsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutHabitsInput | habit_logsUpdateWithWhereUniqueWithoutHabitsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutHabitsInput | habit_logsUpdateManyWithWhereWithoutHabitsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type schoolsUpdateOneRequiredWithoutHabitsNestedInput = {
    create?: XOR<schoolsCreateWithoutHabitsInput, schoolsUncheckedCreateWithoutHabitsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutHabitsInput
    upsert?: schoolsUpsertWithoutHabitsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutHabitsInput, schoolsUpdateWithoutHabitsInput>, schoolsUncheckedUpdateWithoutHabitsInput>
  }

  export type habit_logsUncheckedUpdateManyWithoutHabitsNestedInput = {
    create?: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput> | habit_logsCreateWithoutHabitsInput[] | habit_logsUncheckedCreateWithoutHabitsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutHabitsInput | habit_logsCreateOrConnectWithoutHabitsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutHabitsInput | habit_logsUpsertWithWhereUniqueWithoutHabitsInput[]
    createMany?: habit_logsCreateManyHabitsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutHabitsInput | habit_logsUpdateWithWhereUniqueWithoutHabitsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutHabitsInput | habit_logsUpdateManyWithWhereWithoutHabitsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type schoolsCreateNestedOneWithoutLesson_plansInput = {
    create?: XOR<schoolsCreateWithoutLesson_plansInput, schoolsUncheckedCreateWithoutLesson_plansInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutLesson_plansInput
    connect?: schoolsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutLesson_plansInput = {
    create?: XOR<teachersCreateWithoutLesson_plansInput, teachersUncheckedCreateWithoutLesson_plansInput>
    connectOrCreate?: teachersCreateOrConnectWithoutLesson_plansInput
    connect?: teachersWhereUniqueInput
  }

  export type task_recordsCreateNestedManyWithoutLesson_plansInput = {
    create?: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput> | task_recordsCreateWithoutLesson_plansInput[] | task_recordsUncheckedCreateWithoutLesson_plansInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutLesson_plansInput | task_recordsCreateOrConnectWithoutLesson_plansInput[]
    createMany?: task_recordsCreateManyLesson_plansInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type task_recordsUncheckedCreateNestedManyWithoutLesson_plansInput = {
    create?: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput> | task_recordsCreateWithoutLesson_plansInput[] | task_recordsUncheckedCreateWithoutLesson_plansInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutLesson_plansInput | task_recordsCreateOrConnectWithoutLesson_plansInput[]
    createMany?: task_recordsCreateManyLesson_plansInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type schoolsUpdateOneRequiredWithoutLesson_plansNestedInput = {
    create?: XOR<schoolsCreateWithoutLesson_plansInput, schoolsUncheckedCreateWithoutLesson_plansInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutLesson_plansInput
    upsert?: schoolsUpsertWithoutLesson_plansInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutLesson_plansInput, schoolsUpdateWithoutLesson_plansInput>, schoolsUncheckedUpdateWithoutLesson_plansInput>
  }

  export type teachersUpdateOneRequiredWithoutLesson_plansNestedInput = {
    create?: XOR<teachersCreateWithoutLesson_plansInput, teachersUncheckedCreateWithoutLesson_plansInput>
    connectOrCreate?: teachersCreateOrConnectWithoutLesson_plansInput
    upsert?: teachersUpsertWithoutLesson_plansInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutLesson_plansInput, teachersUpdateWithoutLesson_plansInput>, teachersUncheckedUpdateWithoutLesson_plansInput>
  }

  export type task_recordsUpdateManyWithoutLesson_plansNestedInput = {
    create?: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput> | task_recordsCreateWithoutLesson_plansInput[] | task_recordsUncheckedCreateWithoutLesson_plansInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutLesson_plansInput | task_recordsCreateOrConnectWithoutLesson_plansInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutLesson_plansInput | task_recordsUpsertWithWhereUniqueWithoutLesson_plansInput[]
    createMany?: task_recordsCreateManyLesson_plansInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutLesson_plansInput | task_recordsUpdateWithWhereUniqueWithoutLesson_plansInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutLesson_plansInput | task_recordsUpdateManyWithWhereWithoutLesson_plansInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type task_recordsUncheckedUpdateManyWithoutLesson_plansNestedInput = {
    create?: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput> | task_recordsCreateWithoutLesson_plansInput[] | task_recordsUncheckedCreateWithoutLesson_plansInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutLesson_plansInput | task_recordsCreateOrConnectWithoutLesson_plansInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutLesson_plansInput | task_recordsUpsertWithWhereUniqueWithoutLesson_plansInput[]
    createMany?: task_recordsCreateManyLesson_plansInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutLesson_plansInput | task_recordsUpdateWithWhereUniqueWithoutLesson_plansInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutLesson_plansInput | task_recordsUpdateManyWithWhereWithoutLesson_plansInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type schoolsCreateNestedOneWithoutMistakesInput = {
    create?: XOR<schoolsCreateWithoutMistakesInput, schoolsUncheckedCreateWithoutMistakesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutMistakesInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutMistakesInput = {
    create?: XOR<studentsCreateWithoutMistakesInput, studentsUncheckedCreateWithoutMistakesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutMistakesInput
    connect?: studentsWhereUniqueInput
  }

  export type EnumMistakeStatusFieldUpdateOperationsInput = {
    set?: $Enums.MistakeStatus
  }

  export type schoolsUpdateOneRequiredWithoutMistakesNestedInput = {
    create?: XOR<schoolsCreateWithoutMistakesInput, schoolsUncheckedCreateWithoutMistakesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutMistakesInput
    upsert?: schoolsUpsertWithoutMistakesInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutMistakesInput, schoolsUpdateWithoutMistakesInput>, schoolsUncheckedUpdateWithoutMistakesInput>
  }

  export type studentsUpdateOneRequiredWithoutMistakesNestedInput = {
    create?: XOR<studentsCreateWithoutMistakesInput, studentsUncheckedCreateWithoutMistakesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutMistakesInput
    upsert?: studentsUpsertWithoutMistakesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutMistakesInput, studentsUpdateWithoutMistakesInput>, studentsUncheckedUpdateWithoutMistakesInput>
  }

  export type schoolsCreateNestedOneWithoutPk_matchesInput = {
    create?: XOR<schoolsCreateWithoutPk_matchesInput, schoolsUncheckedCreateWithoutPk_matchesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutPk_matchesInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutPk_matches_studentAInput = {
    create?: XOR<studentsCreateWithoutPk_matches_studentAInput, studentsUncheckedCreateWithoutPk_matches_studentAInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_studentAInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutPk_matches_studentBInput = {
    create?: XOR<studentsCreateWithoutPk_matches_studentBInput, studentsUncheckedCreateWithoutPk_matches_studentBInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_studentBInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutPk_matches_winnerInput = {
    create?: XOR<studentsCreateWithoutPk_matches_winnerInput, studentsUncheckedCreateWithoutPk_matches_winnerInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_winnerInput
    connect?: studentsWhereUniqueInput
  }

  export type EnumPKStatusFieldUpdateOperationsInput = {
    set?: $Enums.PKStatus
  }

  export type schoolsUpdateOneRequiredWithoutPk_matchesNestedInput = {
    create?: XOR<schoolsCreateWithoutPk_matchesInput, schoolsUncheckedCreateWithoutPk_matchesInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutPk_matchesInput
    upsert?: schoolsUpsertWithoutPk_matchesInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutPk_matchesInput, schoolsUpdateWithoutPk_matchesInput>, schoolsUncheckedUpdateWithoutPk_matchesInput>
  }

  export type studentsUpdateOneRequiredWithoutPk_matches_studentANestedInput = {
    create?: XOR<studentsCreateWithoutPk_matches_studentAInput, studentsUncheckedCreateWithoutPk_matches_studentAInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_studentAInput
    upsert?: studentsUpsertWithoutPk_matches_studentAInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutPk_matches_studentAInput, studentsUpdateWithoutPk_matches_studentAInput>, studentsUncheckedUpdateWithoutPk_matches_studentAInput>
  }

  export type studentsUpdateOneRequiredWithoutPk_matches_studentBNestedInput = {
    create?: XOR<studentsCreateWithoutPk_matches_studentBInput, studentsUncheckedCreateWithoutPk_matches_studentBInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_studentBInput
    upsert?: studentsUpsertWithoutPk_matches_studentBInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutPk_matches_studentBInput, studentsUpdateWithoutPk_matches_studentBInput>, studentsUncheckedUpdateWithoutPk_matches_studentBInput>
  }

  export type studentsUpdateOneWithoutPk_matches_winnerNestedInput = {
    create?: XOR<studentsCreateWithoutPk_matches_winnerInput, studentsUncheckedCreateWithoutPk_matches_winnerInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPk_matches_winnerInput
    upsert?: studentsUpsertWithoutPk_matches_winnerInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutPk_matches_winnerInput, studentsUpdateWithoutPk_matches_winnerInput>, studentsUncheckedUpdateWithoutPk_matches_winnerInput>
  }

  export type badgesCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput> | badgesCreateWithoutSchoolsInput[] | badgesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutSchoolsInput | badgesCreateOrConnectWithoutSchoolsInput[]
    createMany?: badgesCreateManySchoolsInputEnvelope
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
  }

  export type challengesCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput> | challengesCreateWithoutSchoolsInput[] | challengesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutSchoolsInput | challengesCreateOrConnectWithoutSchoolsInput[]
    createMany?: challengesCreateManySchoolsInputEnvelope
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
  }

  export type habit_logsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput> | habit_logsCreateWithoutSchoolsInput[] | habit_logsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutSchoolsInput | habit_logsCreateOrConnectWithoutSchoolsInput[]
    createMany?: habit_logsCreateManySchoolsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type habitsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput> | habitsCreateWithoutSchoolsInput[] | habitsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habitsCreateOrConnectWithoutSchoolsInput | habitsCreateOrConnectWithoutSchoolsInput[]
    createMany?: habitsCreateManySchoolsInputEnvelope
    connect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
  }

  export type lesson_plansCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput> | lesson_plansCreateWithoutSchoolsInput[] | lesson_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutSchoolsInput | lesson_plansCreateOrConnectWithoutSchoolsInput[]
    createMany?: lesson_plansCreateManySchoolsInputEnvelope
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
  }

  export type mistakesCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput> | mistakesCreateWithoutSchoolsInput[] | mistakesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutSchoolsInput | mistakesCreateOrConnectWithoutSchoolsInput[]
    createMany?: mistakesCreateManySchoolsInputEnvelope
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
  }

  export type parentsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput> | parentsCreateWithoutSchoolsInput[] | parentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutSchoolsInput | parentsCreateOrConnectWithoutSchoolsInput[]
    createMany?: parentsCreateManySchoolsInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput> | personalized_tutoring_plansCreateWithoutSchoolsInput[] | personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput | personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput[]
    createMany?: personalized_tutoring_plansCreateManySchoolsInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type pk_matchesCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput> | pk_matchesCreateWithoutSchoolsInput[] | pk_matchesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutSchoolsInput | pk_matchesCreateOrConnectWithoutSchoolsInput[]
    createMany?: pk_matchesCreateManySchoolsInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type reward_configsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput> | reward_configsCreateWithoutSchoolsInput[] | reward_configsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: reward_configsCreateOrConnectWithoutSchoolsInput | reward_configsCreateOrConnectWithoutSchoolsInput[]
    createMany?: reward_configsCreateManySchoolsInputEnvelope
    connect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
  }

  export type student_checkinsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput> | student_checkinsCreateWithoutSchoolsInput[] | student_checkinsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutSchoolsInput | student_checkinsCreateOrConnectWithoutSchoolsInput[]
    createMany?: student_checkinsCreateManySchoolsInputEnvelope
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput> | studentsCreateWithoutSchoolsInput[] | studentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutSchoolsInput | studentsCreateOrConnectWithoutSchoolsInput[]
    createMany?: studentsCreateManySchoolsInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type task_libraryCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput> | task_libraryCreateWithoutSchoolsInput[] | task_libraryUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_libraryCreateOrConnectWithoutSchoolsInput | task_libraryCreateOrConnectWithoutSchoolsInput[]
    createMany?: task_libraryCreateManySchoolsInputEnvelope
    connect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
  }

  export type task_recordsCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput> | task_recordsCreateWithoutSchoolsInput[] | task_recordsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutSchoolsInput | task_recordsCreateOrConnectWithoutSchoolsInput[]
    createMany?: task_recordsCreateManySchoolsInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type teachersCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput> | teachersCreateWithoutSchoolsInput[] | teachersUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSchoolsInput | teachersCreateOrConnectWithoutSchoolsInput[]
    createMany?: teachersCreateManySchoolsInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type badgesUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput> | badgesCreateWithoutSchoolsInput[] | badgesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutSchoolsInput | badgesCreateOrConnectWithoutSchoolsInput[]
    createMany?: badgesCreateManySchoolsInputEnvelope
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
  }

  export type challengesUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput> | challengesCreateWithoutSchoolsInput[] | challengesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutSchoolsInput | challengesCreateOrConnectWithoutSchoolsInput[]
    createMany?: challengesCreateManySchoolsInputEnvelope
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
  }

  export type habit_logsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput> | habit_logsCreateWithoutSchoolsInput[] | habit_logsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutSchoolsInput | habit_logsCreateOrConnectWithoutSchoolsInput[]
    createMany?: habit_logsCreateManySchoolsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type habitsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput> | habitsCreateWithoutSchoolsInput[] | habitsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habitsCreateOrConnectWithoutSchoolsInput | habitsCreateOrConnectWithoutSchoolsInput[]
    createMany?: habitsCreateManySchoolsInputEnvelope
    connect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
  }

  export type lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput> | lesson_plansCreateWithoutSchoolsInput[] | lesson_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutSchoolsInput | lesson_plansCreateOrConnectWithoutSchoolsInput[]
    createMany?: lesson_plansCreateManySchoolsInputEnvelope
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
  }

  export type mistakesUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput> | mistakesCreateWithoutSchoolsInput[] | mistakesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutSchoolsInput | mistakesCreateOrConnectWithoutSchoolsInput[]
    createMany?: mistakesCreateManySchoolsInputEnvelope
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
  }

  export type parentsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput> | parentsCreateWithoutSchoolsInput[] | parentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutSchoolsInput | parentsCreateOrConnectWithoutSchoolsInput[]
    createMany?: parentsCreateManySchoolsInputEnvelope
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
  }

  export type personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput> | personalized_tutoring_plansCreateWithoutSchoolsInput[] | personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput | personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput[]
    createMany?: personalized_tutoring_plansCreateManySchoolsInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput> | pk_matchesCreateWithoutSchoolsInput[] | pk_matchesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutSchoolsInput | pk_matchesCreateOrConnectWithoutSchoolsInput[]
    createMany?: pk_matchesCreateManySchoolsInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type reward_configsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput> | reward_configsCreateWithoutSchoolsInput[] | reward_configsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: reward_configsCreateOrConnectWithoutSchoolsInput | reward_configsCreateOrConnectWithoutSchoolsInput[]
    createMany?: reward_configsCreateManySchoolsInputEnvelope
    connect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
  }

  export type student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput> | student_checkinsCreateWithoutSchoolsInput[] | student_checkinsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutSchoolsInput | student_checkinsCreateOrConnectWithoutSchoolsInput[]
    createMany?: student_checkinsCreateManySchoolsInputEnvelope
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput> | studentsCreateWithoutSchoolsInput[] | studentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutSchoolsInput | studentsCreateOrConnectWithoutSchoolsInput[]
    createMany?: studentsCreateManySchoolsInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type task_libraryUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput> | task_libraryCreateWithoutSchoolsInput[] | task_libraryUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_libraryCreateOrConnectWithoutSchoolsInput | task_libraryCreateOrConnectWithoutSchoolsInput[]
    createMany?: task_libraryCreateManySchoolsInputEnvelope
    connect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
  }

  export type task_recordsUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput> | task_recordsCreateWithoutSchoolsInput[] | task_recordsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutSchoolsInput | task_recordsCreateOrConnectWithoutSchoolsInput[]
    createMany?: task_recordsCreateManySchoolsInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type teachersUncheckedCreateNestedManyWithoutSchoolsInput = {
    create?: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput> | teachersCreateWithoutSchoolsInput[] | teachersUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSchoolsInput | teachersCreateOrConnectWithoutSchoolsInput[]
    createMany?: teachersCreateManySchoolsInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type badgesUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput> | badgesCreateWithoutSchoolsInput[] | badgesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutSchoolsInput | badgesCreateOrConnectWithoutSchoolsInput[]
    upsert?: badgesUpsertWithWhereUniqueWithoutSchoolsInput | badgesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: badgesCreateManySchoolsInputEnvelope
    set?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    disconnect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    delete?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    update?: badgesUpdateWithWhereUniqueWithoutSchoolsInput | badgesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: badgesUpdateManyWithWhereWithoutSchoolsInput | badgesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: badgesScalarWhereInput | badgesScalarWhereInput[]
  }

  export type challengesUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput> | challengesCreateWithoutSchoolsInput[] | challengesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutSchoolsInput | challengesCreateOrConnectWithoutSchoolsInput[]
    upsert?: challengesUpsertWithWhereUniqueWithoutSchoolsInput | challengesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: challengesCreateManySchoolsInputEnvelope
    set?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    disconnect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    delete?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    update?: challengesUpdateWithWhereUniqueWithoutSchoolsInput | challengesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: challengesUpdateManyWithWhereWithoutSchoolsInput | challengesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: challengesScalarWhereInput | challengesScalarWhereInput[]
  }

  export type habit_logsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput> | habit_logsCreateWithoutSchoolsInput[] | habit_logsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutSchoolsInput | habit_logsCreateOrConnectWithoutSchoolsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutSchoolsInput | habit_logsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: habit_logsCreateManySchoolsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutSchoolsInput | habit_logsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutSchoolsInput | habit_logsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type habitsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput> | habitsCreateWithoutSchoolsInput[] | habitsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habitsCreateOrConnectWithoutSchoolsInput | habitsCreateOrConnectWithoutSchoolsInput[]
    upsert?: habitsUpsertWithWhereUniqueWithoutSchoolsInput | habitsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: habitsCreateManySchoolsInputEnvelope
    set?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    disconnect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    delete?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    connect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    update?: habitsUpdateWithWhereUniqueWithoutSchoolsInput | habitsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: habitsUpdateManyWithWhereWithoutSchoolsInput | habitsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: habitsScalarWhereInput | habitsScalarWhereInput[]
  }

  export type lesson_plansUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput> | lesson_plansCreateWithoutSchoolsInput[] | lesson_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutSchoolsInput | lesson_plansCreateOrConnectWithoutSchoolsInput[]
    upsert?: lesson_plansUpsertWithWhereUniqueWithoutSchoolsInput | lesson_plansUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: lesson_plansCreateManySchoolsInputEnvelope
    set?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    disconnect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    delete?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    update?: lesson_plansUpdateWithWhereUniqueWithoutSchoolsInput | lesson_plansUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: lesson_plansUpdateManyWithWhereWithoutSchoolsInput | lesson_plansUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
  }

  export type mistakesUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput> | mistakesCreateWithoutSchoolsInput[] | mistakesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutSchoolsInput | mistakesCreateOrConnectWithoutSchoolsInput[]
    upsert?: mistakesUpsertWithWhereUniqueWithoutSchoolsInput | mistakesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: mistakesCreateManySchoolsInputEnvelope
    set?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    disconnect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    delete?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    update?: mistakesUpdateWithWhereUniqueWithoutSchoolsInput | mistakesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: mistakesUpdateManyWithWhereWithoutSchoolsInput | mistakesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
  }

  export type parentsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput> | parentsCreateWithoutSchoolsInput[] | parentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutSchoolsInput | parentsCreateOrConnectWithoutSchoolsInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutSchoolsInput | parentsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: parentsCreateManySchoolsInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutSchoolsInput | parentsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutSchoolsInput | parentsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput> | personalized_tutoring_plansCreateWithoutSchoolsInput[] | personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput | personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutSchoolsInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: personalized_tutoring_plansCreateManySchoolsInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutSchoolsInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutSchoolsInput | personalized_tutoring_plansUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type pk_matchesUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput> | pk_matchesCreateWithoutSchoolsInput[] | pk_matchesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutSchoolsInput | pk_matchesCreateOrConnectWithoutSchoolsInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutSchoolsInput | pk_matchesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: pk_matchesCreateManySchoolsInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutSchoolsInput | pk_matchesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutSchoolsInput | pk_matchesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type reward_configsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput> | reward_configsCreateWithoutSchoolsInput[] | reward_configsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: reward_configsCreateOrConnectWithoutSchoolsInput | reward_configsCreateOrConnectWithoutSchoolsInput[]
    upsert?: reward_configsUpsertWithWhereUniqueWithoutSchoolsInput | reward_configsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: reward_configsCreateManySchoolsInputEnvelope
    set?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    disconnect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    delete?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    connect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    update?: reward_configsUpdateWithWhereUniqueWithoutSchoolsInput | reward_configsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: reward_configsUpdateManyWithWhereWithoutSchoolsInput | reward_configsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: reward_configsScalarWhereInput | reward_configsScalarWhereInput[]
  }

  export type student_checkinsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput> | student_checkinsCreateWithoutSchoolsInput[] | student_checkinsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutSchoolsInput | student_checkinsCreateOrConnectWithoutSchoolsInput[]
    upsert?: student_checkinsUpsertWithWhereUniqueWithoutSchoolsInput | student_checkinsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: student_checkinsCreateManySchoolsInputEnvelope
    set?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    disconnect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    delete?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    update?: student_checkinsUpdateWithWhereUniqueWithoutSchoolsInput | student_checkinsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: student_checkinsUpdateManyWithWhereWithoutSchoolsInput | student_checkinsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput> | studentsCreateWithoutSchoolsInput[] | studentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutSchoolsInput | studentsCreateOrConnectWithoutSchoolsInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutSchoolsInput | studentsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: studentsCreateManySchoolsInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutSchoolsInput | studentsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutSchoolsInput | studentsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type task_libraryUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput> | task_libraryCreateWithoutSchoolsInput[] | task_libraryUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_libraryCreateOrConnectWithoutSchoolsInput | task_libraryCreateOrConnectWithoutSchoolsInput[]
    upsert?: task_libraryUpsertWithWhereUniqueWithoutSchoolsInput | task_libraryUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: task_libraryCreateManySchoolsInputEnvelope
    set?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    disconnect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    delete?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    connect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    update?: task_libraryUpdateWithWhereUniqueWithoutSchoolsInput | task_libraryUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: task_libraryUpdateManyWithWhereWithoutSchoolsInput | task_libraryUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: task_libraryScalarWhereInput | task_libraryScalarWhereInput[]
  }

  export type task_recordsUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput> | task_recordsCreateWithoutSchoolsInput[] | task_recordsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutSchoolsInput | task_recordsCreateOrConnectWithoutSchoolsInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutSchoolsInput | task_recordsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: task_recordsCreateManySchoolsInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutSchoolsInput | task_recordsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutSchoolsInput | task_recordsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type teachersUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput> | teachersCreateWithoutSchoolsInput[] | teachersUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSchoolsInput | teachersCreateOrConnectWithoutSchoolsInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutSchoolsInput | teachersUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: teachersCreateManySchoolsInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutSchoolsInput | teachersUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutSchoolsInput | teachersUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type badgesUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput> | badgesCreateWithoutSchoolsInput[] | badgesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: badgesCreateOrConnectWithoutSchoolsInput | badgesCreateOrConnectWithoutSchoolsInput[]
    upsert?: badgesUpsertWithWhereUniqueWithoutSchoolsInput | badgesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: badgesCreateManySchoolsInputEnvelope
    set?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    disconnect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    delete?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    connect?: badgesWhereUniqueInput | badgesWhereUniqueInput[]
    update?: badgesUpdateWithWhereUniqueWithoutSchoolsInput | badgesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: badgesUpdateManyWithWhereWithoutSchoolsInput | badgesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: badgesScalarWhereInput | badgesScalarWhereInput[]
  }

  export type challengesUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput> | challengesCreateWithoutSchoolsInput[] | challengesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutSchoolsInput | challengesCreateOrConnectWithoutSchoolsInput[]
    upsert?: challengesUpsertWithWhereUniqueWithoutSchoolsInput | challengesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: challengesCreateManySchoolsInputEnvelope
    set?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    disconnect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    delete?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    update?: challengesUpdateWithWhereUniqueWithoutSchoolsInput | challengesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: challengesUpdateManyWithWhereWithoutSchoolsInput | challengesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: challengesScalarWhereInput | challengesScalarWhereInput[]
  }

  export type habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput> | habit_logsCreateWithoutSchoolsInput[] | habit_logsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutSchoolsInput | habit_logsCreateOrConnectWithoutSchoolsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutSchoolsInput | habit_logsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: habit_logsCreateManySchoolsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutSchoolsInput | habit_logsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutSchoolsInput | habit_logsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type habitsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput> | habitsCreateWithoutSchoolsInput[] | habitsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: habitsCreateOrConnectWithoutSchoolsInput | habitsCreateOrConnectWithoutSchoolsInput[]
    upsert?: habitsUpsertWithWhereUniqueWithoutSchoolsInput | habitsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: habitsCreateManySchoolsInputEnvelope
    set?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    disconnect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    delete?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    connect?: habitsWhereUniqueInput | habitsWhereUniqueInput[]
    update?: habitsUpdateWithWhereUniqueWithoutSchoolsInput | habitsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: habitsUpdateManyWithWhereWithoutSchoolsInput | habitsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: habitsScalarWhereInput | habitsScalarWhereInput[]
  }

  export type lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput> | lesson_plansCreateWithoutSchoolsInput[] | lesson_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutSchoolsInput | lesson_plansCreateOrConnectWithoutSchoolsInput[]
    upsert?: lesson_plansUpsertWithWhereUniqueWithoutSchoolsInput | lesson_plansUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: lesson_plansCreateManySchoolsInputEnvelope
    set?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    disconnect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    delete?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    update?: lesson_plansUpdateWithWhereUniqueWithoutSchoolsInput | lesson_plansUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: lesson_plansUpdateManyWithWhereWithoutSchoolsInput | lesson_plansUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
  }

  export type mistakesUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput> | mistakesCreateWithoutSchoolsInput[] | mistakesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutSchoolsInput | mistakesCreateOrConnectWithoutSchoolsInput[]
    upsert?: mistakesUpsertWithWhereUniqueWithoutSchoolsInput | mistakesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: mistakesCreateManySchoolsInputEnvelope
    set?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    disconnect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    delete?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    update?: mistakesUpdateWithWhereUniqueWithoutSchoolsInput | mistakesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: mistakesUpdateManyWithWhereWithoutSchoolsInput | mistakesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
  }

  export type parentsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput> | parentsCreateWithoutSchoolsInput[] | parentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: parentsCreateOrConnectWithoutSchoolsInput | parentsCreateOrConnectWithoutSchoolsInput[]
    upsert?: parentsUpsertWithWhereUniqueWithoutSchoolsInput | parentsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: parentsCreateManySchoolsInputEnvelope
    set?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    disconnect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    delete?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    connect?: parentsWhereUniqueInput | parentsWhereUniqueInput[]
    update?: parentsUpdateWithWhereUniqueWithoutSchoolsInput | parentsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: parentsUpdateManyWithWhereWithoutSchoolsInput | parentsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: parentsScalarWhereInput | parentsScalarWhereInput[]
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput> | personalized_tutoring_plansCreateWithoutSchoolsInput[] | personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput | personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutSchoolsInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: personalized_tutoring_plansCreateManySchoolsInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutSchoolsInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutSchoolsInput | personalized_tutoring_plansUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput> | pk_matchesCreateWithoutSchoolsInput[] | pk_matchesUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutSchoolsInput | pk_matchesCreateOrConnectWithoutSchoolsInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutSchoolsInput | pk_matchesUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: pk_matchesCreateManySchoolsInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutSchoolsInput | pk_matchesUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutSchoolsInput | pk_matchesUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput> | reward_configsCreateWithoutSchoolsInput[] | reward_configsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: reward_configsCreateOrConnectWithoutSchoolsInput | reward_configsCreateOrConnectWithoutSchoolsInput[]
    upsert?: reward_configsUpsertWithWhereUniqueWithoutSchoolsInput | reward_configsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: reward_configsCreateManySchoolsInputEnvelope
    set?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    disconnect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    delete?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    connect?: reward_configsWhereUniqueInput | reward_configsWhereUniqueInput[]
    update?: reward_configsUpdateWithWhereUniqueWithoutSchoolsInput | reward_configsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: reward_configsUpdateManyWithWhereWithoutSchoolsInput | reward_configsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: reward_configsScalarWhereInput | reward_configsScalarWhereInput[]
  }

  export type student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput> | student_checkinsCreateWithoutSchoolsInput[] | student_checkinsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutSchoolsInput | student_checkinsCreateOrConnectWithoutSchoolsInput[]
    upsert?: student_checkinsUpsertWithWhereUniqueWithoutSchoolsInput | student_checkinsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: student_checkinsCreateManySchoolsInputEnvelope
    set?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    disconnect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    delete?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    update?: student_checkinsUpdateWithWhereUniqueWithoutSchoolsInput | student_checkinsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: student_checkinsUpdateManyWithWhereWithoutSchoolsInput | student_checkinsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput> | studentsCreateWithoutSchoolsInput[] | studentsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutSchoolsInput | studentsCreateOrConnectWithoutSchoolsInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutSchoolsInput | studentsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: studentsCreateManySchoolsInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutSchoolsInput | studentsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutSchoolsInput | studentsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput> | task_libraryCreateWithoutSchoolsInput[] | task_libraryUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_libraryCreateOrConnectWithoutSchoolsInput | task_libraryCreateOrConnectWithoutSchoolsInput[]
    upsert?: task_libraryUpsertWithWhereUniqueWithoutSchoolsInput | task_libraryUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: task_libraryCreateManySchoolsInputEnvelope
    set?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    disconnect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    delete?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    connect?: task_libraryWhereUniqueInput | task_libraryWhereUniqueInput[]
    update?: task_libraryUpdateWithWhereUniqueWithoutSchoolsInput | task_libraryUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: task_libraryUpdateManyWithWhereWithoutSchoolsInput | task_libraryUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: task_libraryScalarWhereInput | task_libraryScalarWhereInput[]
  }

  export type task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput> | task_recordsCreateWithoutSchoolsInput[] | task_recordsUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutSchoolsInput | task_recordsCreateOrConnectWithoutSchoolsInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutSchoolsInput | task_recordsUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: task_recordsCreateManySchoolsInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutSchoolsInput | task_recordsUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutSchoolsInput | task_recordsUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type teachersUncheckedUpdateManyWithoutSchoolsNestedInput = {
    create?: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput> | teachersCreateWithoutSchoolsInput[] | teachersUncheckedCreateWithoutSchoolsInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutSchoolsInput | teachersCreateOrConnectWithoutSchoolsInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutSchoolsInput | teachersUpsertWithWhereUniqueWithoutSchoolsInput[]
    createMany?: teachersCreateManySchoolsInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutSchoolsInput | teachersUpdateWithWhereUniqueWithoutSchoolsInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutSchoolsInput | teachersUpdateManyWithWhereWithoutSchoolsInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type badgesCreateNestedOneWithoutStudent_badgesInput = {
    create?: XOR<badgesCreateWithoutStudent_badgesInput, badgesUncheckedCreateWithoutStudent_badgesInput>
    connectOrCreate?: badgesCreateOrConnectWithoutStudent_badgesInput
    connect?: badgesWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutStudent_badgesInput = {
    create?: XOR<studentsCreateWithoutStudent_badgesInput, studentsUncheckedCreateWithoutStudent_badgesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_badgesInput
    connect?: studentsWhereUniqueInput
  }

  export type badgesUpdateOneRequiredWithoutStudent_badgesNestedInput = {
    create?: XOR<badgesCreateWithoutStudent_badgesInput, badgesUncheckedCreateWithoutStudent_badgesInput>
    connectOrCreate?: badgesCreateOrConnectWithoutStudent_badgesInput
    upsert?: badgesUpsertWithoutStudent_badgesInput
    connect?: badgesWhereUniqueInput
    update?: XOR<XOR<badgesUpdateToOneWithWhereWithoutStudent_badgesInput, badgesUpdateWithoutStudent_badgesInput>, badgesUncheckedUpdateWithoutStudent_badgesInput>
  }

  export type studentsUpdateOneRequiredWithoutStudent_badgesNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_badgesInput, studentsUncheckedCreateWithoutStudent_badgesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_badgesInput
    upsert?: studentsUpsertWithoutStudent_badgesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_badgesInput, studentsUpdateWithoutStudent_badgesInput>, studentsUncheckedUpdateWithoutStudent_badgesInput>
  }

  export type campaignsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput> | campaignsCreateWithoutStudentsInput[] | campaignsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: campaignsCreateOrConnectWithoutStudentsInput | campaignsCreateOrConnectWithoutStudentsInput[]
    createMany?: campaignsCreateManyStudentsInputEnvelope
    connect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
  }

  export type challenge_participantsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput> | challenge_participantsCreateWithoutStudentsInput[] | challenge_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutStudentsInput | challenge_participantsCreateOrConnectWithoutStudentsInput[]
    createMany?: challenge_participantsCreateManyStudentsInputEnvelope
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
  }

  export type daily_summariesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput> | daily_summariesCreateWithoutStudentsInput[] | daily_summariesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutStudentsInput | daily_summariesCreateOrConnectWithoutStudentsInput[]
    createMany?: daily_summariesCreateManyStudentsInputEnvelope
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
  }

  export type habit_logsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput> | habit_logsCreateWithoutStudentsInput[] | habit_logsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutStudentsInput | habit_logsCreateOrConnectWithoutStudentsInput[]
    createMany?: habit_logsCreateManyStudentsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type mistakesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput> | mistakesCreateWithoutStudentsInput[] | mistakesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutStudentsInput | mistakesCreateOrConnectWithoutStudentsInput[]
    createMany?: mistakesCreateManyStudentsInputEnvelope
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
  }

  export type parent_student_bindingsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput> | parent_student_bindingsCreateWithoutStudentsInput[] | parent_student_bindingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutStudentsInput | parent_student_bindingsCreateOrConnectWithoutStudentsInput[]
    createMany?: parent_student_bindingsCreateManyStudentsInputEnvelope
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
  }

  export type personalized_tutoring_plansCreateNestedManyWithoutStudentsInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput> | personalized_tutoring_plansCreateWithoutStudentsInput[] | personalized_tutoring_plansUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutStudentsInput | personalized_tutoring_plansCreateOrConnectWithoutStudentsInput[]
    createMany?: personalized_tutoring_plansCreateManyStudentsInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type pk_matchesCreateNestedManyWithoutPlayerAInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput> | pk_matchesCreateWithoutPlayerAInput[] | pk_matchesUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerAInput | pk_matchesCreateOrConnectWithoutPlayerAInput[]
    createMany?: pk_matchesCreateManyPlayerAInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type pk_matchesCreateNestedManyWithoutPlayerBInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput> | pk_matchesCreateWithoutPlayerBInput[] | pk_matchesUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerBInput | pk_matchesCreateOrConnectWithoutPlayerBInput[]
    createMany?: pk_matchesCreateManyPlayerBInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type pk_matchesCreateNestedManyWithoutWinnerInput = {
    create?: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput> | pk_matchesCreateWithoutWinnerInput[] | pk_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutWinnerInput | pk_matchesCreateOrConnectWithoutWinnerInput[]
    createMany?: pk_matchesCreateManyWinnerInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type student_badgesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput> | student_badgesCreateWithoutStudentsInput[] | student_badgesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutStudentsInput | student_badgesCreateOrConnectWithoutStudentsInput[]
    createMany?: student_badgesCreateManyStudentsInputEnvelope
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
  }

  export type student_checkinsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput> | student_checkinsCreateWithoutStudentsInput[] | student_checkinsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutStudentsInput | student_checkinsCreateOrConnectWithoutStudentsInput[]
    createMany?: student_checkinsCreateManyStudentsInputEnvelope
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
  }

  export type schoolsCreateNestedOneWithoutStudentsInput = {
    create?: XOR<schoolsCreateWithoutStudentsInput, schoolsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutStudentsInput
    connect?: schoolsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutStudentsInput = {
    create?: XOR<teachersCreateWithoutStudentsInput, teachersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutStudentsInput
    connect?: teachersWhereUniqueInput
  }

  export type task_recordsCreateNestedManyWithoutStudentsInput = {
    create?: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput> | task_recordsCreateWithoutStudentsInput[] | task_recordsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutStudentsInput | task_recordsCreateOrConnectWithoutStudentsInput[]
    createMany?: task_recordsCreateManyStudentsInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type campaignsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput> | campaignsCreateWithoutStudentsInput[] | campaignsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: campaignsCreateOrConnectWithoutStudentsInput | campaignsCreateOrConnectWithoutStudentsInput[]
    createMany?: campaignsCreateManyStudentsInputEnvelope
    connect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
  }

  export type challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput> | challenge_participantsCreateWithoutStudentsInput[] | challenge_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutStudentsInput | challenge_participantsCreateOrConnectWithoutStudentsInput[]
    createMany?: challenge_participantsCreateManyStudentsInputEnvelope
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
  }

  export type daily_summariesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput> | daily_summariesCreateWithoutStudentsInput[] | daily_summariesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutStudentsInput | daily_summariesCreateOrConnectWithoutStudentsInput[]
    createMany?: daily_summariesCreateManyStudentsInputEnvelope
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
  }

  export type habit_logsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput> | habit_logsCreateWithoutStudentsInput[] | habit_logsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutStudentsInput | habit_logsCreateOrConnectWithoutStudentsInput[]
    createMany?: habit_logsCreateManyStudentsInputEnvelope
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
  }

  export type mistakesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput> | mistakesCreateWithoutStudentsInput[] | mistakesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutStudentsInput | mistakesCreateOrConnectWithoutStudentsInput[]
    createMany?: mistakesCreateManyStudentsInputEnvelope
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
  }

  export type parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput> | parent_student_bindingsCreateWithoutStudentsInput[] | parent_student_bindingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutStudentsInput | parent_student_bindingsCreateOrConnectWithoutStudentsInput[]
    createMany?: parent_student_bindingsCreateManyStudentsInputEnvelope
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
  }

  export type personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput> | personalized_tutoring_plansCreateWithoutStudentsInput[] | personalized_tutoring_plansUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutStudentsInput | personalized_tutoring_plansCreateOrConnectWithoutStudentsInput[]
    createMany?: personalized_tutoring_plansCreateManyStudentsInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput> | pk_matchesCreateWithoutPlayerAInput[] | pk_matchesUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerAInput | pk_matchesCreateOrConnectWithoutPlayerAInput[]
    createMany?: pk_matchesCreateManyPlayerAInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput> | pk_matchesCreateWithoutPlayerBInput[] | pk_matchesUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerBInput | pk_matchesCreateOrConnectWithoutPlayerBInput[]
    createMany?: pk_matchesCreateManyPlayerBInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type pk_matchesUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput> | pk_matchesCreateWithoutWinnerInput[] | pk_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutWinnerInput | pk_matchesCreateOrConnectWithoutWinnerInput[]
    createMany?: pk_matchesCreateManyWinnerInputEnvelope
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
  }

  export type student_badgesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput> | student_badgesCreateWithoutStudentsInput[] | student_badgesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutStudentsInput | student_badgesCreateOrConnectWithoutStudentsInput[]
    createMany?: student_badgesCreateManyStudentsInputEnvelope
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
  }

  export type student_checkinsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput> | student_checkinsCreateWithoutStudentsInput[] | student_checkinsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutStudentsInput | student_checkinsCreateOrConnectWithoutStudentsInput[]
    createMany?: student_checkinsCreateManyStudentsInputEnvelope
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
  }

  export type task_recordsUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput> | task_recordsCreateWithoutStudentsInput[] | task_recordsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutStudentsInput | task_recordsCreateOrConnectWithoutStudentsInput[]
    createMany?: task_recordsCreateManyStudentsInputEnvelope
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
  }

  export type campaignsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput> | campaignsCreateWithoutStudentsInput[] | campaignsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: campaignsCreateOrConnectWithoutStudentsInput | campaignsCreateOrConnectWithoutStudentsInput[]
    upsert?: campaignsUpsertWithWhereUniqueWithoutStudentsInput | campaignsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: campaignsCreateManyStudentsInputEnvelope
    set?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    disconnect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    delete?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    connect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    update?: campaignsUpdateWithWhereUniqueWithoutStudentsInput | campaignsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: campaignsUpdateManyWithWhereWithoutStudentsInput | campaignsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: campaignsScalarWhereInput | campaignsScalarWhereInput[]
  }

  export type challenge_participantsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput> | challenge_participantsCreateWithoutStudentsInput[] | challenge_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutStudentsInput | challenge_participantsCreateOrConnectWithoutStudentsInput[]
    upsert?: challenge_participantsUpsertWithWhereUniqueWithoutStudentsInput | challenge_participantsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: challenge_participantsCreateManyStudentsInputEnvelope
    set?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    disconnect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    delete?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    update?: challenge_participantsUpdateWithWhereUniqueWithoutStudentsInput | challenge_participantsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: challenge_participantsUpdateManyWithWhereWithoutStudentsInput | challenge_participantsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
  }

  export type daily_summariesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput> | daily_summariesCreateWithoutStudentsInput[] | daily_summariesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutStudentsInput | daily_summariesCreateOrConnectWithoutStudentsInput[]
    upsert?: daily_summariesUpsertWithWhereUniqueWithoutStudentsInput | daily_summariesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: daily_summariesCreateManyStudentsInputEnvelope
    set?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    disconnect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    delete?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    update?: daily_summariesUpdateWithWhereUniqueWithoutStudentsInput | daily_summariesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: daily_summariesUpdateManyWithWhereWithoutStudentsInput | daily_summariesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
  }

  export type habit_logsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput> | habit_logsCreateWithoutStudentsInput[] | habit_logsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutStudentsInput | habit_logsCreateOrConnectWithoutStudentsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutStudentsInput | habit_logsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: habit_logsCreateManyStudentsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutStudentsInput | habit_logsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutStudentsInput | habit_logsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type mistakesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput> | mistakesCreateWithoutStudentsInput[] | mistakesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutStudentsInput | mistakesCreateOrConnectWithoutStudentsInput[]
    upsert?: mistakesUpsertWithWhereUniqueWithoutStudentsInput | mistakesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: mistakesCreateManyStudentsInputEnvelope
    set?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    disconnect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    delete?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    update?: mistakesUpdateWithWhereUniqueWithoutStudentsInput | mistakesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: mistakesUpdateManyWithWhereWithoutStudentsInput | mistakesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
  }

  export type parent_student_bindingsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput> | parent_student_bindingsCreateWithoutStudentsInput[] | parent_student_bindingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutStudentsInput | parent_student_bindingsCreateOrConnectWithoutStudentsInput[]
    upsert?: parent_student_bindingsUpsertWithWhereUniqueWithoutStudentsInput | parent_student_bindingsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: parent_student_bindingsCreateManyStudentsInputEnvelope
    set?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    disconnect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    delete?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    update?: parent_student_bindingsUpdateWithWhereUniqueWithoutStudentsInput | parent_student_bindingsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: parent_student_bindingsUpdateManyWithWhereWithoutStudentsInput | parent_student_bindingsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
  }

  export type personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput> | personalized_tutoring_plansCreateWithoutStudentsInput[] | personalized_tutoring_plansUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutStudentsInput | personalized_tutoring_plansCreateOrConnectWithoutStudentsInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutStudentsInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: personalized_tutoring_plansCreateManyStudentsInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutStudentsInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutStudentsInput | personalized_tutoring_plansUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type pk_matchesUpdateManyWithoutPlayerANestedInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput> | pk_matchesCreateWithoutPlayerAInput[] | pk_matchesUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerAInput | pk_matchesCreateOrConnectWithoutPlayerAInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutPlayerAInput | pk_matchesUpsertWithWhereUniqueWithoutPlayerAInput[]
    createMany?: pk_matchesCreateManyPlayerAInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutPlayerAInput | pk_matchesUpdateWithWhereUniqueWithoutPlayerAInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutPlayerAInput | pk_matchesUpdateManyWithWhereWithoutPlayerAInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type pk_matchesUpdateManyWithoutPlayerBNestedInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput> | pk_matchesCreateWithoutPlayerBInput[] | pk_matchesUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerBInput | pk_matchesCreateOrConnectWithoutPlayerBInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutPlayerBInput | pk_matchesUpsertWithWhereUniqueWithoutPlayerBInput[]
    createMany?: pk_matchesCreateManyPlayerBInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutPlayerBInput | pk_matchesUpdateWithWhereUniqueWithoutPlayerBInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutPlayerBInput | pk_matchesUpdateManyWithWhereWithoutPlayerBInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type pk_matchesUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput> | pk_matchesCreateWithoutWinnerInput[] | pk_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutWinnerInput | pk_matchesCreateOrConnectWithoutWinnerInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutWinnerInput | pk_matchesUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: pk_matchesCreateManyWinnerInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutWinnerInput | pk_matchesUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutWinnerInput | pk_matchesUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type student_badgesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput> | student_badgesCreateWithoutStudentsInput[] | student_badgesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutStudentsInput | student_badgesCreateOrConnectWithoutStudentsInput[]
    upsert?: student_badgesUpsertWithWhereUniqueWithoutStudentsInput | student_badgesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_badgesCreateManyStudentsInputEnvelope
    set?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    disconnect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    delete?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    update?: student_badgesUpdateWithWhereUniqueWithoutStudentsInput | student_badgesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_badgesUpdateManyWithWhereWithoutStudentsInput | student_badgesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
  }

  export type student_checkinsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput> | student_checkinsCreateWithoutStudentsInput[] | student_checkinsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutStudentsInput | student_checkinsCreateOrConnectWithoutStudentsInput[]
    upsert?: student_checkinsUpsertWithWhereUniqueWithoutStudentsInput | student_checkinsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_checkinsCreateManyStudentsInputEnvelope
    set?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    disconnect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    delete?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    update?: student_checkinsUpdateWithWhereUniqueWithoutStudentsInput | student_checkinsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_checkinsUpdateManyWithWhereWithoutStudentsInput | student_checkinsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
  }

  export type schoolsUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<schoolsCreateWithoutStudentsInput, schoolsUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutStudentsInput
    upsert?: schoolsUpsertWithoutStudentsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutStudentsInput, schoolsUpdateWithoutStudentsInput>, schoolsUncheckedUpdateWithoutStudentsInput>
  }

  export type teachersUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<teachersCreateWithoutStudentsInput, teachersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutStudentsInput
    upsert?: teachersUpsertWithoutStudentsInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutStudentsInput, teachersUpdateWithoutStudentsInput>, teachersUncheckedUpdateWithoutStudentsInput>
  }

  export type task_recordsUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput> | task_recordsCreateWithoutStudentsInput[] | task_recordsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutStudentsInput | task_recordsCreateOrConnectWithoutStudentsInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutStudentsInput | task_recordsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: task_recordsCreateManyStudentsInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutStudentsInput | task_recordsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutStudentsInput | task_recordsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type campaignsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput> | campaignsCreateWithoutStudentsInput[] | campaignsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: campaignsCreateOrConnectWithoutStudentsInput | campaignsCreateOrConnectWithoutStudentsInput[]
    upsert?: campaignsUpsertWithWhereUniqueWithoutStudentsInput | campaignsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: campaignsCreateManyStudentsInputEnvelope
    set?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    disconnect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    delete?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    connect?: campaignsWhereUniqueInput | campaignsWhereUniqueInput[]
    update?: campaignsUpdateWithWhereUniqueWithoutStudentsInput | campaignsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: campaignsUpdateManyWithWhereWithoutStudentsInput | campaignsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: campaignsScalarWhereInput | campaignsScalarWhereInput[]
  }

  export type challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput> | challenge_participantsCreateWithoutStudentsInput[] | challenge_participantsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: challenge_participantsCreateOrConnectWithoutStudentsInput | challenge_participantsCreateOrConnectWithoutStudentsInput[]
    upsert?: challenge_participantsUpsertWithWhereUniqueWithoutStudentsInput | challenge_participantsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: challenge_participantsCreateManyStudentsInputEnvelope
    set?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    disconnect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    delete?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    connect?: challenge_participantsWhereUniqueInput | challenge_participantsWhereUniqueInput[]
    update?: challenge_participantsUpdateWithWhereUniqueWithoutStudentsInput | challenge_participantsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: challenge_participantsUpdateManyWithWhereWithoutStudentsInput | challenge_participantsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
  }

  export type daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput> | daily_summariesCreateWithoutStudentsInput[] | daily_summariesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutStudentsInput | daily_summariesCreateOrConnectWithoutStudentsInput[]
    upsert?: daily_summariesUpsertWithWhereUniqueWithoutStudentsInput | daily_summariesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: daily_summariesCreateManyStudentsInputEnvelope
    set?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    disconnect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    delete?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    update?: daily_summariesUpdateWithWhereUniqueWithoutStudentsInput | daily_summariesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: daily_summariesUpdateManyWithWhereWithoutStudentsInput | daily_summariesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
  }

  export type habit_logsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput> | habit_logsCreateWithoutStudentsInput[] | habit_logsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: habit_logsCreateOrConnectWithoutStudentsInput | habit_logsCreateOrConnectWithoutStudentsInput[]
    upsert?: habit_logsUpsertWithWhereUniqueWithoutStudentsInput | habit_logsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: habit_logsCreateManyStudentsInputEnvelope
    set?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    disconnect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    delete?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    connect?: habit_logsWhereUniqueInput | habit_logsWhereUniqueInput[]
    update?: habit_logsUpdateWithWhereUniqueWithoutStudentsInput | habit_logsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: habit_logsUpdateManyWithWhereWithoutStudentsInput | habit_logsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
  }

  export type mistakesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput> | mistakesCreateWithoutStudentsInput[] | mistakesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: mistakesCreateOrConnectWithoutStudentsInput | mistakesCreateOrConnectWithoutStudentsInput[]
    upsert?: mistakesUpsertWithWhereUniqueWithoutStudentsInput | mistakesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: mistakesCreateManyStudentsInputEnvelope
    set?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    disconnect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    delete?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    connect?: mistakesWhereUniqueInput | mistakesWhereUniqueInput[]
    update?: mistakesUpdateWithWhereUniqueWithoutStudentsInput | mistakesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: mistakesUpdateManyWithWhereWithoutStudentsInput | mistakesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
  }

  export type parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput> | parent_student_bindingsCreateWithoutStudentsInput[] | parent_student_bindingsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutStudentsInput | parent_student_bindingsCreateOrConnectWithoutStudentsInput[]
    upsert?: parent_student_bindingsUpsertWithWhereUniqueWithoutStudentsInput | parent_student_bindingsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: parent_student_bindingsCreateManyStudentsInputEnvelope
    set?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    disconnect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    delete?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    update?: parent_student_bindingsUpdateWithWhereUniqueWithoutStudentsInput | parent_student_bindingsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: parent_student_bindingsUpdateManyWithWhereWithoutStudentsInput | parent_student_bindingsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput> | personalized_tutoring_plansCreateWithoutStudentsInput[] | personalized_tutoring_plansUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutStudentsInput | personalized_tutoring_plansCreateOrConnectWithoutStudentsInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutStudentsInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: personalized_tutoring_plansCreateManyStudentsInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutStudentsInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutStudentsInput | personalized_tutoring_plansUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput> | pk_matchesCreateWithoutPlayerAInput[] | pk_matchesUncheckedCreateWithoutPlayerAInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerAInput | pk_matchesCreateOrConnectWithoutPlayerAInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutPlayerAInput | pk_matchesUpsertWithWhereUniqueWithoutPlayerAInput[]
    createMany?: pk_matchesCreateManyPlayerAInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutPlayerAInput | pk_matchesUpdateWithWhereUniqueWithoutPlayerAInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutPlayerAInput | pk_matchesUpdateManyWithWhereWithoutPlayerAInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput = {
    create?: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput> | pk_matchesCreateWithoutPlayerBInput[] | pk_matchesUncheckedCreateWithoutPlayerBInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutPlayerBInput | pk_matchesCreateOrConnectWithoutPlayerBInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutPlayerBInput | pk_matchesUpsertWithWhereUniqueWithoutPlayerBInput[]
    createMany?: pk_matchesCreateManyPlayerBInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutPlayerBInput | pk_matchesUpdateWithWhereUniqueWithoutPlayerBInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutPlayerBInput | pk_matchesUpdateManyWithWhereWithoutPlayerBInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput> | pk_matchesCreateWithoutWinnerInput[] | pk_matchesUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: pk_matchesCreateOrConnectWithoutWinnerInput | pk_matchesCreateOrConnectWithoutWinnerInput[]
    upsert?: pk_matchesUpsertWithWhereUniqueWithoutWinnerInput | pk_matchesUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: pk_matchesCreateManyWinnerInputEnvelope
    set?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    disconnect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    delete?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    connect?: pk_matchesWhereUniqueInput | pk_matchesWhereUniqueInput[]
    update?: pk_matchesUpdateWithWhereUniqueWithoutWinnerInput | pk_matchesUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: pk_matchesUpdateManyWithWhereWithoutWinnerInput | pk_matchesUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
  }

  export type student_badgesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput> | student_badgesCreateWithoutStudentsInput[] | student_badgesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_badgesCreateOrConnectWithoutStudentsInput | student_badgesCreateOrConnectWithoutStudentsInput[]
    upsert?: student_badgesUpsertWithWhereUniqueWithoutStudentsInput | student_badgesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_badgesCreateManyStudentsInputEnvelope
    set?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    disconnect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    delete?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    connect?: student_badgesWhereUniqueInput | student_badgesWhereUniqueInput[]
    update?: student_badgesUpdateWithWhereUniqueWithoutStudentsInput | student_badgesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_badgesUpdateManyWithWhereWithoutStudentsInput | student_badgesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
  }

  export type student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput> | student_checkinsCreateWithoutStudentsInput[] | student_checkinsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_checkinsCreateOrConnectWithoutStudentsInput | student_checkinsCreateOrConnectWithoutStudentsInput[]
    upsert?: student_checkinsUpsertWithWhereUniqueWithoutStudentsInput | student_checkinsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_checkinsCreateManyStudentsInputEnvelope
    set?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    disconnect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    delete?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    connect?: student_checkinsWhereUniqueInput | student_checkinsWhereUniqueInput[]
    update?: student_checkinsUpdateWithWhereUniqueWithoutStudentsInput | student_checkinsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_checkinsUpdateManyWithWhereWithoutStudentsInput | student_checkinsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
  }

  export type task_recordsUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput> | task_recordsCreateWithoutStudentsInput[] | task_recordsUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: task_recordsCreateOrConnectWithoutStudentsInput | task_recordsCreateOrConnectWithoutStudentsInput[]
    upsert?: task_recordsUpsertWithWhereUniqueWithoutStudentsInput | task_recordsUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: task_recordsCreateManyStudentsInputEnvelope
    set?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    disconnect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    delete?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    connect?: task_recordsWhereUniqueInput | task_recordsWhereUniqueInput[]
    update?: task_recordsUpdateWithWhereUniqueWithoutStudentsInput | task_recordsUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: task_recordsUpdateManyWithWhereWithoutStudentsInput | task_recordsUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
  }

  export type schoolsCreateNestedOneWithoutStudent_checkinsInput = {
    create?: XOR<schoolsCreateWithoutStudent_checkinsInput, schoolsUncheckedCreateWithoutStudent_checkinsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutStudent_checkinsInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutStudent_checkinsInput = {
    create?: XOR<studentsCreateWithoutStudent_checkinsInput, studentsUncheckedCreateWithoutStudent_checkinsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_checkinsInput
    connect?: studentsWhereUniqueInput
  }

  export type schoolsUpdateOneRequiredWithoutStudent_checkinsNestedInput = {
    create?: XOR<schoolsCreateWithoutStudent_checkinsInput, schoolsUncheckedCreateWithoutStudent_checkinsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutStudent_checkinsInput
    upsert?: schoolsUpsertWithoutStudent_checkinsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutStudent_checkinsInput, schoolsUpdateWithoutStudent_checkinsInput>, schoolsUncheckedUpdateWithoutStudent_checkinsInput>
  }

  export type studentsUpdateOneRequiredWithoutStudent_checkinsNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_checkinsInput, studentsUncheckedCreateWithoutStudent_checkinsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_checkinsInput
    upsert?: studentsUpsertWithoutStudent_checkinsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_checkinsInput, studentsUpdateWithoutStudent_checkinsInput>, studentsUncheckedUpdateWithoutStudent_checkinsInput>
  }

  export type schoolsCreateNestedOneWithoutTask_libraryInput = {
    create?: XOR<schoolsCreateWithoutTask_libraryInput, schoolsUncheckedCreateWithoutTask_libraryInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTask_libraryInput
    connect?: schoolsWhereUniqueInput
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type schoolsUpdateOneRequiredWithoutTask_libraryNestedInput = {
    create?: XOR<schoolsCreateWithoutTask_libraryInput, schoolsUncheckedCreateWithoutTask_libraryInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTask_libraryInput
    upsert?: schoolsUpsertWithoutTask_libraryInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutTask_libraryInput, schoolsUpdateWithoutTask_libraryInput>, schoolsUncheckedUpdateWithoutTask_libraryInput>
  }

  export type lesson_plansCreateNestedOneWithoutTask_recordsInput = {
    create?: XOR<lesson_plansCreateWithoutTask_recordsInput, lesson_plansUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTask_recordsInput
    connect?: lesson_plansWhereUniqueInput
  }

  export type schoolsCreateNestedOneWithoutTask_recordsInput = {
    create?: XOR<schoolsCreateWithoutTask_recordsInput, schoolsUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTask_recordsInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutTask_recordsInput = {
    create?: XOR<studentsCreateWithoutTask_recordsInput, studentsUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutTask_recordsInput
    connect?: studentsWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumTaskCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TaskCategory
  }

  export type lesson_plansUpdateOneWithoutTask_recordsNestedInput = {
    create?: XOR<lesson_plansCreateWithoutTask_recordsInput, lesson_plansUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTask_recordsInput
    upsert?: lesson_plansUpsertWithoutTask_recordsInput
    disconnect?: lesson_plansWhereInput | boolean
    delete?: lesson_plansWhereInput | boolean
    connect?: lesson_plansWhereUniqueInput
    update?: XOR<XOR<lesson_plansUpdateToOneWithWhereWithoutTask_recordsInput, lesson_plansUpdateWithoutTask_recordsInput>, lesson_plansUncheckedUpdateWithoutTask_recordsInput>
  }

  export type schoolsUpdateOneRequiredWithoutTask_recordsNestedInput = {
    create?: XOR<schoolsCreateWithoutTask_recordsInput, schoolsUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTask_recordsInput
    upsert?: schoolsUpsertWithoutTask_recordsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutTask_recordsInput, schoolsUpdateWithoutTask_recordsInput>, schoolsUncheckedUpdateWithoutTask_recordsInput>
  }

  export type studentsUpdateOneRequiredWithoutTask_recordsNestedInput = {
    create?: XOR<studentsCreateWithoutTask_recordsInput, studentsUncheckedCreateWithoutTask_recordsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutTask_recordsInput
    upsert?: studentsUpsertWithoutTask_recordsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutTask_recordsInput, studentsUpdateWithoutTask_recordsInput>, studentsUncheckedUpdateWithoutTask_recordsInput>
  }

  export type challengesCreateNestedManyWithoutTeachersInput = {
    create?: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput> | challengesCreateWithoutTeachersInput[] | challengesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutTeachersInput | challengesCreateOrConnectWithoutTeachersInput[]
    createMany?: challengesCreateManyTeachersInputEnvelope
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
  }

  export type lesson_plansCreateNestedManyWithoutTeachersInput = {
    create?: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput> | lesson_plansCreateWithoutTeachersInput[] | lesson_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTeachersInput | lesson_plansCreateOrConnectWithoutTeachersInput[]
    createMany?: lesson_plansCreateManyTeachersInputEnvelope
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
  }

  export type personalized_tutoring_plansCreateNestedManyWithoutTeachersInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput> | personalized_tutoring_plansCreateWithoutTeachersInput[] | personalized_tutoring_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutTeachersInput | personalized_tutoring_plansCreateOrConnectWithoutTeachersInput[]
    createMany?: personalized_tutoring_plansCreateManyTeachersInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput> | studentsCreateWithoutTeachersInput[] | studentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutTeachersInput | studentsCreateOrConnectWithoutTeachersInput[]
    createMany?: studentsCreateManyTeachersInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type schoolsCreateNestedOneWithoutTeachersInput = {
    create?: XOR<schoolsCreateWithoutTeachersInput, schoolsUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTeachersInput
    connect?: schoolsWhereUniqueInput
  }

  export type challengesUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput> | challengesCreateWithoutTeachersInput[] | challengesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutTeachersInput | challengesCreateOrConnectWithoutTeachersInput[]
    createMany?: challengesCreateManyTeachersInputEnvelope
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
  }

  export type lesson_plansUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput> | lesson_plansCreateWithoutTeachersInput[] | lesson_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTeachersInput | lesson_plansCreateOrConnectWithoutTeachersInput[]
    createMany?: lesson_plansCreateManyTeachersInputEnvelope
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
  }

  export type personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput> | personalized_tutoring_plansCreateWithoutTeachersInput[] | personalized_tutoring_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutTeachersInput | personalized_tutoring_plansCreateOrConnectWithoutTeachersInput[]
    createMany?: personalized_tutoring_plansCreateManyTeachersInputEnvelope
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput> | studentsCreateWithoutTeachersInput[] | studentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutTeachersInput | studentsCreateOrConnectWithoutTeachersInput[]
    createMany?: studentsCreateManyTeachersInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type challengesUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput> | challengesCreateWithoutTeachersInput[] | challengesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutTeachersInput | challengesCreateOrConnectWithoutTeachersInput[]
    upsert?: challengesUpsertWithWhereUniqueWithoutTeachersInput | challengesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: challengesCreateManyTeachersInputEnvelope
    set?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    disconnect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    delete?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    update?: challengesUpdateWithWhereUniqueWithoutTeachersInput | challengesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: challengesUpdateManyWithWhereWithoutTeachersInput | challengesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: challengesScalarWhereInput | challengesScalarWhereInput[]
  }

  export type lesson_plansUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput> | lesson_plansCreateWithoutTeachersInput[] | lesson_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTeachersInput | lesson_plansCreateOrConnectWithoutTeachersInput[]
    upsert?: lesson_plansUpsertWithWhereUniqueWithoutTeachersInput | lesson_plansUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: lesson_plansCreateManyTeachersInputEnvelope
    set?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    disconnect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    delete?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    update?: lesson_plansUpdateWithWhereUniqueWithoutTeachersInput | lesson_plansUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: lesson_plansUpdateManyWithWhereWithoutTeachersInput | lesson_plansUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
  }

  export type personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput> | personalized_tutoring_plansCreateWithoutTeachersInput[] | personalized_tutoring_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutTeachersInput | personalized_tutoring_plansCreateOrConnectWithoutTeachersInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutTeachersInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: personalized_tutoring_plansCreateManyTeachersInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutTeachersInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutTeachersInput | personalized_tutoring_plansUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput> | studentsCreateWithoutTeachersInput[] | studentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutTeachersInput | studentsCreateOrConnectWithoutTeachersInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutTeachersInput | studentsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: studentsCreateManyTeachersInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutTeachersInput | studentsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutTeachersInput | studentsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type schoolsUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<schoolsCreateWithoutTeachersInput, schoolsUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutTeachersInput
    upsert?: schoolsUpsertWithoutTeachersInput
    disconnect?: schoolsWhereInput | boolean
    delete?: schoolsWhereInput | boolean
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutTeachersInput, schoolsUpdateWithoutTeachersInput>, schoolsUncheckedUpdateWithoutTeachersInput>
  }

  export type challengesUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput> | challengesCreateWithoutTeachersInput[] | challengesUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: challengesCreateOrConnectWithoutTeachersInput | challengesCreateOrConnectWithoutTeachersInput[]
    upsert?: challengesUpsertWithWhereUniqueWithoutTeachersInput | challengesUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: challengesCreateManyTeachersInputEnvelope
    set?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    disconnect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    delete?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    connect?: challengesWhereUniqueInput | challengesWhereUniqueInput[]
    update?: challengesUpdateWithWhereUniqueWithoutTeachersInput | challengesUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: challengesUpdateManyWithWhereWithoutTeachersInput | challengesUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: challengesScalarWhereInput | challengesScalarWhereInput[]
  }

  export type lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput> | lesson_plansCreateWithoutTeachersInput[] | lesson_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: lesson_plansCreateOrConnectWithoutTeachersInput | lesson_plansCreateOrConnectWithoutTeachersInput[]
    upsert?: lesson_plansUpsertWithWhereUniqueWithoutTeachersInput | lesson_plansUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: lesson_plansCreateManyTeachersInputEnvelope
    set?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    disconnect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    delete?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    connect?: lesson_plansWhereUniqueInput | lesson_plansWhereUniqueInput[]
    update?: lesson_plansUpdateWithWhereUniqueWithoutTeachersInput | lesson_plansUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: lesson_plansUpdateManyWithWhereWithoutTeachersInput | lesson_plansUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput> | personalized_tutoring_plansCreateWithoutTeachersInput[] | personalized_tutoring_plansUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: personalized_tutoring_plansCreateOrConnectWithoutTeachersInput | personalized_tutoring_plansCreateOrConnectWithoutTeachersInput[]
    upsert?: personalized_tutoring_plansUpsertWithWhereUniqueWithoutTeachersInput | personalized_tutoring_plansUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: personalized_tutoring_plansCreateManyTeachersInputEnvelope
    set?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    disconnect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    delete?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    connect?: personalized_tutoring_plansWhereUniqueInput | personalized_tutoring_plansWhereUniqueInput[]
    update?: personalized_tutoring_plansUpdateWithWhereUniqueWithoutTeachersInput | personalized_tutoring_plansUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: personalized_tutoring_plansUpdateManyWithWhereWithoutTeachersInput | personalized_tutoring_plansUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput> | studentsCreateWithoutTeachersInput[] | studentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutTeachersInput | studentsCreateOrConnectWithoutTeachersInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutTeachersInput | studentsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: studentsCreateManyTeachersInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutTeachersInput | studentsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutTeachersInput | studentsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type schoolsCreateNestedOneWithoutPersonalized_tutoring_plansInput = {
    create?: XOR<schoolsCreateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutPersonalized_tutoring_plansInput
    connect?: schoolsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutPersonalized_tutoring_plansInput = {
    create?: XOR<studentsCreateWithoutPersonalized_tutoring_plansInput, studentsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPersonalized_tutoring_plansInput
    connect?: studentsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutPersonalized_tutoring_plansInput = {
    create?: XOR<teachersCreateWithoutPersonalized_tutoring_plansInput, teachersUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: teachersCreateOrConnectWithoutPersonalized_tutoring_plansInput
    connect?: teachersWhereUniqueInput
  }

  export type schoolsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput = {
    create?: XOR<schoolsCreateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutPersonalized_tutoring_plansInput
    upsert?: schoolsUpsertWithoutPersonalized_tutoring_plansInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput, schoolsUpdateWithoutPersonalized_tutoring_plansInput>, schoolsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type studentsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput = {
    create?: XOR<studentsCreateWithoutPersonalized_tutoring_plansInput, studentsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: studentsCreateOrConnectWithoutPersonalized_tutoring_plansInput
    upsert?: studentsUpsertWithoutPersonalized_tutoring_plansInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput, studentsUpdateWithoutPersonalized_tutoring_plansInput>, studentsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type teachersUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput = {
    create?: XOR<teachersCreateWithoutPersonalized_tutoring_plansInput, teachersUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    connectOrCreate?: teachersCreateOrConnectWithoutPersonalized_tutoring_plansInput
    upsert?: teachersUpsertWithoutPersonalized_tutoring_plansInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput, teachersUpdateWithoutPersonalized_tutoring_plansInput>, teachersUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type daily_summariesCreateNestedManyWithoutParentsInput = {
    create?: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput> | daily_summariesCreateWithoutParentsInput[] | daily_summariesUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutParentsInput | daily_summariesCreateOrConnectWithoutParentsInput[]
    createMany?: daily_summariesCreateManyParentsInputEnvelope
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
  }

  export type parent_student_bindingsCreateNestedManyWithoutParentsInput = {
    create?: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput> | parent_student_bindingsCreateWithoutParentsInput[] | parent_student_bindingsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutParentsInput | parent_student_bindingsCreateOrConnectWithoutParentsInput[]
    createMany?: parent_student_bindingsCreateManyParentsInputEnvelope
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
  }

  export type schoolsCreateNestedOneWithoutParentsInput = {
    create?: XOR<schoolsCreateWithoutParentsInput, schoolsUncheckedCreateWithoutParentsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutParentsInput
    connect?: schoolsWhereUniqueInput
  }

  export type daily_summariesUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput> | daily_summariesCreateWithoutParentsInput[] | daily_summariesUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutParentsInput | daily_summariesCreateOrConnectWithoutParentsInput[]
    createMany?: daily_summariesCreateManyParentsInputEnvelope
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
  }

  export type parent_student_bindingsUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput> | parent_student_bindingsCreateWithoutParentsInput[] | parent_student_bindingsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutParentsInput | parent_student_bindingsCreateOrConnectWithoutParentsInput[]
    createMany?: parent_student_bindingsCreateManyParentsInputEnvelope
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
  }

  export type daily_summariesUpdateManyWithoutParentsNestedInput = {
    create?: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput> | daily_summariesCreateWithoutParentsInput[] | daily_summariesUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutParentsInput | daily_summariesCreateOrConnectWithoutParentsInput[]
    upsert?: daily_summariesUpsertWithWhereUniqueWithoutParentsInput | daily_summariesUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: daily_summariesCreateManyParentsInputEnvelope
    set?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    disconnect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    delete?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    update?: daily_summariesUpdateWithWhereUniqueWithoutParentsInput | daily_summariesUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: daily_summariesUpdateManyWithWhereWithoutParentsInput | daily_summariesUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
  }

  export type parent_student_bindingsUpdateManyWithoutParentsNestedInput = {
    create?: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput> | parent_student_bindingsCreateWithoutParentsInput[] | parent_student_bindingsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutParentsInput | parent_student_bindingsCreateOrConnectWithoutParentsInput[]
    upsert?: parent_student_bindingsUpsertWithWhereUniqueWithoutParentsInput | parent_student_bindingsUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: parent_student_bindingsCreateManyParentsInputEnvelope
    set?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    disconnect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    delete?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    update?: parent_student_bindingsUpdateWithWhereUniqueWithoutParentsInput | parent_student_bindingsUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: parent_student_bindingsUpdateManyWithWhereWithoutParentsInput | parent_student_bindingsUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
  }

  export type schoolsUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<schoolsCreateWithoutParentsInput, schoolsUncheckedCreateWithoutParentsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutParentsInput
    upsert?: schoolsUpsertWithoutParentsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutParentsInput, schoolsUpdateWithoutParentsInput>, schoolsUncheckedUpdateWithoutParentsInput>
  }

  export type daily_summariesUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput> | daily_summariesCreateWithoutParentsInput[] | daily_summariesUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: daily_summariesCreateOrConnectWithoutParentsInput | daily_summariesCreateOrConnectWithoutParentsInput[]
    upsert?: daily_summariesUpsertWithWhereUniqueWithoutParentsInput | daily_summariesUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: daily_summariesCreateManyParentsInputEnvelope
    set?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    disconnect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    delete?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    connect?: daily_summariesWhereUniqueInput | daily_summariesWhereUniqueInput[]
    update?: daily_summariesUpdateWithWhereUniqueWithoutParentsInput | daily_summariesUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: daily_summariesUpdateManyWithWhereWithoutParentsInput | daily_summariesUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
  }

  export type parent_student_bindingsUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput> | parent_student_bindingsCreateWithoutParentsInput[] | parent_student_bindingsUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: parent_student_bindingsCreateOrConnectWithoutParentsInput | parent_student_bindingsCreateOrConnectWithoutParentsInput[]
    upsert?: parent_student_bindingsUpsertWithWhereUniqueWithoutParentsInput | parent_student_bindingsUpsertWithWhereUniqueWithoutParentsInput[]
    createMany?: parent_student_bindingsCreateManyParentsInputEnvelope
    set?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    disconnect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    delete?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    connect?: parent_student_bindingsWhereUniqueInput | parent_student_bindingsWhereUniqueInput[]
    update?: parent_student_bindingsUpdateWithWhereUniqueWithoutParentsInput | parent_student_bindingsUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: parent_student_bindingsUpdateManyWithWhereWithoutParentsInput | parent_student_bindingsUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
  }

  export type parentsCreateNestedOneWithoutParent_student_bindingsInput = {
    create?: XOR<parentsCreateWithoutParent_student_bindingsInput, parentsUncheckedCreateWithoutParent_student_bindingsInput>
    connectOrCreate?: parentsCreateOrConnectWithoutParent_student_bindingsInput
    connect?: parentsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutParent_student_bindingsInput = {
    create?: XOR<studentsCreateWithoutParent_student_bindingsInput, studentsUncheckedCreateWithoutParent_student_bindingsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutParent_student_bindingsInput
    connect?: studentsWhereUniqueInput
  }

  export type parentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput = {
    create?: XOR<parentsCreateWithoutParent_student_bindingsInput, parentsUncheckedCreateWithoutParent_student_bindingsInput>
    connectOrCreate?: parentsCreateOrConnectWithoutParent_student_bindingsInput
    upsert?: parentsUpsertWithoutParent_student_bindingsInput
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutParent_student_bindingsInput, parentsUpdateWithoutParent_student_bindingsInput>, parentsUncheckedUpdateWithoutParent_student_bindingsInput>
  }

  export type studentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput = {
    create?: XOR<studentsCreateWithoutParent_student_bindingsInput, studentsUncheckedCreateWithoutParent_student_bindingsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutParent_student_bindingsInput
    upsert?: studentsUpsertWithoutParent_student_bindingsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutParent_student_bindingsInput, studentsUpdateWithoutParent_student_bindingsInput>, studentsUncheckedUpdateWithoutParent_student_bindingsInput>
  }

  export type parentsCreateNestedOneWithoutDaily_summariesInput = {
    create?: XOR<parentsCreateWithoutDaily_summariesInput, parentsUncheckedCreateWithoutDaily_summariesInput>
    connectOrCreate?: parentsCreateOrConnectWithoutDaily_summariesInput
    connect?: parentsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutDaily_summariesInput = {
    create?: XOR<studentsCreateWithoutDaily_summariesInput, studentsUncheckedCreateWithoutDaily_summariesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutDaily_summariesInput
    connect?: studentsWhereUniqueInput
  }

  export type parentsUpdateOneRequiredWithoutDaily_summariesNestedInput = {
    create?: XOR<parentsCreateWithoutDaily_summariesInput, parentsUncheckedCreateWithoutDaily_summariesInput>
    connectOrCreate?: parentsCreateOrConnectWithoutDaily_summariesInput
    upsert?: parentsUpsertWithoutDaily_summariesInput
    connect?: parentsWhereUniqueInput
    update?: XOR<XOR<parentsUpdateToOneWithWhereWithoutDaily_summariesInput, parentsUpdateWithoutDaily_summariesInput>, parentsUncheckedUpdateWithoutDaily_summariesInput>
  }

  export type studentsUpdateOneRequiredWithoutDaily_summariesNestedInput = {
    create?: XOR<studentsCreateWithoutDaily_summariesInput, studentsUncheckedCreateWithoutDaily_summariesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutDaily_summariesInput
    upsert?: studentsUpsertWithoutDaily_summariesInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutDaily_summariesInput, studentsUpdateWithoutDaily_summariesInput>, studentsUncheckedUpdateWithoutDaily_summariesInput>
  }

  export type studentsCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<studentsCreateWithoutCampaignsInput, studentsUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutCampaignsInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<studentsCreateWithoutCampaignsInput, studentsUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: studentsCreateOrConnectWithoutCampaignsInput
    upsert?: studentsUpsertWithoutCampaignsInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutCampaignsInput, studentsUpdateWithoutCampaignsInput>, studentsUncheckedUpdateWithoutCampaignsInput>
  }

  export type schoolsCreateNestedOneWithoutReward_configsInput = {
    create?: XOR<schoolsCreateWithoutReward_configsInput, schoolsUncheckedCreateWithoutReward_configsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutReward_configsInput
    connect?: schoolsWhereUniqueInput
  }

  export type schoolsUpdateOneRequiredWithoutReward_configsNestedInput = {
    create?: XOR<schoolsCreateWithoutReward_configsInput, schoolsUncheckedCreateWithoutReward_configsInput>
    connectOrCreate?: schoolsCreateOrConnectWithoutReward_configsInput
    upsert?: schoolsUpsertWithoutReward_configsInput
    connect?: schoolsWhereUniqueInput
    update?: XOR<XOR<schoolsUpdateToOneWithWhereWithoutReward_configsInput, schoolsUpdateWithoutReward_configsInput>, schoolsUncheckedUpdateWithoutReward_configsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusFilter<$PrismaModel> | $Enums.ParticipantStatus
  }

  export type NestedEnumParticipantResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantResult | EnumParticipantResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumParticipantResultNullableFilter<$PrismaModel> | $Enums.ParticipantResult | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantStatus | EnumParticipantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantStatus[] | ListEnumParticipantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantStatusFilter<$PrismaModel>
    _max?: NestedEnumParticipantStatusFilter<$PrismaModel>
  }

  export type NestedEnumParticipantResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantResult | EnumParticipantResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ParticipantResult[] | ListEnumParticipantResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumParticipantResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumParticipantResultNullableFilter<$PrismaModel>
    _max?: NestedEnumParticipantResultNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumChallengeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeFilter<$PrismaModel> | $Enums.ChallengeType
  }

  export type NestedEnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus
  }

  export type NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeType | EnumChallengeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeType[] | ListEnumChallengeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeTypeFilter<$PrismaModel>
    _max?: NestedEnumChallengeTypeFilter<$PrismaModel>
  }

  export type NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMistakeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MistakeStatus | EnumMistakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMistakeStatusFilter<$PrismaModel> | $Enums.MistakeStatus
  }

  export type NestedEnumMistakeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MistakeStatus | EnumMistakeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MistakeStatus[] | ListEnumMistakeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMistakeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MistakeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMistakeStatusFilter<$PrismaModel>
    _max?: NestedEnumMistakeStatusFilter<$PrismaModel>
  }

  export type NestedEnumPKStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PKStatus | EnumPKStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPKStatusFilter<$PrismaModel> | $Enums.PKStatus
  }

  export type NestedEnumPKStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PKStatus | EnumPKStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PKStatus[] | ListEnumPKStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPKStatusWithAggregatesFilter<$PrismaModel> | $Enums.PKStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPKStatusFilter<$PrismaModel>
    _max?: NestedEnumPKStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCategoryFilter<$PrismaModel> | $Enums.TaskCategory
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskCategory | EnumTaskCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskCategory[] | ListEnumTaskCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TaskCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskCategoryFilter<$PrismaModel>
    _max?: NestedEnumTaskCategoryFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type schoolsCreateWithoutBadgesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutBadgesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutBadgesInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutBadgesInput, schoolsUncheckedCreateWithoutBadgesInput>
  }

  export type student_badgesCreateWithoutBadgesInput = {
    id?: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
    students: studentsCreateNestedOneWithoutStudent_badgesInput
  }

  export type student_badgesUncheckedCreateWithoutBadgesInput = {
    id?: string
    studentId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_badgesCreateOrConnectWithoutBadgesInput = {
    where: student_badgesWhereUniqueInput
    create: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput>
  }

  export type student_badgesCreateManyBadgesInputEnvelope = {
    data: student_badgesCreateManyBadgesInput | student_badgesCreateManyBadgesInput[]
    skipDuplicates?: boolean
  }

  export type schoolsUpsertWithoutBadgesInput = {
    update: XOR<schoolsUpdateWithoutBadgesInput, schoolsUncheckedUpdateWithoutBadgesInput>
    create: XOR<schoolsCreateWithoutBadgesInput, schoolsUncheckedCreateWithoutBadgesInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutBadgesInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutBadgesInput, schoolsUncheckedUpdateWithoutBadgesInput>
  }

  export type schoolsUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type student_badgesUpsertWithWhereUniqueWithoutBadgesInput = {
    where: student_badgesWhereUniqueInput
    update: XOR<student_badgesUpdateWithoutBadgesInput, student_badgesUncheckedUpdateWithoutBadgesInput>
    create: XOR<student_badgesCreateWithoutBadgesInput, student_badgesUncheckedCreateWithoutBadgesInput>
  }

  export type student_badgesUpdateWithWhereUniqueWithoutBadgesInput = {
    where: student_badgesWhereUniqueInput
    data: XOR<student_badgesUpdateWithoutBadgesInput, student_badgesUncheckedUpdateWithoutBadgesInput>
  }

  export type student_badgesUpdateManyWithWhereWithoutBadgesInput = {
    where: student_badgesScalarWhereInput
    data: XOR<student_badgesUpdateManyMutationInput, student_badgesUncheckedUpdateManyWithoutBadgesInput>
  }

  export type student_badgesScalarWhereInput = {
    AND?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
    OR?: student_badgesScalarWhereInput[]
    NOT?: student_badgesScalarWhereInput | student_badgesScalarWhereInput[]
    id?: StringFilter<"student_badges"> | string
    studentId?: StringFilter<"student_badges"> | string
    badgeId?: StringFilter<"student_badges"> | string
    awardedBy?: StringNullableFilter<"student_badges"> | string | null
    awardedAt?: DateTimeFilter<"student_badges"> | Date | string
    reason?: StringNullableFilter<"student_badges"> | string | null
  }

  export type challengesCreateWithoutChallenge_participantsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers: teachersCreateNestedOneWithoutChallengesInput
    schools: schoolsCreateNestedOneWithoutChallengesInput
  }

  export type challengesUncheckedCreateWithoutChallenge_participantsInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    creatorId: string
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type challengesCreateOrConnectWithoutChallenge_participantsInput = {
    where: challengesWhereUniqueInput
    create: XOR<challengesCreateWithoutChallenge_participantsInput, challengesUncheckedCreateWithoutChallenge_participantsInput>
  }

  export type studentsCreateWithoutChallenge_participantsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutChallenge_participantsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutChallenge_participantsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutChallenge_participantsInput, studentsUncheckedCreateWithoutChallenge_participantsInput>
  }

  export type challengesUpsertWithoutChallenge_participantsInput = {
    update: XOR<challengesUpdateWithoutChallenge_participantsInput, challengesUncheckedUpdateWithoutChallenge_participantsInput>
    create: XOR<challengesCreateWithoutChallenge_participantsInput, challengesUncheckedCreateWithoutChallenge_participantsInput>
    where?: challengesWhereInput
  }

  export type challengesUpdateToOneWithWhereWithoutChallenge_participantsInput = {
    where?: challengesWhereInput
    data: XOR<challengesUpdateWithoutChallenge_participantsInput, challengesUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type challengesUpdateWithoutChallenge_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: teachersUpdateOneRequiredWithoutChallengesNestedInput
    schools?: schoolsUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateWithoutChallenge_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsUpsertWithoutChallenge_participantsInput = {
    update: XOR<studentsUpdateWithoutChallenge_participantsInput, studentsUncheckedUpdateWithoutChallenge_participantsInput>
    create: XOR<studentsCreateWithoutChallenge_participantsInput, studentsUncheckedCreateWithoutChallenge_participantsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutChallenge_participantsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutChallenge_participantsInput, studentsUncheckedUpdateWithoutChallenge_participantsInput>
  }

  export type studentsUpdateWithoutChallenge_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutChallenge_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type challenge_participantsCreateWithoutChallengesInput = {
    id?: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
    students: studentsCreateNestedOneWithoutChallenge_participantsInput
  }

  export type challenge_participantsUncheckedCreateWithoutChallengesInput = {
    id?: string
    studentId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type challenge_participantsCreateOrConnectWithoutChallengesInput = {
    where: challenge_participantsWhereUniqueInput
    create: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput>
  }

  export type challenge_participantsCreateManyChallengesInputEnvelope = {
    data: challenge_participantsCreateManyChallengesInput | challenge_participantsCreateManyChallengesInput[]
    skipDuplicates?: boolean
  }

  export type teachersCreateWithoutChallengesInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    lesson_plans?: lesson_plansCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutTeachersInput
    students?: studentsCreateNestedManyWithoutTeachersInput
    schools?: schoolsCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutChallengesInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput
    students?: studentsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutChallengesInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutChallengesInput, teachersUncheckedCreateWithoutChallengesInput>
  }

  export type schoolsCreateWithoutChallengesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutChallengesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutChallengesInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutChallengesInput, schoolsUncheckedCreateWithoutChallengesInput>
  }

  export type challenge_participantsUpsertWithWhereUniqueWithoutChallengesInput = {
    where: challenge_participantsWhereUniqueInput
    update: XOR<challenge_participantsUpdateWithoutChallengesInput, challenge_participantsUncheckedUpdateWithoutChallengesInput>
    create: XOR<challenge_participantsCreateWithoutChallengesInput, challenge_participantsUncheckedCreateWithoutChallengesInput>
  }

  export type challenge_participantsUpdateWithWhereUniqueWithoutChallengesInput = {
    where: challenge_participantsWhereUniqueInput
    data: XOR<challenge_participantsUpdateWithoutChallengesInput, challenge_participantsUncheckedUpdateWithoutChallengesInput>
  }

  export type challenge_participantsUpdateManyWithWhereWithoutChallengesInput = {
    where: challenge_participantsScalarWhereInput
    data: XOR<challenge_participantsUpdateManyMutationInput, challenge_participantsUncheckedUpdateManyWithoutChallengesInput>
  }

  export type challenge_participantsScalarWhereInput = {
    AND?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
    OR?: challenge_participantsScalarWhereInput[]
    NOT?: challenge_participantsScalarWhereInput | challenge_participantsScalarWhereInput[]
    id?: StringFilter<"challenge_participants"> | string
    challengeId?: StringFilter<"challenge_participants"> | string
    studentId?: StringFilter<"challenge_participants"> | string
    joinedAt?: DateTimeFilter<"challenge_participants"> | Date | string
    status?: EnumParticipantStatusFilter<"challenge_participants"> | $Enums.ParticipantStatus
    result?: EnumParticipantResultNullableFilter<"challenge_participants"> | $Enums.ParticipantResult | null
    score?: IntNullableFilter<"challenge_participants"> | number | null
    notes?: StringNullableFilter<"challenge_participants"> | string | null
    completedAt?: DateTimeNullableFilter<"challenge_participants"> | Date | string | null
  }

  export type teachersUpsertWithoutChallengesInput = {
    update: XOR<teachersUpdateWithoutChallengesInput, teachersUncheckedUpdateWithoutChallengesInput>
    create: XOR<teachersCreateWithoutChallengesInput, teachersUncheckedCreateWithoutChallengesInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutChallengesInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutChallengesInput, teachersUncheckedUpdateWithoutChallengesInput>
  }

  export type teachersUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_plans?: lesson_plansUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput
    students?: studentsUpdateManyWithoutTeachersNestedInput
    schools?: schoolsUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput
    students?: studentsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type schoolsUpsertWithoutChallengesInput = {
    update: XOR<schoolsUpdateWithoutChallengesInput, schoolsUncheckedUpdateWithoutChallengesInput>
    create: XOR<schoolsCreateWithoutChallengesInput, schoolsUncheckedCreateWithoutChallengesInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutChallengesInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutChallengesInput, schoolsUncheckedUpdateWithoutChallengesInput>
  }

  export type schoolsUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type habitsCreateWithoutHabit_logsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutHabitsInput
  }

  export type habitsUncheckedCreateWithoutHabit_logsInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type habitsCreateOrConnectWithoutHabit_logsInput = {
    where: habitsWhereUniqueInput
    create: XOR<habitsCreateWithoutHabit_logsInput, habitsUncheckedCreateWithoutHabit_logsInput>
  }

  export type schoolsCreateWithoutHabit_logsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutHabit_logsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutHabit_logsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutHabit_logsInput, schoolsUncheckedCreateWithoutHabit_logsInput>
  }

  export type studentsCreateWithoutHabit_logsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutHabit_logsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutHabit_logsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutHabit_logsInput, studentsUncheckedCreateWithoutHabit_logsInput>
  }

  export type habitsUpsertWithoutHabit_logsInput = {
    update: XOR<habitsUpdateWithoutHabit_logsInput, habitsUncheckedUpdateWithoutHabit_logsInput>
    create: XOR<habitsCreateWithoutHabit_logsInput, habitsUncheckedCreateWithoutHabit_logsInput>
    where?: habitsWhereInput
  }

  export type habitsUpdateToOneWithWhereWithoutHabit_logsInput = {
    where?: habitsWhereInput
    data: XOR<habitsUpdateWithoutHabit_logsInput, habitsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type habitsUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutHabitsNestedInput
  }

  export type habitsUncheckedUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schoolsUpsertWithoutHabit_logsInput = {
    update: XOR<schoolsUpdateWithoutHabit_logsInput, schoolsUncheckedUpdateWithoutHabit_logsInput>
    create: XOR<schoolsCreateWithoutHabit_logsInput, schoolsUncheckedCreateWithoutHabit_logsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutHabit_logsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutHabit_logsInput, schoolsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type schoolsUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutHabit_logsInput = {
    update: XOR<studentsUpdateWithoutHabit_logsInput, studentsUncheckedUpdateWithoutHabit_logsInput>
    create: XOR<studentsCreateWithoutHabit_logsInput, studentsUncheckedCreateWithoutHabit_logsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutHabit_logsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutHabit_logsInput, studentsUncheckedUpdateWithoutHabit_logsInput>
  }

  export type studentsUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutHabit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type habit_logsCreateWithoutHabitsInput = {
    id?: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
    schools: schoolsCreateNestedOneWithoutHabit_logsInput
    students: studentsCreateNestedOneWithoutHabit_logsInput
  }

  export type habit_logsUncheckedCreateWithoutHabitsInput = {
    id?: string
    schoolId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsCreateOrConnectWithoutHabitsInput = {
    where: habit_logsWhereUniqueInput
    create: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput>
  }

  export type habit_logsCreateManyHabitsInputEnvelope = {
    data: habit_logsCreateManyHabitsInput | habit_logsCreateManyHabitsInput[]
    skipDuplicates?: boolean
  }

  export type schoolsCreateWithoutHabitsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutHabitsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutHabitsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutHabitsInput, schoolsUncheckedCreateWithoutHabitsInput>
  }

  export type habit_logsUpsertWithWhereUniqueWithoutHabitsInput = {
    where: habit_logsWhereUniqueInput
    update: XOR<habit_logsUpdateWithoutHabitsInput, habit_logsUncheckedUpdateWithoutHabitsInput>
    create: XOR<habit_logsCreateWithoutHabitsInput, habit_logsUncheckedCreateWithoutHabitsInput>
  }

  export type habit_logsUpdateWithWhereUniqueWithoutHabitsInput = {
    where: habit_logsWhereUniqueInput
    data: XOR<habit_logsUpdateWithoutHabitsInput, habit_logsUncheckedUpdateWithoutHabitsInput>
  }

  export type habit_logsUpdateManyWithWhereWithoutHabitsInput = {
    where: habit_logsScalarWhereInput
    data: XOR<habit_logsUpdateManyMutationInput, habit_logsUncheckedUpdateManyWithoutHabitsInput>
  }

  export type habit_logsScalarWhereInput = {
    AND?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
    OR?: habit_logsScalarWhereInput[]
    NOT?: habit_logsScalarWhereInput | habit_logsScalarWhereInput[]
    id?: StringFilter<"habit_logs"> | string
    schoolId?: StringFilter<"habit_logs"> | string
    habitId?: StringFilter<"habit_logs"> | string
    studentId?: StringFilter<"habit_logs"> | string
    checkedAt?: DateTimeFilter<"habit_logs"> | Date | string
    streakDays?: IntFilter<"habit_logs"> | number
    notes?: StringNullableFilter<"habit_logs"> | string | null
  }

  export type schoolsUpsertWithoutHabitsInput = {
    update: XOR<schoolsUpdateWithoutHabitsInput, schoolsUncheckedUpdateWithoutHabitsInput>
    create: XOR<schoolsCreateWithoutHabitsInput, schoolsUncheckedCreateWithoutHabitsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutHabitsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutHabitsInput, schoolsUncheckedUpdateWithoutHabitsInput>
  }

  export type schoolsUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsCreateWithoutLesson_plansInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutLesson_plansInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutLesson_plansInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutLesson_plansInput, schoolsUncheckedCreateWithoutLesson_plansInput>
  }

  export type teachersCreateWithoutLesson_plansInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutTeachersInput
    students?: studentsCreateNestedManyWithoutTeachersInput
    schools?: schoolsCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutLesson_plansInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput
    students?: studentsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutLesson_plansInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutLesson_plansInput, teachersUncheckedCreateWithoutLesson_plansInput>
  }

  export type task_recordsCreateWithoutLesson_plansInput = {
    id?: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
    schools: schoolsCreateNestedOneWithoutTask_recordsInput
    students: studentsCreateNestedOneWithoutTask_recordsInput
  }

  export type task_recordsUncheckedCreateWithoutLesson_plansInput = {
    id?: string
    schoolId: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsCreateOrConnectWithoutLesson_plansInput = {
    where: task_recordsWhereUniqueInput
    create: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput>
  }

  export type task_recordsCreateManyLesson_plansInputEnvelope = {
    data: task_recordsCreateManyLesson_plansInput | task_recordsCreateManyLesson_plansInput[]
    skipDuplicates?: boolean
  }

  export type schoolsUpsertWithoutLesson_plansInput = {
    update: XOR<schoolsUpdateWithoutLesson_plansInput, schoolsUncheckedUpdateWithoutLesson_plansInput>
    create: XOR<schoolsCreateWithoutLesson_plansInput, schoolsUncheckedCreateWithoutLesson_plansInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutLesson_plansInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutLesson_plansInput, schoolsUncheckedUpdateWithoutLesson_plansInput>
  }

  export type schoolsUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type teachersUpsertWithoutLesson_plansInput = {
    update: XOR<teachersUpdateWithoutLesson_plansInput, teachersUncheckedUpdateWithoutLesson_plansInput>
    create: XOR<teachersCreateWithoutLesson_plansInput, teachersUncheckedCreateWithoutLesson_plansInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutLesson_plansInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutLesson_plansInput, teachersUncheckedUpdateWithoutLesson_plansInput>
  }

  export type teachersUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput
    students?: studentsUpdateManyWithoutTeachersNestedInput
    schools?: schoolsUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUncheckedUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput
    students?: studentsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type task_recordsUpsertWithWhereUniqueWithoutLesson_plansInput = {
    where: task_recordsWhereUniqueInput
    update: XOR<task_recordsUpdateWithoutLesson_plansInput, task_recordsUncheckedUpdateWithoutLesson_plansInput>
    create: XOR<task_recordsCreateWithoutLesson_plansInput, task_recordsUncheckedCreateWithoutLesson_plansInput>
  }

  export type task_recordsUpdateWithWhereUniqueWithoutLesson_plansInput = {
    where: task_recordsWhereUniqueInput
    data: XOR<task_recordsUpdateWithoutLesson_plansInput, task_recordsUncheckedUpdateWithoutLesson_plansInput>
  }

  export type task_recordsUpdateManyWithWhereWithoutLesson_plansInput = {
    where: task_recordsScalarWhereInput
    data: XOR<task_recordsUpdateManyMutationInput, task_recordsUncheckedUpdateManyWithoutLesson_plansInput>
  }

  export type task_recordsScalarWhereInput = {
    AND?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
    OR?: task_recordsScalarWhereInput[]
    NOT?: task_recordsScalarWhereInput | task_recordsScalarWhereInput[]
    id?: StringFilter<"task_records"> | string
    schoolId?: StringFilter<"task_records"> | string
    studentId?: StringFilter<"task_records"> | string
    type?: EnumTaskTypeFilter<"task_records"> | $Enums.TaskType
    title?: StringFilter<"task_records"> | string
    content?: JsonNullableFilter<"task_records">
    status?: EnumTaskStatusFilter<"task_records"> | $Enums.TaskStatus
    expAwarded?: IntFilter<"task_records"> | number
    submittedAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
    createdAt?: DateTimeFilter<"task_records"> | Date | string
    updatedAt?: DateTimeFilter<"task_records"> | Date | string
    lessonPlanId?: StringNullableFilter<"task_records"> | string | null
    task_category?: EnumTaskCategoryFilter<"task_records"> | $Enums.TaskCategory
    is_current?: BoolFilter<"task_records"> | boolean
    attempts?: IntFilter<"task_records"> | number
    subject?: StringNullableFilter<"task_records"> | string | null
    isOverridden?: BoolFilter<"task_records"> | boolean
    settledAt?: DateTimeNullableFilter<"task_records"> | Date | string | null
  }

  export type schoolsCreateWithoutMistakesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutMistakesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutMistakesInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutMistakesInput, schoolsUncheckedCreateWithoutMistakesInput>
  }

  export type studentsCreateWithoutMistakesInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutMistakesInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutMistakesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutMistakesInput, studentsUncheckedCreateWithoutMistakesInput>
  }

  export type schoolsUpsertWithoutMistakesInput = {
    update: XOR<schoolsUpdateWithoutMistakesInput, schoolsUncheckedUpdateWithoutMistakesInput>
    create: XOR<schoolsCreateWithoutMistakesInput, schoolsUncheckedCreateWithoutMistakesInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutMistakesInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutMistakesInput, schoolsUncheckedUpdateWithoutMistakesInput>
  }

  export type schoolsUpdateWithoutMistakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutMistakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutMistakesInput = {
    update: XOR<studentsUpdateWithoutMistakesInput, studentsUncheckedUpdateWithoutMistakesInput>
    create: XOR<studentsCreateWithoutMistakesInput, studentsUncheckedCreateWithoutMistakesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutMistakesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutMistakesInput, studentsUncheckedUpdateWithoutMistakesInput>
  }

  export type studentsUpdateWithoutMistakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutMistakesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type schoolsCreateWithoutPk_matchesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutPk_matchesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutPk_matchesInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutPk_matchesInput, schoolsUncheckedCreateWithoutPk_matchesInput>
  }

  export type studentsCreateWithoutPk_matches_studentAInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutPk_matches_studentAInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutPk_matches_studentAInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutPk_matches_studentAInput, studentsUncheckedCreateWithoutPk_matches_studentAInput>
  }

  export type studentsCreateWithoutPk_matches_studentBInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutPk_matches_studentBInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutPk_matches_studentBInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutPk_matches_studentBInput, studentsUncheckedCreateWithoutPk_matches_studentBInput>
  }

  export type studentsCreateWithoutPk_matches_winnerInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutPk_matches_winnerInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutPk_matches_winnerInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutPk_matches_winnerInput, studentsUncheckedCreateWithoutPk_matches_winnerInput>
  }

  export type schoolsUpsertWithoutPk_matchesInput = {
    update: XOR<schoolsUpdateWithoutPk_matchesInput, schoolsUncheckedUpdateWithoutPk_matchesInput>
    create: XOR<schoolsCreateWithoutPk_matchesInput, schoolsUncheckedCreateWithoutPk_matchesInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutPk_matchesInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutPk_matchesInput, schoolsUncheckedUpdateWithoutPk_matchesInput>
  }

  export type schoolsUpdateWithoutPk_matchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutPk_matchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutPk_matches_studentAInput = {
    update: XOR<studentsUpdateWithoutPk_matches_studentAInput, studentsUncheckedUpdateWithoutPk_matches_studentAInput>
    create: XOR<studentsCreateWithoutPk_matches_studentAInput, studentsUncheckedCreateWithoutPk_matches_studentAInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutPk_matches_studentAInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutPk_matches_studentAInput, studentsUncheckedUpdateWithoutPk_matches_studentAInput>
  }

  export type studentsUpdateWithoutPk_matches_studentAInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutPk_matches_studentAInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUpsertWithoutPk_matches_studentBInput = {
    update: XOR<studentsUpdateWithoutPk_matches_studentBInput, studentsUncheckedUpdateWithoutPk_matches_studentBInput>
    create: XOR<studentsCreateWithoutPk_matches_studentBInput, studentsUncheckedCreateWithoutPk_matches_studentBInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutPk_matches_studentBInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutPk_matches_studentBInput, studentsUncheckedUpdateWithoutPk_matches_studentBInput>
  }

  export type studentsUpdateWithoutPk_matches_studentBInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutPk_matches_studentBInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUpsertWithoutPk_matches_winnerInput = {
    update: XOR<studentsUpdateWithoutPk_matches_winnerInput, studentsUncheckedUpdateWithoutPk_matches_winnerInput>
    create: XOR<studentsCreateWithoutPk_matches_winnerInput, studentsUncheckedCreateWithoutPk_matches_winnerInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutPk_matches_winnerInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutPk_matches_winnerInput, studentsUncheckedUpdateWithoutPk_matches_winnerInput>
  }

  export type studentsUpdateWithoutPk_matches_winnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutPk_matches_winnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type badgesCreateWithoutSchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student_badges?: student_badgesCreateNestedManyWithoutBadgesInput
  }

  export type badgesUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutBadgesInput
  }

  export type badgesCreateOrConnectWithoutSchoolsInput = {
    where: badgesWhereUniqueInput
    create: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput>
  }

  export type badgesCreateManySchoolsInputEnvelope = {
    data: badgesCreateManySchoolsInput | badgesCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type challengesCreateWithoutSchoolsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsCreateNestedManyWithoutChallengesInput
    teachers: teachersCreateNestedOneWithoutChallengesInput
  }

  export type challengesUncheckedCreateWithoutSchoolsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    creatorId: string
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutChallengesInput
  }

  export type challengesCreateOrConnectWithoutSchoolsInput = {
    where: challengesWhereUniqueInput
    create: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput>
  }

  export type challengesCreateManySchoolsInputEnvelope = {
    data: challengesCreateManySchoolsInput | challengesCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type habit_logsCreateWithoutSchoolsInput = {
    id?: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
    habits: habitsCreateNestedOneWithoutHabit_logsInput
    students: studentsCreateNestedOneWithoutHabit_logsInput
  }

  export type habit_logsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    habitId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsCreateOrConnectWithoutSchoolsInput = {
    where: habit_logsWhereUniqueInput
    create: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput>
  }

  export type habit_logsCreateManySchoolsInputEnvelope = {
    data: habit_logsCreateManySchoolsInput | habit_logsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type habitsCreateWithoutSchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    habit_logs?: habit_logsCreateNestedManyWithoutHabitsInput
  }

  export type habitsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutHabitsInput
  }

  export type habitsCreateOrConnectWithoutSchoolsInput = {
    where: habitsWhereUniqueInput
    create: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput>
  }

  export type habitsCreateManySchoolsInputEnvelope = {
    data: habitsCreateManySchoolsInput | habitsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type lesson_plansCreateWithoutSchoolsInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    teachers: teachersCreateNestedOneWithoutLesson_plansInput
    task_records?: task_recordsCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansUncheckedCreateWithoutSchoolsInput = {
    id?: string
    teacherId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    task_records?: task_recordsUncheckedCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansCreateOrConnectWithoutSchoolsInput = {
    where: lesson_plansWhereUniqueInput
    create: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput>
  }

  export type lesson_plansCreateManySchoolsInputEnvelope = {
    data: lesson_plansCreateManySchoolsInput | lesson_plansCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type mistakesCreateWithoutSchoolsInput = {
    id?: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
    students: studentsCreateNestedOneWithoutMistakesInput
  }

  export type mistakesUncheckedCreateWithoutSchoolsInput = {
    id?: string
    studentId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type mistakesCreateOrConnectWithoutSchoolsInput = {
    where: mistakesWhereUniqueInput
    create: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput>
  }

  export type mistakesCreateManySchoolsInputEnvelope = {
    data: mistakesCreateManySchoolsInput | mistakesCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type parentsCreateWithoutSchoolsInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesCreateNestedManyWithoutParentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutParentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutSchoolsInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput>
  }

  export type parentsCreateManySchoolsInputEnvelope = {
    data: parentsCreateManySchoolsInput | parentsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type personalized_tutoring_plansCreateWithoutSchoolsInput = {
    id?: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students: studentsCreateNestedOneWithoutPersonalized_tutoring_plansInput
    teachers: teachersCreateNestedOneWithoutPersonalized_tutoring_plansInput
  }

  export type personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput = {
    id?: string
    teacherId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansCreateOrConnectWithoutSchoolsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    create: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput>
  }

  export type personalized_tutoring_plansCreateManySchoolsInputEnvelope = {
    data: personalized_tutoring_plansCreateManySchoolsInput | personalized_tutoring_plansCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type pk_matchesCreateWithoutSchoolsInput = {
    id?: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    playerA: studentsCreateNestedOneWithoutPk_matches_studentAInput
    playerB: studentsCreateNestedOneWithoutPk_matches_studentBInput
    winner?: studentsCreateNestedOneWithoutPk_matches_winnerInput
  }

  export type pk_matchesUncheckedCreateWithoutSchoolsInput = {
    id?: string
    studentA: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateOrConnectWithoutSchoolsInput = {
    where: pk_matchesWhereUniqueInput
    create: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput>
  }

  export type pk_matchesCreateManySchoolsInputEnvelope = {
    data: pk_matchesCreateManySchoolsInput | pk_matchesCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type reward_configsCreateWithoutSchoolsInput = {
    id?: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reward_configsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reward_configsCreateOrConnectWithoutSchoolsInput = {
    where: reward_configsWhereUniqueInput
    create: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput>
  }

  export type reward_configsCreateManySchoolsInputEnvelope = {
    data: reward_configsCreateManySchoolsInput | reward_configsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type student_checkinsCreateWithoutSchoolsInput = {
    id?: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
    students: studentsCreateNestedOneWithoutStudent_checkinsInput
  }

  export type student_checkinsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    studentId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type student_checkinsCreateOrConnectWithoutSchoolsInput = {
    where: student_checkinsWhereUniqueInput
    create: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput>
  }

  export type student_checkinsCreateManySchoolsInputEnvelope = {
    data: student_checkinsCreateManySchoolsInput | student_checkinsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutSchoolsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutSchoolsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput>
  }

  export type studentsCreateManySchoolsInputEnvelope = {
    data: studentsCreateManySchoolsInput | studentsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type task_libraryCreateWithoutSchoolsInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
  }

  export type task_libraryUncheckedCreateWithoutSchoolsInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
  }

  export type task_libraryCreateOrConnectWithoutSchoolsInput = {
    where: task_libraryWhereUniqueInput
    create: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput>
  }

  export type task_libraryCreateManySchoolsInputEnvelope = {
    data: task_libraryCreateManySchoolsInput | task_libraryCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type task_recordsCreateWithoutSchoolsInput = {
    id?: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
    lesson_plans?: lesson_plansCreateNestedOneWithoutTask_recordsInput
    students: studentsCreateNestedOneWithoutTask_recordsInput
  }

  export type task_recordsUncheckedCreateWithoutSchoolsInput = {
    id?: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsCreateOrConnectWithoutSchoolsInput = {
    where: task_recordsWhereUniqueInput
    create: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput>
  }

  export type task_recordsCreateManySchoolsInputEnvelope = {
    data: task_recordsCreateManySchoolsInput | task_recordsCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type teachersCreateWithoutSchoolsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutTeachersInput
    students?: studentsCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutSchoolsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput
    students?: studentsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutSchoolsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput>
  }

  export type teachersCreateManySchoolsInputEnvelope = {
    data: teachersCreateManySchoolsInput | teachersCreateManySchoolsInput[]
    skipDuplicates?: boolean
  }

  export type badgesUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: badgesWhereUniqueInput
    update: XOR<badgesUpdateWithoutSchoolsInput, badgesUncheckedUpdateWithoutSchoolsInput>
    create: XOR<badgesCreateWithoutSchoolsInput, badgesUncheckedCreateWithoutSchoolsInput>
  }

  export type badgesUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: badgesWhereUniqueInput
    data: XOR<badgesUpdateWithoutSchoolsInput, badgesUncheckedUpdateWithoutSchoolsInput>
  }

  export type badgesUpdateManyWithWhereWithoutSchoolsInput = {
    where: badgesScalarWhereInput
    data: XOR<badgesUpdateManyMutationInput, badgesUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type badgesScalarWhereInput = {
    AND?: badgesScalarWhereInput | badgesScalarWhereInput[]
    OR?: badgesScalarWhereInput[]
    NOT?: badgesScalarWhereInput | badgesScalarWhereInput[]
    id?: StringFilter<"badges"> | string
    schoolId?: StringFilter<"badges"> | string
    name?: StringFilter<"badges"> | string
    description?: StringNullableFilter<"badges"> | string | null
    icon?: StringNullableFilter<"badges"> | string | null
    category?: StringFilter<"badges"> | string
    requirement?: JsonNullableFilter<"badges">
    isActive?: BoolFilter<"badges"> | boolean
    createdAt?: DateTimeFilter<"badges"> | Date | string
    updatedAt?: DateTimeFilter<"badges"> | Date | string
  }

  export type challengesUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: challengesWhereUniqueInput
    update: XOR<challengesUpdateWithoutSchoolsInput, challengesUncheckedUpdateWithoutSchoolsInput>
    create: XOR<challengesCreateWithoutSchoolsInput, challengesUncheckedCreateWithoutSchoolsInput>
  }

  export type challengesUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: challengesWhereUniqueInput
    data: XOR<challengesUpdateWithoutSchoolsInput, challengesUncheckedUpdateWithoutSchoolsInput>
  }

  export type challengesUpdateManyWithWhereWithoutSchoolsInput = {
    where: challengesScalarWhereInput
    data: XOR<challengesUpdateManyMutationInput, challengesUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type challengesScalarWhereInput = {
    AND?: challengesScalarWhereInput | challengesScalarWhereInput[]
    OR?: challengesScalarWhereInput[]
    NOT?: challengesScalarWhereInput | challengesScalarWhereInput[]
    id?: StringFilter<"challenges"> | string
    schoolId?: StringFilter<"challenges"> | string
    title?: StringFilter<"challenges"> | string
    description?: StringNullableFilter<"challenges"> | string | null
    type?: EnumChallengeTypeFilter<"challenges"> | $Enums.ChallengeType
    status?: EnumChallengeStatusFilter<"challenges"> | $Enums.ChallengeStatus
    creatorId?: StringFilter<"challenges"> | string
    startDate?: DateTimeFilter<"challenges"> | Date | string
    endDate?: DateTimeNullableFilter<"challenges"> | Date | string | null
    rewardPoints?: IntFilter<"challenges"> | number
    rewardExp?: IntFilter<"challenges"> | number
    maxParticipants?: IntFilter<"challenges"> | number
    metadata?: JsonNullableFilter<"challenges">
    isActive?: BoolFilter<"challenges"> | boolean
    createdAt?: DateTimeFilter<"challenges"> | Date | string
    updatedAt?: DateTimeFilter<"challenges"> | Date | string
  }

  export type habit_logsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: habit_logsWhereUniqueInput
    update: XOR<habit_logsUpdateWithoutSchoolsInput, habit_logsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<habit_logsCreateWithoutSchoolsInput, habit_logsUncheckedCreateWithoutSchoolsInput>
  }

  export type habit_logsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: habit_logsWhereUniqueInput
    data: XOR<habit_logsUpdateWithoutSchoolsInput, habit_logsUncheckedUpdateWithoutSchoolsInput>
  }

  export type habit_logsUpdateManyWithWhereWithoutSchoolsInput = {
    where: habit_logsScalarWhereInput
    data: XOR<habit_logsUpdateManyMutationInput, habit_logsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type habitsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: habitsWhereUniqueInput
    update: XOR<habitsUpdateWithoutSchoolsInput, habitsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<habitsCreateWithoutSchoolsInput, habitsUncheckedCreateWithoutSchoolsInput>
  }

  export type habitsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: habitsWhereUniqueInput
    data: XOR<habitsUpdateWithoutSchoolsInput, habitsUncheckedUpdateWithoutSchoolsInput>
  }

  export type habitsUpdateManyWithWhereWithoutSchoolsInput = {
    where: habitsScalarWhereInput
    data: XOR<habitsUpdateManyMutationInput, habitsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type habitsScalarWhereInput = {
    AND?: habitsScalarWhereInput | habitsScalarWhereInput[]
    OR?: habitsScalarWhereInput[]
    NOT?: habitsScalarWhereInput | habitsScalarWhereInput[]
    id?: StringFilter<"habits"> | string
    schoolId?: StringFilter<"habits"> | string
    name?: StringFilter<"habits"> | string
    description?: StringNullableFilter<"habits"> | string | null
    icon?: StringNullableFilter<"habits"> | string | null
    expReward?: IntFilter<"habits"> | number
    pointsReward?: IntNullableFilter<"habits"> | number | null
    isActive?: BoolFilter<"habits"> | boolean
    createdAt?: DateTimeFilter<"habits"> | Date | string
    updatedAt?: DateTimeFilter<"habits"> | Date | string
  }

  export type lesson_plansUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: lesson_plansWhereUniqueInput
    update: XOR<lesson_plansUpdateWithoutSchoolsInput, lesson_plansUncheckedUpdateWithoutSchoolsInput>
    create: XOR<lesson_plansCreateWithoutSchoolsInput, lesson_plansUncheckedCreateWithoutSchoolsInput>
  }

  export type lesson_plansUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: lesson_plansWhereUniqueInput
    data: XOR<lesson_plansUpdateWithoutSchoolsInput, lesson_plansUncheckedUpdateWithoutSchoolsInput>
  }

  export type lesson_plansUpdateManyWithWhereWithoutSchoolsInput = {
    where: lesson_plansScalarWhereInput
    data: XOR<lesson_plansUpdateManyMutationInput, lesson_plansUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type lesson_plansScalarWhereInput = {
    AND?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
    OR?: lesson_plansScalarWhereInput[]
    NOT?: lesson_plansScalarWhereInput | lesson_plansScalarWhereInput[]
    id?: StringFilter<"lesson_plans"> | string
    schoolId?: StringFilter<"lesson_plans"> | string
    teacherId?: StringFilter<"lesson_plans"> | string
    title?: StringFilter<"lesson_plans"> | string
    content?: JsonFilter<"lesson_plans">
    date?: DateTimeFilter<"lesson_plans"> | Date | string
    isActive?: BoolFilter<"lesson_plans"> | boolean
    createdAt?: DateTimeFilter<"lesson_plans"> | Date | string
    updatedAt?: DateTimeFilter<"lesson_plans"> | Date | string
    isGlobal?: BoolFilter<"lesson_plans"> | boolean
  }

  export type mistakesUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: mistakesWhereUniqueInput
    update: XOR<mistakesUpdateWithoutSchoolsInput, mistakesUncheckedUpdateWithoutSchoolsInput>
    create: XOR<mistakesCreateWithoutSchoolsInput, mistakesUncheckedCreateWithoutSchoolsInput>
  }

  export type mistakesUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: mistakesWhereUniqueInput
    data: XOR<mistakesUpdateWithoutSchoolsInput, mistakesUncheckedUpdateWithoutSchoolsInput>
  }

  export type mistakesUpdateManyWithWhereWithoutSchoolsInput = {
    where: mistakesScalarWhereInput
    data: XOR<mistakesUpdateManyMutationInput, mistakesUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type mistakesScalarWhereInput = {
    AND?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
    OR?: mistakesScalarWhereInput[]
    NOT?: mistakesScalarWhereInput | mistakesScalarWhereInput[]
    id?: StringFilter<"mistakes"> | string
    schoolId?: StringFilter<"mistakes"> | string
    studentId?: StringFilter<"mistakes"> | string
    imageUrl?: StringNullableFilter<"mistakes"> | string | null
    ocrText?: StringNullableFilter<"mistakes"> | string | null
    status?: EnumMistakeStatusFilter<"mistakes"> | $Enums.MistakeStatus
    category?: StringNullableFilter<"mistakes"> | string | null
    notes?: StringNullableFilter<"mistakes"> | string | null
    createdAt?: DateTimeFilter<"mistakes"> | Date | string
    updatedAt?: DateTimeFilter<"mistakes"> | Date | string
    aiAnalysis?: JsonNullableFilter<"mistakes">
    errorCause?: StringNullableFilter<"mistakes"> | string | null
    lastRetryAt?: DateTimeNullableFilter<"mistakes"> | Date | string | null
    lesson?: StringNullableFilter<"mistakes"> | string | null
    questionNo?: IntNullableFilter<"mistakes"> | number | null
    retryCount?: IntFilter<"mistakes"> | number
    subject?: StringNullableFilter<"mistakes"> | string | null
    unit?: StringNullableFilter<"mistakes"> | string | null
    workbookPage?: IntNullableFilter<"mistakes"> | number | null
    wrongCount?: IntFilter<"mistakes"> | number
  }

  export type parentsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: parentsWhereUniqueInput
    update: XOR<parentsUpdateWithoutSchoolsInput, parentsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<parentsCreateWithoutSchoolsInput, parentsUncheckedCreateWithoutSchoolsInput>
  }

  export type parentsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: parentsWhereUniqueInput
    data: XOR<parentsUpdateWithoutSchoolsInput, parentsUncheckedUpdateWithoutSchoolsInput>
  }

  export type parentsUpdateManyWithWhereWithoutSchoolsInput = {
    where: parentsScalarWhereInput
    data: XOR<parentsUpdateManyMutationInput, parentsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type parentsScalarWhereInput = {
    AND?: parentsScalarWhereInput | parentsScalarWhereInput[]
    OR?: parentsScalarWhereInput[]
    NOT?: parentsScalarWhereInput | parentsScalarWhereInput[]
    id?: StringFilter<"parents"> | string
    schoolId?: StringFilter<"parents"> | string
    phone?: StringFilter<"parents"> | string
    password?: StringFilter<"parents"> | string
    name?: StringNullableFilter<"parents"> | string | null
    identity?: StringNullableFilter<"parents"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"parents"> | Date | string | null
    isActive?: BoolFilter<"parents"> | boolean
    createdAt?: DateTimeFilter<"parents"> | Date | string
    updatedAt?: DateTimeFilter<"parents"> | Date | string
  }

  export type personalized_tutoring_plansUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    update: XOR<personalized_tutoring_plansUpdateWithoutSchoolsInput, personalized_tutoring_plansUncheckedUpdateWithoutSchoolsInput>
    create: XOR<personalized_tutoring_plansCreateWithoutSchoolsInput, personalized_tutoring_plansUncheckedCreateWithoutSchoolsInput>
  }

  export type personalized_tutoring_plansUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    data: XOR<personalized_tutoring_plansUpdateWithoutSchoolsInput, personalized_tutoring_plansUncheckedUpdateWithoutSchoolsInput>
  }

  export type personalized_tutoring_plansUpdateManyWithWhereWithoutSchoolsInput = {
    where: personalized_tutoring_plansScalarWhereInput
    data: XOR<personalized_tutoring_plansUpdateManyMutationInput, personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type personalized_tutoring_plansScalarWhereInput = {
    AND?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
    OR?: personalized_tutoring_plansScalarWhereInput[]
    NOT?: personalized_tutoring_plansScalarWhereInput | personalized_tutoring_plansScalarWhereInput[]
    id?: StringFilter<"personalized_tutoring_plans"> | string
    teacherId?: StringFilter<"personalized_tutoring_plans"> | string
    schoolId?: StringFilter<"personalized_tutoring_plans"> | string
    title?: StringFilter<"personalized_tutoring_plans"> | string
    subject?: StringFilter<"personalized_tutoring_plans"> | string
    difficulty?: IntFilter<"personalized_tutoring_plans"> | number
    scheduledDate?: StringFilter<"personalized_tutoring_plans"> | string
    scheduledTime?: StringFilter<"personalized_tutoring_plans"> | string
    duration?: IntFilter<"personalized_tutoring_plans"> | number
    actualStartTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    actualEndTime?: DateTimeNullableFilter<"personalized_tutoring_plans"> | Date | string | null
    studentId?: StringFilter<"personalized_tutoring_plans"> | string
    studentName?: StringFilter<"personalized_tutoring_plans"> | string
    studentClass?: StringFilter<"personalized_tutoring_plans"> | string
    knowledgePoints?: JsonFilter<"personalized_tutoring_plans">
    mainProblem?: StringFilter<"personalized_tutoring_plans"> | string
    detailedContent?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    teachingObjectives?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    preparationMaterials?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    tutoringMethods?: JsonFilter<"personalized_tutoring_plans">
    expReward?: IntFilter<"personalized_tutoring_plans"> | number
    pointsReward?: IntFilter<"personalized_tutoring_plans"> | number
    expAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    pointsAwarded?: BoolFilter<"personalized_tutoring_plans"> | boolean
    status?: StringFilter<"personalized_tutoring_plans"> | string
    completionNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    studentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    parentFeedback?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    effectivenessRating?: IntNullableFilter<"personalized_tutoring_plans"> | number | null
    followUpRequired?: BoolFilter<"personalized_tutoring_plans"> | boolean
    followUpDate?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    followUpNotes?: StringNullableFilter<"personalized_tutoring_plans"> | string | null
    attachments?: JsonNullableFilter<"personalized_tutoring_plans">
    totalSessions?: IntFilter<"personalized_tutoring_plans"> | number
    completedSessions?: IntFilter<"personalized_tutoring_plans"> | number
    createdAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
    updatedAt?: DateTimeFilter<"personalized_tutoring_plans"> | Date | string
  }

  export type pk_matchesUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: pk_matchesWhereUniqueInput
    update: XOR<pk_matchesUpdateWithoutSchoolsInput, pk_matchesUncheckedUpdateWithoutSchoolsInput>
    create: XOR<pk_matchesCreateWithoutSchoolsInput, pk_matchesUncheckedCreateWithoutSchoolsInput>
  }

  export type pk_matchesUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: pk_matchesWhereUniqueInput
    data: XOR<pk_matchesUpdateWithoutSchoolsInput, pk_matchesUncheckedUpdateWithoutSchoolsInput>
  }

  export type pk_matchesUpdateManyWithWhereWithoutSchoolsInput = {
    where: pk_matchesScalarWhereInput
    data: XOR<pk_matchesUpdateManyMutationInput, pk_matchesUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type pk_matchesScalarWhereInput = {
    AND?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
    OR?: pk_matchesScalarWhereInput[]
    NOT?: pk_matchesScalarWhereInput | pk_matchesScalarWhereInput[]
    id?: StringFilter<"pk_matches"> | string
    schoolId?: StringFilter<"pk_matches"> | string
    studentA?: StringFilter<"pk_matches"> | string
    studentB?: StringFilter<"pk_matches"> | string
    winnerId?: StringNullableFilter<"pk_matches"> | string | null
    status?: EnumPKStatusFilter<"pk_matches"> | $Enums.PKStatus
    topic?: StringFilter<"pk_matches"> | string
    metadata?: JsonNullableFilter<"pk_matches">
    createdAt?: DateTimeFilter<"pk_matches"> | Date | string
    updatedAt?: DateTimeFilter<"pk_matches"> | Date | string
  }

  export type reward_configsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: reward_configsWhereUniqueInput
    update: XOR<reward_configsUpdateWithoutSchoolsInput, reward_configsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<reward_configsCreateWithoutSchoolsInput, reward_configsUncheckedCreateWithoutSchoolsInput>
  }

  export type reward_configsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: reward_configsWhereUniqueInput
    data: XOR<reward_configsUpdateWithoutSchoolsInput, reward_configsUncheckedUpdateWithoutSchoolsInput>
  }

  export type reward_configsUpdateManyWithWhereWithoutSchoolsInput = {
    where: reward_configsScalarWhereInput
    data: XOR<reward_configsUpdateManyMutationInput, reward_configsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type reward_configsScalarWhereInput = {
    AND?: reward_configsScalarWhereInput | reward_configsScalarWhereInput[]
    OR?: reward_configsScalarWhereInput[]
    NOT?: reward_configsScalarWhereInput | reward_configsScalarWhereInput[]
    id?: StringFilter<"reward_configs"> | string
    schoolId?: StringFilter<"reward_configs"> | string
    module?: StringFilter<"reward_configs"> | string
    category?: StringNullableFilter<"reward_configs"> | string | null
    action?: StringFilter<"reward_configs"> | string
    expReward?: IntFilter<"reward_configs"> | number
    pointsReward?: IntFilter<"reward_configs"> | number
    description?: StringNullableFilter<"reward_configs"> | string | null
    isActive?: BoolFilter<"reward_configs"> | boolean
    createdAt?: DateTimeFilter<"reward_configs"> | Date | string
    updatedAt?: DateTimeFilter<"reward_configs"> | Date | string
  }

  export type student_checkinsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: student_checkinsWhereUniqueInput
    update: XOR<student_checkinsUpdateWithoutSchoolsInput, student_checkinsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<student_checkinsCreateWithoutSchoolsInput, student_checkinsUncheckedCreateWithoutSchoolsInput>
  }

  export type student_checkinsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: student_checkinsWhereUniqueInput
    data: XOR<student_checkinsUpdateWithoutSchoolsInput, student_checkinsUncheckedUpdateWithoutSchoolsInput>
  }

  export type student_checkinsUpdateManyWithWhereWithoutSchoolsInput = {
    where: student_checkinsScalarWhereInput
    data: XOR<student_checkinsUpdateManyMutationInput, student_checkinsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type student_checkinsScalarWhereInput = {
    AND?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
    OR?: student_checkinsScalarWhereInput[]
    NOT?: student_checkinsScalarWhereInput | student_checkinsScalarWhereInput[]
    id?: StringFilter<"student_checkins"> | string
    studentId?: StringFilter<"student_checkins"> | string
    schoolId?: StringFilter<"student_checkins"> | string
    checkinDate?: StringFilter<"student_checkins"> | string
    checkedBy?: StringNullableFilter<"student_checkins"> | string | null
    createdAt?: DateTimeFilter<"student_checkins"> | Date | string
  }

  export type studentsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutSchoolsInput, studentsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<studentsCreateWithoutSchoolsInput, studentsUncheckedCreateWithoutSchoolsInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutSchoolsInput, studentsUncheckedUpdateWithoutSchoolsInput>
  }

  export type studentsUpdateManyWithWhereWithoutSchoolsInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type studentsScalarWhereInput = {
    AND?: studentsScalarWhereInput | studentsScalarWhereInput[]
    OR?: studentsScalarWhereInput[]
    NOT?: studentsScalarWhereInput | studentsScalarWhereInput[]
    id?: StringFilter<"students"> | string
    schoolId?: StringFilter<"students"> | string
    name?: StringFilter<"students"> | string
    className?: StringNullableFilter<"students"> | string | null
    level?: IntFilter<"students"> | number
    points?: IntFilter<"students"> | number
    exp?: IntFilter<"students"> | number
    avatarUrl?: StringNullableFilter<"students"> | string | null
    isActive?: BoolFilter<"students"> | boolean
    createdAt?: DateTimeFilter<"students"> | Date | string
    updatedAt?: DateTimeFilter<"students"> | Date | string
    teamId?: StringNullableFilter<"students"> | string | null
    teacherId?: StringNullableFilter<"students"> | string | null
    currentLesson?: StringNullableFilter<"students"> | string | null
    currentLessonTitle?: StringNullableFilter<"students"> | string | null
    currentUnit?: StringNullableFilter<"students"> | string | null
    currentInviteCode?: StringNullableFilter<"students"> | string | null
    inviteCodeExpiresAt?: DateTimeNullableFilter<"students"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"students"> | Date | string | null
    grade?: StringNullableFilter<"students"> | string | null
    semester?: StringNullableFilter<"students"> | string | null
    currentProgress?: JsonNullableFilter<"students">
  }

  export type task_libraryUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: task_libraryWhereUniqueInput
    update: XOR<task_libraryUpdateWithoutSchoolsInput, task_libraryUncheckedUpdateWithoutSchoolsInput>
    create: XOR<task_libraryCreateWithoutSchoolsInput, task_libraryUncheckedCreateWithoutSchoolsInput>
  }

  export type task_libraryUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: task_libraryWhereUniqueInput
    data: XOR<task_libraryUpdateWithoutSchoolsInput, task_libraryUncheckedUpdateWithoutSchoolsInput>
  }

  export type task_libraryUpdateManyWithWhereWithoutSchoolsInput = {
    where: task_libraryScalarWhereInput
    data: XOR<task_libraryUpdateManyMutationInput, task_libraryUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type task_libraryScalarWhereInput = {
    AND?: task_libraryScalarWhereInput | task_libraryScalarWhereInput[]
    OR?: task_libraryScalarWhereInput[]
    NOT?: task_libraryScalarWhereInput | task_libraryScalarWhereInput[]
    id?: StringFilter<"task_library"> | string
    category?: StringFilter<"task_library"> | string
    name?: StringFilter<"task_library"> | string
    description?: StringNullableFilter<"task_library"> | string | null
    defaultExp?: IntFilter<"task_library"> | number
    type?: EnumTaskTypeFilter<"task_library"> | $Enums.TaskType
    difficulty?: IntNullableFilter<"task_library"> | number | null
    isActive?: BoolFilter<"task_library"> | boolean
    createdAt?: DateTimeFilter<"task_library"> | Date | string
    updatedAt?: DateTimeFilter<"task_library"> | Date | string
    schoolId?: StringFilter<"task_library"> | string
    isGlobal?: BoolFilter<"task_library"> | boolean
    educationalDomain?: StringFilter<"task_library"> | string
    educationalSubcategory?: StringFilter<"task_library"> | string
  }

  export type task_recordsUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: task_recordsWhereUniqueInput
    update: XOR<task_recordsUpdateWithoutSchoolsInput, task_recordsUncheckedUpdateWithoutSchoolsInput>
    create: XOR<task_recordsCreateWithoutSchoolsInput, task_recordsUncheckedCreateWithoutSchoolsInput>
  }

  export type task_recordsUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: task_recordsWhereUniqueInput
    data: XOR<task_recordsUpdateWithoutSchoolsInput, task_recordsUncheckedUpdateWithoutSchoolsInput>
  }

  export type task_recordsUpdateManyWithWhereWithoutSchoolsInput = {
    where: task_recordsScalarWhereInput
    data: XOR<task_recordsUpdateManyMutationInput, task_recordsUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type teachersUpsertWithWhereUniqueWithoutSchoolsInput = {
    where: teachersWhereUniqueInput
    update: XOR<teachersUpdateWithoutSchoolsInput, teachersUncheckedUpdateWithoutSchoolsInput>
    create: XOR<teachersCreateWithoutSchoolsInput, teachersUncheckedCreateWithoutSchoolsInput>
  }

  export type teachersUpdateWithWhereUniqueWithoutSchoolsInput = {
    where: teachersWhereUniqueInput
    data: XOR<teachersUpdateWithoutSchoolsInput, teachersUncheckedUpdateWithoutSchoolsInput>
  }

  export type teachersUpdateManyWithWhereWithoutSchoolsInput = {
    where: teachersScalarWhereInput
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyWithoutSchoolsInput>
  }

  export type teachersScalarWhereInput = {
    AND?: teachersScalarWhereInput | teachersScalarWhereInput[]
    OR?: teachersScalarWhereInput[]
    NOT?: teachersScalarWhereInput | teachersScalarWhereInput[]
    id?: StringFilter<"teachers"> | string
    schoolId?: StringNullableFilter<"teachers"> | string | null
    username?: StringFilter<"teachers"> | string
    password?: StringFilter<"teachers"> | string
    name?: StringFilter<"teachers"> | string
    email?: StringNullableFilter<"teachers"> | string | null
    role?: EnumRoleFilter<"teachers"> | $Enums.Role
    createdAt?: DateTimeFilter<"teachers"> | Date | string
    updatedAt?: DateTimeFilter<"teachers"> | Date | string
    displayName?: StringNullableFilter<"teachers"> | string | null
    primaryClassName?: StringNullableFilter<"teachers"> | string | null
  }

  export type badgesCreateWithoutStudent_badgesInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutBadgesInput
  }

  export type badgesUncheckedCreateWithoutStudent_badgesInput = {
    id?: string
    schoolId: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type badgesCreateOrConnectWithoutStudent_badgesInput = {
    where: badgesWhereUniqueInput
    create: XOR<badgesCreateWithoutStudent_badgesInput, badgesUncheckedCreateWithoutStudent_badgesInput>
  }

  export type studentsCreateWithoutStudent_badgesInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_badgesInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_badgesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_badgesInput, studentsUncheckedCreateWithoutStudent_badgesInput>
  }

  export type badgesUpsertWithoutStudent_badgesInput = {
    update: XOR<badgesUpdateWithoutStudent_badgesInput, badgesUncheckedUpdateWithoutStudent_badgesInput>
    create: XOR<badgesCreateWithoutStudent_badgesInput, badgesUncheckedCreateWithoutStudent_badgesInput>
    where?: badgesWhereInput
  }

  export type badgesUpdateToOneWithWhereWithoutStudent_badgesInput = {
    where?: badgesWhereInput
    data: XOR<badgesUpdateWithoutStudent_badgesInput, badgesUncheckedUpdateWithoutStudent_badgesInput>
  }

  export type badgesUpdateWithoutStudent_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateWithoutStudent_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsUpsertWithoutStudent_badgesInput = {
    update: XOR<studentsUpdateWithoutStudent_badgesInput, studentsUncheckedUpdateWithoutStudent_badgesInput>
    create: XOR<studentsCreateWithoutStudent_badgesInput, studentsUncheckedCreateWithoutStudent_badgesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_badgesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_badgesInput, studentsUncheckedUpdateWithoutStudent_badgesInput>
  }

  export type studentsUpdateWithoutStudent_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_badgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type campaignsCreateWithoutStudentsInput = {
    id?: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type campaignsUncheckedCreateWithoutStudentsInput = {
    id?: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type campaignsCreateOrConnectWithoutStudentsInput = {
    where: campaignsWhereUniqueInput
    create: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput>
  }

  export type campaignsCreateManyStudentsInputEnvelope = {
    data: campaignsCreateManyStudentsInput | campaignsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type challenge_participantsCreateWithoutStudentsInput = {
    id?: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
    challenges: challengesCreateNestedOneWithoutChallenge_participantsInput
  }

  export type challenge_participantsUncheckedCreateWithoutStudentsInput = {
    id?: string
    challengeId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type challenge_participantsCreateOrConnectWithoutStudentsInput = {
    where: challenge_participantsWhereUniqueInput
    create: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput>
  }

  export type challenge_participantsCreateManyStudentsInputEnvelope = {
    data: challenge_participantsCreateManyStudentsInput | challenge_participantsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type daily_summariesCreateWithoutStudentsInput = {
    id?: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parents: parentsCreateNestedOneWithoutDaily_summariesInput
  }

  export type daily_summariesUncheckedCreateWithoutStudentsInput = {
    id?: string
    parentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type daily_summariesCreateOrConnectWithoutStudentsInput = {
    where: daily_summariesWhereUniqueInput
    create: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput>
  }

  export type daily_summariesCreateManyStudentsInputEnvelope = {
    data: daily_summariesCreateManyStudentsInput | daily_summariesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type habit_logsCreateWithoutStudentsInput = {
    id?: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
    habits: habitsCreateNestedOneWithoutHabit_logsInput
    schools: schoolsCreateNestedOneWithoutHabit_logsInput
  }

  export type habit_logsUncheckedCreateWithoutStudentsInput = {
    id?: string
    schoolId: string
    habitId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsCreateOrConnectWithoutStudentsInput = {
    where: habit_logsWhereUniqueInput
    create: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput>
  }

  export type habit_logsCreateManyStudentsInputEnvelope = {
    data: habit_logsCreateManyStudentsInput | habit_logsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type mistakesCreateWithoutStudentsInput = {
    id?: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
    schools: schoolsCreateNestedOneWithoutMistakesInput
  }

  export type mistakesUncheckedCreateWithoutStudentsInput = {
    id?: string
    schoolId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type mistakesCreateOrConnectWithoutStudentsInput = {
    where: mistakesWhereUniqueInput
    create: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput>
  }

  export type mistakesCreateManyStudentsInputEnvelope = {
    data: mistakesCreateManyStudentsInput | mistakesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type parent_student_bindingsCreateWithoutStudentsInput = {
    id?: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
    parents: parentsCreateNestedOneWithoutParent_student_bindingsInput
  }

  export type parent_student_bindingsUncheckedCreateWithoutStudentsInput = {
    id?: string
    parentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type parent_student_bindingsCreateOrConnectWithoutStudentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    create: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput>
  }

  export type parent_student_bindingsCreateManyStudentsInputEnvelope = {
    data: parent_student_bindingsCreateManyStudentsInput | parent_student_bindingsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type personalized_tutoring_plansCreateWithoutStudentsInput = {
    id?: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPersonalized_tutoring_plansInput
    teachers: teachersCreateNestedOneWithoutPersonalized_tutoring_plansInput
  }

  export type personalized_tutoring_plansUncheckedCreateWithoutStudentsInput = {
    id?: string
    teacherId: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansCreateOrConnectWithoutStudentsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    create: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput>
  }

  export type personalized_tutoring_plansCreateManyStudentsInputEnvelope = {
    data: personalized_tutoring_plansCreateManyStudentsInput | personalized_tutoring_plansCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type pk_matchesCreateWithoutPlayerAInput = {
    id?: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPk_matchesInput
    playerB: studentsCreateNestedOneWithoutPk_matches_studentBInput
    winner?: studentsCreateNestedOneWithoutPk_matches_winnerInput
  }

  export type pk_matchesUncheckedCreateWithoutPlayerAInput = {
    id?: string
    schoolId: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateOrConnectWithoutPlayerAInput = {
    where: pk_matchesWhereUniqueInput
    create: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput>
  }

  export type pk_matchesCreateManyPlayerAInputEnvelope = {
    data: pk_matchesCreateManyPlayerAInput | pk_matchesCreateManyPlayerAInput[]
    skipDuplicates?: boolean
  }

  export type pk_matchesCreateWithoutPlayerBInput = {
    id?: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPk_matchesInput
    playerA: studentsCreateNestedOneWithoutPk_matches_studentAInput
    winner?: studentsCreateNestedOneWithoutPk_matches_winnerInput
  }

  export type pk_matchesUncheckedCreateWithoutPlayerBInput = {
    id?: string
    schoolId: string
    studentA: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateOrConnectWithoutPlayerBInput = {
    where: pk_matchesWhereUniqueInput
    create: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput>
  }

  export type pk_matchesCreateManyPlayerBInputEnvelope = {
    data: pk_matchesCreateManyPlayerBInput | pk_matchesCreateManyPlayerBInput[]
    skipDuplicates?: boolean
  }

  export type pk_matchesCreateWithoutWinnerInput = {
    id?: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPk_matchesInput
    playerA: studentsCreateNestedOneWithoutPk_matches_studentAInput
    playerB: studentsCreateNestedOneWithoutPk_matches_studentBInput
  }

  export type pk_matchesUncheckedCreateWithoutWinnerInput = {
    id?: string
    schoolId: string
    studentA: string
    studentB: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateOrConnectWithoutWinnerInput = {
    where: pk_matchesWhereUniqueInput
    create: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput>
  }

  export type pk_matchesCreateManyWinnerInputEnvelope = {
    data: pk_matchesCreateManyWinnerInput | pk_matchesCreateManyWinnerInput[]
    skipDuplicates?: boolean
  }

  export type student_badgesCreateWithoutStudentsInput = {
    id?: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
    badges: badgesCreateNestedOneWithoutStudent_badgesInput
  }

  export type student_badgesUncheckedCreateWithoutStudentsInput = {
    id?: string
    badgeId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_badgesCreateOrConnectWithoutStudentsInput = {
    where: student_badgesWhereUniqueInput
    create: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput>
  }

  export type student_badgesCreateManyStudentsInputEnvelope = {
    data: student_badgesCreateManyStudentsInput | student_badgesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_checkinsCreateWithoutStudentsInput = {
    id?: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
    schools: schoolsCreateNestedOneWithoutStudent_checkinsInput
  }

  export type student_checkinsUncheckedCreateWithoutStudentsInput = {
    id?: string
    schoolId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type student_checkinsCreateOrConnectWithoutStudentsInput = {
    where: student_checkinsWhereUniqueInput
    create: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput>
  }

  export type student_checkinsCreateManyStudentsInputEnvelope = {
    data: student_checkinsCreateManyStudentsInput | student_checkinsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type schoolsCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutStudentsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutStudentsInput, schoolsUncheckedCreateWithoutStudentsInput>
  }

  export type teachersCreateWithoutStudentsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutTeachersInput
    schools?: schoolsCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutStudentsInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutTeachersInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutStudentsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutStudentsInput, teachersUncheckedCreateWithoutStudentsInput>
  }

  export type task_recordsCreateWithoutStudentsInput = {
    id?: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
    lesson_plans?: lesson_plansCreateNestedOneWithoutTask_recordsInput
    schools: schoolsCreateNestedOneWithoutTask_recordsInput
  }

  export type task_recordsUncheckedCreateWithoutStudentsInput = {
    id?: string
    schoolId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsCreateOrConnectWithoutStudentsInput = {
    where: task_recordsWhereUniqueInput
    create: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput>
  }

  export type task_recordsCreateManyStudentsInputEnvelope = {
    data: task_recordsCreateManyStudentsInput | task_recordsCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type campaignsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: campaignsWhereUniqueInput
    update: XOR<campaignsUpdateWithoutStudentsInput, campaignsUncheckedUpdateWithoutStudentsInput>
    create: XOR<campaignsCreateWithoutStudentsInput, campaignsUncheckedCreateWithoutStudentsInput>
  }

  export type campaignsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: campaignsWhereUniqueInput
    data: XOR<campaignsUpdateWithoutStudentsInput, campaignsUncheckedUpdateWithoutStudentsInput>
  }

  export type campaignsUpdateManyWithWhereWithoutStudentsInput = {
    where: campaignsScalarWhereInput
    data: XOR<campaignsUpdateManyMutationInput, campaignsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type campaignsScalarWhereInput = {
    AND?: campaignsScalarWhereInput | campaignsScalarWhereInput[]
    OR?: campaignsScalarWhereInput[]
    NOT?: campaignsScalarWhereInput | campaignsScalarWhereInput[]
    id?: StringFilter<"campaigns"> | string
    studentId?: StringFilter<"campaigns"> | string
    type?: StringFilter<"campaigns"> | string
    status?: StringFilter<"campaigns"> | string
    metadata?: JsonNullableFilter<"campaigns">
    createdAt?: DateTimeFilter<"campaigns"> | Date | string
    updatedAt?: DateTimeFilter<"campaigns"> | Date | string
  }

  export type challenge_participantsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: challenge_participantsWhereUniqueInput
    update: XOR<challenge_participantsUpdateWithoutStudentsInput, challenge_participantsUncheckedUpdateWithoutStudentsInput>
    create: XOR<challenge_participantsCreateWithoutStudentsInput, challenge_participantsUncheckedCreateWithoutStudentsInput>
  }

  export type challenge_participantsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: challenge_participantsWhereUniqueInput
    data: XOR<challenge_participantsUpdateWithoutStudentsInput, challenge_participantsUncheckedUpdateWithoutStudentsInput>
  }

  export type challenge_participantsUpdateManyWithWhereWithoutStudentsInput = {
    where: challenge_participantsScalarWhereInput
    data: XOR<challenge_participantsUpdateManyMutationInput, challenge_participantsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type daily_summariesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: daily_summariesWhereUniqueInput
    update: XOR<daily_summariesUpdateWithoutStudentsInput, daily_summariesUncheckedUpdateWithoutStudentsInput>
    create: XOR<daily_summariesCreateWithoutStudentsInput, daily_summariesUncheckedCreateWithoutStudentsInput>
  }

  export type daily_summariesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: daily_summariesWhereUniqueInput
    data: XOR<daily_summariesUpdateWithoutStudentsInput, daily_summariesUncheckedUpdateWithoutStudentsInput>
  }

  export type daily_summariesUpdateManyWithWhereWithoutStudentsInput = {
    where: daily_summariesScalarWhereInput
    data: XOR<daily_summariesUpdateManyMutationInput, daily_summariesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type daily_summariesScalarWhereInput = {
    AND?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
    OR?: daily_summariesScalarWhereInput[]
    NOT?: daily_summariesScalarWhereInput | daily_summariesScalarWhereInput[]
    id?: StringFilter<"daily_summaries"> | string
    studentId?: StringFilter<"daily_summaries"> | string
    parentId?: StringFilter<"daily_summaries"> | string
    date?: StringFilter<"daily_summaries"> | string
    parentLiked?: BoolFilter<"daily_summaries"> | boolean
    parentComment?: StringNullableFilter<"daily_summaries"> | string | null
    teacherRead?: BoolFilter<"daily_summaries"> | boolean
    createdAt?: DateTimeFilter<"daily_summaries"> | Date | string
    updatedAt?: DateTimeFilter<"daily_summaries"> | Date | string
  }

  export type habit_logsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: habit_logsWhereUniqueInput
    update: XOR<habit_logsUpdateWithoutStudentsInput, habit_logsUncheckedUpdateWithoutStudentsInput>
    create: XOR<habit_logsCreateWithoutStudentsInput, habit_logsUncheckedCreateWithoutStudentsInput>
  }

  export type habit_logsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: habit_logsWhereUniqueInput
    data: XOR<habit_logsUpdateWithoutStudentsInput, habit_logsUncheckedUpdateWithoutStudentsInput>
  }

  export type habit_logsUpdateManyWithWhereWithoutStudentsInput = {
    where: habit_logsScalarWhereInput
    data: XOR<habit_logsUpdateManyMutationInput, habit_logsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type mistakesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: mistakesWhereUniqueInput
    update: XOR<mistakesUpdateWithoutStudentsInput, mistakesUncheckedUpdateWithoutStudentsInput>
    create: XOR<mistakesCreateWithoutStudentsInput, mistakesUncheckedCreateWithoutStudentsInput>
  }

  export type mistakesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: mistakesWhereUniqueInput
    data: XOR<mistakesUpdateWithoutStudentsInput, mistakesUncheckedUpdateWithoutStudentsInput>
  }

  export type mistakesUpdateManyWithWhereWithoutStudentsInput = {
    where: mistakesScalarWhereInput
    data: XOR<mistakesUpdateManyMutationInput, mistakesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type parent_student_bindingsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    update: XOR<parent_student_bindingsUpdateWithoutStudentsInput, parent_student_bindingsUncheckedUpdateWithoutStudentsInput>
    create: XOR<parent_student_bindingsCreateWithoutStudentsInput, parent_student_bindingsUncheckedCreateWithoutStudentsInput>
  }

  export type parent_student_bindingsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    data: XOR<parent_student_bindingsUpdateWithoutStudentsInput, parent_student_bindingsUncheckedUpdateWithoutStudentsInput>
  }

  export type parent_student_bindingsUpdateManyWithWhereWithoutStudentsInput = {
    where: parent_student_bindingsScalarWhereInput
    data: XOR<parent_student_bindingsUpdateManyMutationInput, parent_student_bindingsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type parent_student_bindingsScalarWhereInput = {
    AND?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
    OR?: parent_student_bindingsScalarWhereInput[]
    NOT?: parent_student_bindingsScalarWhereInput | parent_student_bindingsScalarWhereInput[]
    id?: StringFilter<"parent_student_bindings"> | string
    parentId?: StringFilter<"parent_student_bindings"> | string
    studentId?: StringFilter<"parent_student_bindings"> | string
    inviteCode?: StringFilter<"parent_student_bindings"> | string
    bindingTime?: DateTimeFilter<"parent_student_bindings"> | Date | string
    isActive?: BoolFilter<"parent_student_bindings"> | boolean
  }

  export type personalized_tutoring_plansUpsertWithWhereUniqueWithoutStudentsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    update: XOR<personalized_tutoring_plansUpdateWithoutStudentsInput, personalized_tutoring_plansUncheckedUpdateWithoutStudentsInput>
    create: XOR<personalized_tutoring_plansCreateWithoutStudentsInput, personalized_tutoring_plansUncheckedCreateWithoutStudentsInput>
  }

  export type personalized_tutoring_plansUpdateWithWhereUniqueWithoutStudentsInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    data: XOR<personalized_tutoring_plansUpdateWithoutStudentsInput, personalized_tutoring_plansUncheckedUpdateWithoutStudentsInput>
  }

  export type personalized_tutoring_plansUpdateManyWithWhereWithoutStudentsInput = {
    where: personalized_tutoring_plansScalarWhereInput
    data: XOR<personalized_tutoring_plansUpdateManyMutationInput, personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsInput>
  }

  export type pk_matchesUpsertWithWhereUniqueWithoutPlayerAInput = {
    where: pk_matchesWhereUniqueInput
    update: XOR<pk_matchesUpdateWithoutPlayerAInput, pk_matchesUncheckedUpdateWithoutPlayerAInput>
    create: XOR<pk_matchesCreateWithoutPlayerAInput, pk_matchesUncheckedCreateWithoutPlayerAInput>
  }

  export type pk_matchesUpdateWithWhereUniqueWithoutPlayerAInput = {
    where: pk_matchesWhereUniqueInput
    data: XOR<pk_matchesUpdateWithoutPlayerAInput, pk_matchesUncheckedUpdateWithoutPlayerAInput>
  }

  export type pk_matchesUpdateManyWithWhereWithoutPlayerAInput = {
    where: pk_matchesScalarWhereInput
    data: XOR<pk_matchesUpdateManyMutationInput, pk_matchesUncheckedUpdateManyWithoutPlayerAInput>
  }

  export type pk_matchesUpsertWithWhereUniqueWithoutPlayerBInput = {
    where: pk_matchesWhereUniqueInput
    update: XOR<pk_matchesUpdateWithoutPlayerBInput, pk_matchesUncheckedUpdateWithoutPlayerBInput>
    create: XOR<pk_matchesCreateWithoutPlayerBInput, pk_matchesUncheckedCreateWithoutPlayerBInput>
  }

  export type pk_matchesUpdateWithWhereUniqueWithoutPlayerBInput = {
    where: pk_matchesWhereUniqueInput
    data: XOR<pk_matchesUpdateWithoutPlayerBInput, pk_matchesUncheckedUpdateWithoutPlayerBInput>
  }

  export type pk_matchesUpdateManyWithWhereWithoutPlayerBInput = {
    where: pk_matchesScalarWhereInput
    data: XOR<pk_matchesUpdateManyMutationInput, pk_matchesUncheckedUpdateManyWithoutPlayerBInput>
  }

  export type pk_matchesUpsertWithWhereUniqueWithoutWinnerInput = {
    where: pk_matchesWhereUniqueInput
    update: XOR<pk_matchesUpdateWithoutWinnerInput, pk_matchesUncheckedUpdateWithoutWinnerInput>
    create: XOR<pk_matchesCreateWithoutWinnerInput, pk_matchesUncheckedCreateWithoutWinnerInput>
  }

  export type pk_matchesUpdateWithWhereUniqueWithoutWinnerInput = {
    where: pk_matchesWhereUniqueInput
    data: XOR<pk_matchesUpdateWithoutWinnerInput, pk_matchesUncheckedUpdateWithoutWinnerInput>
  }

  export type pk_matchesUpdateManyWithWhereWithoutWinnerInput = {
    where: pk_matchesScalarWhereInput
    data: XOR<pk_matchesUpdateManyMutationInput, pk_matchesUncheckedUpdateManyWithoutWinnerInput>
  }

  export type student_badgesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_badgesWhereUniqueInput
    update: XOR<student_badgesUpdateWithoutStudentsInput, student_badgesUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_badgesCreateWithoutStudentsInput, student_badgesUncheckedCreateWithoutStudentsInput>
  }

  export type student_badgesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_badgesWhereUniqueInput
    data: XOR<student_badgesUpdateWithoutStudentsInput, student_badgesUncheckedUpdateWithoutStudentsInput>
  }

  export type student_badgesUpdateManyWithWhereWithoutStudentsInput = {
    where: student_badgesScalarWhereInput
    data: XOR<student_badgesUpdateManyMutationInput, student_badgesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type student_checkinsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_checkinsWhereUniqueInput
    update: XOR<student_checkinsUpdateWithoutStudentsInput, student_checkinsUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_checkinsCreateWithoutStudentsInput, student_checkinsUncheckedCreateWithoutStudentsInput>
  }

  export type student_checkinsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_checkinsWhereUniqueInput
    data: XOR<student_checkinsUpdateWithoutStudentsInput, student_checkinsUncheckedUpdateWithoutStudentsInput>
  }

  export type student_checkinsUpdateManyWithWhereWithoutStudentsInput = {
    where: student_checkinsScalarWhereInput
    data: XOR<student_checkinsUpdateManyMutationInput, student_checkinsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type schoolsUpsertWithoutStudentsInput = {
    update: XOR<schoolsUpdateWithoutStudentsInput, schoolsUncheckedUpdateWithoutStudentsInput>
    create: XOR<schoolsCreateWithoutStudentsInput, schoolsUncheckedCreateWithoutStudentsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutStudentsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutStudentsInput, schoolsUncheckedUpdateWithoutStudentsInput>
  }

  export type schoolsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type teachersUpsertWithoutStudentsInput = {
    update: XOR<teachersUpdateWithoutStudentsInput, teachersUncheckedUpdateWithoutStudentsInput>
    create: XOR<teachersCreateWithoutStudentsInput, teachersUncheckedCreateWithoutStudentsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutStudentsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutStudentsInput, teachersUncheckedUpdateWithoutStudentsInput>
  }

  export type teachersUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput
    schools?: schoolsUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUncheckedUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type task_recordsUpsertWithWhereUniqueWithoutStudentsInput = {
    where: task_recordsWhereUniqueInput
    update: XOR<task_recordsUpdateWithoutStudentsInput, task_recordsUncheckedUpdateWithoutStudentsInput>
    create: XOR<task_recordsCreateWithoutStudentsInput, task_recordsUncheckedCreateWithoutStudentsInput>
  }

  export type task_recordsUpdateWithWhereUniqueWithoutStudentsInput = {
    where: task_recordsWhereUniqueInput
    data: XOR<task_recordsUpdateWithoutStudentsInput, task_recordsUncheckedUpdateWithoutStudentsInput>
  }

  export type task_recordsUpdateManyWithWhereWithoutStudentsInput = {
    where: task_recordsScalarWhereInput
    data: XOR<task_recordsUpdateManyMutationInput, task_recordsUncheckedUpdateManyWithoutStudentsInput>
  }

  export type schoolsCreateWithoutStudent_checkinsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutStudent_checkinsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutStudent_checkinsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutStudent_checkinsInput, schoolsUncheckedCreateWithoutStudent_checkinsInput>
  }

  export type studentsCreateWithoutStudent_checkinsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_checkinsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_checkinsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_checkinsInput, studentsUncheckedCreateWithoutStudent_checkinsInput>
  }

  export type schoolsUpsertWithoutStudent_checkinsInput = {
    update: XOR<schoolsUpdateWithoutStudent_checkinsInput, schoolsUncheckedUpdateWithoutStudent_checkinsInput>
    create: XOR<schoolsCreateWithoutStudent_checkinsInput, schoolsUncheckedCreateWithoutStudent_checkinsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutStudent_checkinsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutStudent_checkinsInput, schoolsUncheckedUpdateWithoutStudent_checkinsInput>
  }

  export type schoolsUpdateWithoutStudent_checkinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutStudent_checkinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutStudent_checkinsInput = {
    update: XOR<studentsUpdateWithoutStudent_checkinsInput, studentsUncheckedUpdateWithoutStudent_checkinsInput>
    create: XOR<studentsCreateWithoutStudent_checkinsInput, studentsUncheckedCreateWithoutStudent_checkinsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_checkinsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_checkinsInput, studentsUncheckedUpdateWithoutStudent_checkinsInput>
  }

  export type studentsUpdateWithoutStudent_checkinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_checkinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type schoolsCreateWithoutTask_libraryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutTask_libraryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutTask_libraryInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutTask_libraryInput, schoolsUncheckedCreateWithoutTask_libraryInput>
  }

  export type schoolsUpsertWithoutTask_libraryInput = {
    update: XOR<schoolsUpdateWithoutTask_libraryInput, schoolsUncheckedUpdateWithoutTask_libraryInput>
    create: XOR<schoolsCreateWithoutTask_libraryInput, schoolsUncheckedCreateWithoutTask_libraryInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutTask_libraryInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutTask_libraryInput, schoolsUncheckedUpdateWithoutTask_libraryInput>
  }

  export type schoolsUpdateWithoutTask_libraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutTask_libraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type lesson_plansCreateWithoutTask_recordsInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    schools: schoolsCreateNestedOneWithoutLesson_plansInput
    teachers: teachersCreateNestedOneWithoutLesson_plansInput
  }

  export type lesson_plansUncheckedCreateWithoutTask_recordsInput = {
    id?: string
    schoolId: string
    teacherId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
  }

  export type lesson_plansCreateOrConnectWithoutTask_recordsInput = {
    where: lesson_plansWhereUniqueInput
    create: XOR<lesson_plansCreateWithoutTask_recordsInput, lesson_plansUncheckedCreateWithoutTask_recordsInput>
  }

  export type schoolsCreateWithoutTask_recordsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutTask_recordsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutTask_recordsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutTask_recordsInput, schoolsUncheckedCreateWithoutTask_recordsInput>
  }

  export type studentsCreateWithoutTask_recordsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutTask_recordsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutTask_recordsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutTask_recordsInput, studentsUncheckedCreateWithoutTask_recordsInput>
  }

  export type lesson_plansUpsertWithoutTask_recordsInput = {
    update: XOR<lesson_plansUpdateWithoutTask_recordsInput, lesson_plansUncheckedUpdateWithoutTask_recordsInput>
    create: XOR<lesson_plansCreateWithoutTask_recordsInput, lesson_plansUncheckedCreateWithoutTask_recordsInput>
    where?: lesson_plansWhereInput
  }

  export type lesson_plansUpdateToOneWithWhereWithoutTask_recordsInput = {
    where?: lesson_plansWhereInput
    data: XOR<lesson_plansUpdateWithoutTask_recordsInput, lesson_plansUncheckedUpdateWithoutTask_recordsInput>
  }

  export type lesson_plansUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    schools?: schoolsUpdateOneRequiredWithoutLesson_plansNestedInput
    teachers?: teachersUpdateOneRequiredWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type schoolsUpsertWithoutTask_recordsInput = {
    update: XOR<schoolsUpdateWithoutTask_recordsInput, schoolsUncheckedUpdateWithoutTask_recordsInput>
    create: XOR<schoolsCreateWithoutTask_recordsInput, schoolsUncheckedCreateWithoutTask_recordsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutTask_recordsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutTask_recordsInput, schoolsUncheckedUpdateWithoutTask_recordsInput>
  }

  export type schoolsUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutTask_recordsInput = {
    update: XOR<studentsUpdateWithoutTask_recordsInput, studentsUncheckedUpdateWithoutTask_recordsInput>
    create: XOR<studentsCreateWithoutTask_recordsInput, studentsUncheckedCreateWithoutTask_recordsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutTask_recordsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutTask_recordsInput, studentsUncheckedUpdateWithoutTask_recordsInput>
  }

  export type studentsUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutTask_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type challengesCreateWithoutTeachersInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsCreateNestedManyWithoutChallengesInput
    schools: schoolsCreateNestedOneWithoutChallengesInput
  }

  export type challengesUncheckedCreateWithoutTeachersInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutChallengesInput
  }

  export type challengesCreateOrConnectWithoutTeachersInput = {
    where: challengesWhereUniqueInput
    create: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput>
  }

  export type challengesCreateManyTeachersInputEnvelope = {
    data: challengesCreateManyTeachersInput | challengesCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type lesson_plansCreateWithoutTeachersInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    schools: schoolsCreateNestedOneWithoutLesson_plansInput
    task_records?: task_recordsCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansUncheckedCreateWithoutTeachersInput = {
    id?: string
    schoolId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    task_records?: task_recordsUncheckedCreateNestedManyWithoutLesson_plansInput
  }

  export type lesson_plansCreateOrConnectWithoutTeachersInput = {
    where: lesson_plansWhereUniqueInput
    create: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput>
  }

  export type lesson_plansCreateManyTeachersInputEnvelope = {
    data: lesson_plansCreateManyTeachersInput | lesson_plansCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type personalized_tutoring_plansCreateWithoutTeachersInput = {
    id?: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schools: schoolsCreateNestedOneWithoutPersonalized_tutoring_plansInput
    students: studentsCreateNestedOneWithoutPersonalized_tutoring_plansInput
  }

  export type personalized_tutoring_plansUncheckedCreateWithoutTeachersInput = {
    id?: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansCreateOrConnectWithoutTeachersInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    create: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput>
  }

  export type personalized_tutoring_plansCreateManyTeachersInputEnvelope = {
    data: personalized_tutoring_plansCreateManyTeachersInput | personalized_tutoring_plansCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutTeachersInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutTeachersInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutTeachersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput>
  }

  export type studentsCreateManyTeachersInputEnvelope = {
    data: studentsCreateManyTeachersInput | studentsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type schoolsCreateWithoutTeachersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutTeachersInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutTeachersInput, schoolsUncheckedCreateWithoutTeachersInput>
  }

  export type challengesUpsertWithWhereUniqueWithoutTeachersInput = {
    where: challengesWhereUniqueInput
    update: XOR<challengesUpdateWithoutTeachersInput, challengesUncheckedUpdateWithoutTeachersInput>
    create: XOR<challengesCreateWithoutTeachersInput, challengesUncheckedCreateWithoutTeachersInput>
  }

  export type challengesUpdateWithWhereUniqueWithoutTeachersInput = {
    where: challengesWhereUniqueInput
    data: XOR<challengesUpdateWithoutTeachersInput, challengesUncheckedUpdateWithoutTeachersInput>
  }

  export type challengesUpdateManyWithWhereWithoutTeachersInput = {
    where: challengesScalarWhereInput
    data: XOR<challengesUpdateManyMutationInput, challengesUncheckedUpdateManyWithoutTeachersInput>
  }

  export type lesson_plansUpsertWithWhereUniqueWithoutTeachersInput = {
    where: lesson_plansWhereUniqueInput
    update: XOR<lesson_plansUpdateWithoutTeachersInput, lesson_plansUncheckedUpdateWithoutTeachersInput>
    create: XOR<lesson_plansCreateWithoutTeachersInput, lesson_plansUncheckedCreateWithoutTeachersInput>
  }

  export type lesson_plansUpdateWithWhereUniqueWithoutTeachersInput = {
    where: lesson_plansWhereUniqueInput
    data: XOR<lesson_plansUpdateWithoutTeachersInput, lesson_plansUncheckedUpdateWithoutTeachersInput>
  }

  export type lesson_plansUpdateManyWithWhereWithoutTeachersInput = {
    where: lesson_plansScalarWhereInput
    data: XOR<lesson_plansUpdateManyMutationInput, lesson_plansUncheckedUpdateManyWithoutTeachersInput>
  }

  export type personalized_tutoring_plansUpsertWithWhereUniqueWithoutTeachersInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    update: XOR<personalized_tutoring_plansUpdateWithoutTeachersInput, personalized_tutoring_plansUncheckedUpdateWithoutTeachersInput>
    create: XOR<personalized_tutoring_plansCreateWithoutTeachersInput, personalized_tutoring_plansUncheckedCreateWithoutTeachersInput>
  }

  export type personalized_tutoring_plansUpdateWithWhereUniqueWithoutTeachersInput = {
    where: personalized_tutoring_plansWhereUniqueInput
    data: XOR<personalized_tutoring_plansUpdateWithoutTeachersInput, personalized_tutoring_plansUncheckedUpdateWithoutTeachersInput>
  }

  export type personalized_tutoring_plansUpdateManyWithWhereWithoutTeachersInput = {
    where: personalized_tutoring_plansScalarWhereInput
    data: XOR<personalized_tutoring_plansUpdateManyMutationInput, personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersInput>
  }

  export type studentsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutTeachersInput, studentsUncheckedUpdateWithoutTeachersInput>
    create: XOR<studentsCreateWithoutTeachersInput, studentsUncheckedCreateWithoutTeachersInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutTeachersInput, studentsUncheckedUpdateWithoutTeachersInput>
  }

  export type studentsUpdateManyWithWhereWithoutTeachersInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type schoolsUpsertWithoutTeachersInput = {
    update: XOR<schoolsUpdateWithoutTeachersInput, schoolsUncheckedUpdateWithoutTeachersInput>
    create: XOR<schoolsCreateWithoutTeachersInput, schoolsUncheckedCreateWithoutTeachersInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutTeachersInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutTeachersInput, schoolsUncheckedUpdateWithoutTeachersInput>
  }

  export type schoolsUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutPersonalized_tutoring_plansInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
  }

  export type studentsCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutPersonalized_tutoring_plansInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutPersonalized_tutoring_plansInput, studentsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
  }

  export type teachersCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutTeachersInput
    students?: studentsCreateNestedManyWithoutTeachersInput
    schools?: schoolsCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutPersonalized_tutoring_plansInput = {
    id?: string
    schoolId?: string | null
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
    challenges?: challengesUncheckedCreateNestedManyWithoutTeachersInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutTeachersInput
    students?: studentsUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutPersonalized_tutoring_plansInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutPersonalized_tutoring_plansInput, teachersUncheckedCreateWithoutPersonalized_tutoring_plansInput>
  }

  export type schoolsUpsertWithoutPersonalized_tutoring_plansInput = {
    update: XOR<schoolsUpdateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
    create: XOR<schoolsCreateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutPersonalized_tutoring_plansInput, schoolsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type schoolsUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type studentsUpsertWithoutPersonalized_tutoring_plansInput = {
    update: XOR<studentsUpdateWithoutPersonalized_tutoring_plansInput, studentsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
    create: XOR<studentsCreateWithoutPersonalized_tutoring_plansInput, studentsUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutPersonalized_tutoring_plansInput, studentsUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type studentsUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersUpsertWithoutPersonalized_tutoring_plansInput = {
    update: XOR<teachersUpdateWithoutPersonalized_tutoring_plansInput, teachersUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
    create: XOR<teachersCreateWithoutPersonalized_tutoring_plansInput, teachersUncheckedCreateWithoutPersonalized_tutoring_plansInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutPersonalized_tutoring_plansInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutPersonalized_tutoring_plansInput, teachersUncheckedUpdateWithoutPersonalized_tutoring_plansInput>
  }

  export type teachersUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutTeachersNestedInput
    students?: studentsUpdateManyWithoutTeachersNestedInput
    schools?: schoolsUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutPersonalized_tutoring_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUncheckedUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput
    students?: studentsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type daily_summariesCreateWithoutParentsInput = {
    id?: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students: studentsCreateNestedOneWithoutDaily_summariesInput
  }

  export type daily_summariesUncheckedCreateWithoutParentsInput = {
    id?: string
    studentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type daily_summariesCreateOrConnectWithoutParentsInput = {
    where: daily_summariesWhereUniqueInput
    create: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput>
  }

  export type daily_summariesCreateManyParentsInputEnvelope = {
    data: daily_summariesCreateManyParentsInput | daily_summariesCreateManyParentsInput[]
    skipDuplicates?: boolean
  }

  export type parent_student_bindingsCreateWithoutParentsInput = {
    id?: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
    students: studentsCreateNestedOneWithoutParent_student_bindingsInput
  }

  export type parent_student_bindingsUncheckedCreateWithoutParentsInput = {
    id?: string
    studentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type parent_student_bindingsCreateOrConnectWithoutParentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    create: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput>
  }

  export type parent_student_bindingsCreateManyParentsInputEnvelope = {
    data: parent_student_bindingsCreateManyParentsInput | parent_student_bindingsCreateManyParentsInput[]
    skipDuplicates?: boolean
  }

  export type schoolsCreateWithoutParentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutParentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    reward_configs?: reward_configsUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutParentsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutParentsInput, schoolsUncheckedCreateWithoutParentsInput>
  }

  export type daily_summariesUpsertWithWhereUniqueWithoutParentsInput = {
    where: daily_summariesWhereUniqueInput
    update: XOR<daily_summariesUpdateWithoutParentsInput, daily_summariesUncheckedUpdateWithoutParentsInput>
    create: XOR<daily_summariesCreateWithoutParentsInput, daily_summariesUncheckedCreateWithoutParentsInput>
  }

  export type daily_summariesUpdateWithWhereUniqueWithoutParentsInput = {
    where: daily_summariesWhereUniqueInput
    data: XOR<daily_summariesUpdateWithoutParentsInput, daily_summariesUncheckedUpdateWithoutParentsInput>
  }

  export type daily_summariesUpdateManyWithWhereWithoutParentsInput = {
    where: daily_summariesScalarWhereInput
    data: XOR<daily_summariesUpdateManyMutationInput, daily_summariesUncheckedUpdateManyWithoutParentsInput>
  }

  export type parent_student_bindingsUpsertWithWhereUniqueWithoutParentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    update: XOR<parent_student_bindingsUpdateWithoutParentsInput, parent_student_bindingsUncheckedUpdateWithoutParentsInput>
    create: XOR<parent_student_bindingsCreateWithoutParentsInput, parent_student_bindingsUncheckedCreateWithoutParentsInput>
  }

  export type parent_student_bindingsUpdateWithWhereUniqueWithoutParentsInput = {
    where: parent_student_bindingsWhereUniqueInput
    data: XOR<parent_student_bindingsUpdateWithoutParentsInput, parent_student_bindingsUncheckedUpdateWithoutParentsInput>
  }

  export type parent_student_bindingsUpdateManyWithWhereWithoutParentsInput = {
    where: parent_student_bindingsScalarWhereInput
    data: XOR<parent_student_bindingsUpdateManyMutationInput, parent_student_bindingsUncheckedUpdateManyWithoutParentsInput>
  }

  export type schoolsUpsertWithoutParentsInput = {
    update: XOR<schoolsUpdateWithoutParentsInput, schoolsUncheckedUpdateWithoutParentsInput>
    create: XOR<schoolsCreateWithoutParentsInput, schoolsUncheckedCreateWithoutParentsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutParentsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutParentsInput, schoolsUncheckedUpdateWithoutParentsInput>
  }

  export type schoolsUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    reward_configs?: reward_configsUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type parentsCreateWithoutParent_student_bindingsInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesCreateNestedManyWithoutParentsInput
    schools: schoolsCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutParent_student_bindingsInput = {
    id?: string
    schoolId: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutParent_student_bindingsInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutParent_student_bindingsInput, parentsUncheckedCreateWithoutParent_student_bindingsInput>
  }

  export type studentsCreateWithoutParent_student_bindingsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutParent_student_bindingsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutParent_student_bindingsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutParent_student_bindingsInput, studentsUncheckedCreateWithoutParent_student_bindingsInput>
  }

  export type parentsUpsertWithoutParent_student_bindingsInput = {
    update: XOR<parentsUpdateWithoutParent_student_bindingsInput, parentsUncheckedUpdateWithoutParent_student_bindingsInput>
    create: XOR<parentsCreateWithoutParent_student_bindingsInput, parentsUncheckedCreateWithoutParent_student_bindingsInput>
    where?: parentsWhereInput
  }

  export type parentsUpdateToOneWithWhereWithoutParent_student_bindingsInput = {
    where?: parentsWhereInput
    data: XOR<parentsUpdateWithoutParent_student_bindingsInput, parentsUncheckedUpdateWithoutParent_student_bindingsInput>
  }

  export type parentsUpdateWithoutParent_student_bindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUpdateManyWithoutParentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutParent_student_bindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type studentsUpsertWithoutParent_student_bindingsInput = {
    update: XOR<studentsUpdateWithoutParent_student_bindingsInput, studentsUncheckedUpdateWithoutParent_student_bindingsInput>
    create: XOR<studentsCreateWithoutParent_student_bindingsInput, studentsUncheckedCreateWithoutParent_student_bindingsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutParent_student_bindingsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutParent_student_bindingsInput, studentsUncheckedUpdateWithoutParent_student_bindingsInput>
  }

  export type studentsUpdateWithoutParent_student_bindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutParent_student_bindingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type parentsCreateWithoutDaily_summariesInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutParentsInput
    schools: schoolsCreateNestedOneWithoutParentsInput
  }

  export type parentsUncheckedCreateWithoutDaily_summariesInput = {
    id?: string
    schoolId: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutParentsInput
  }

  export type parentsCreateOrConnectWithoutDaily_summariesInput = {
    where: parentsWhereUniqueInput
    create: XOR<parentsCreateWithoutDaily_summariesInput, parentsUncheckedCreateWithoutDaily_summariesInput>
  }

  export type studentsCreateWithoutDaily_summariesInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutDaily_summariesInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedCreateNestedManyWithoutStudentsInput
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutDaily_summariesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutDaily_summariesInput, studentsUncheckedCreateWithoutDaily_summariesInput>
  }

  export type parentsUpsertWithoutDaily_summariesInput = {
    update: XOR<parentsUpdateWithoutDaily_summariesInput, parentsUncheckedUpdateWithoutDaily_summariesInput>
    create: XOR<parentsCreateWithoutDaily_summariesInput, parentsUncheckedCreateWithoutDaily_summariesInput>
    where?: parentsWhereInput
  }

  export type parentsUpdateToOneWithWhereWithoutDaily_summariesInput = {
    where?: parentsWhereInput
    data: XOR<parentsUpdateWithoutDaily_summariesInput, parentsUncheckedUpdateWithoutDaily_summariesInput>
  }

  export type parentsUpdateWithoutDaily_summariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutParentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutDaily_summariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type studentsUpsertWithoutDaily_summariesInput = {
    update: XOR<studentsUpdateWithoutDaily_summariesInput, studentsUncheckedUpdateWithoutDaily_summariesInput>
    create: XOR<studentsCreateWithoutDaily_summariesInput, studentsUncheckedCreateWithoutDaily_summariesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutDaily_summariesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutDaily_summariesInput, studentsUncheckedUpdateWithoutDaily_summariesInput>
  }

  export type studentsUpdateWithoutDaily_summariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutDaily_summariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateWithoutCampaignsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    challenge_participants?: challenge_participantsCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutStudentsInput
    schools: schoolsCreateNestedOneWithoutStudentsInput
    teachers?: teachersCreateNestedOneWithoutStudentsInput
    task_records?: task_recordsCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutCampaignsInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    challenge_participants?: challenge_participantsUncheckedCreateNestedManyWithoutStudentsInput
    daily_summaries?: daily_summariesUncheckedCreateNestedManyWithoutStudentsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutStudentsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutStudentsInput
    parent_student_bindings?: parent_student_bindingsUncheckedCreateNestedManyWithoutStudentsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutStudentsInput
    pk_matches_studentA?: pk_matchesUncheckedCreateNestedManyWithoutPlayerAInput
    pk_matches_studentB?: pk_matchesUncheckedCreateNestedManyWithoutPlayerBInput
    pk_matches_winner?: pk_matchesUncheckedCreateNestedManyWithoutWinnerInput
    student_badges?: student_badgesUncheckedCreateNestedManyWithoutStudentsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutStudentsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutCampaignsInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutCampaignsInput, studentsUncheckedCreateWithoutCampaignsInput>
  }

  export type studentsUpsertWithoutCampaignsInput = {
    update: XOR<studentsUpdateWithoutCampaignsInput, studentsUncheckedUpdateWithoutCampaignsInput>
    create: XOR<studentsCreateWithoutCampaignsInput, studentsUncheckedCreateWithoutCampaignsInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutCampaignsInput, studentsUncheckedUpdateWithoutCampaignsInput>
  }

  export type studentsUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type schoolsCreateWithoutReward_configsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesCreateNestedManyWithoutSchoolsInput
    challenges?: challengesCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsCreateNestedManyWithoutSchoolsInput
    habits?: habitsCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesCreateNestedManyWithoutSchoolsInput
    parents?: parentsCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsCreateNestedManyWithoutSchoolsInput
    students?: studentsCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsCreateNestedManyWithoutSchoolsInput
    teachers?: teachersCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsUncheckedCreateWithoutReward_configsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    planType?: $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: string
    expiredAt?: Date | string | null
    badges?: badgesUncheckedCreateNestedManyWithoutSchoolsInput
    challenges?: challengesUncheckedCreateNestedManyWithoutSchoolsInput
    habit_logs?: habit_logsUncheckedCreateNestedManyWithoutSchoolsInput
    habits?: habitsUncheckedCreateNestedManyWithoutSchoolsInput
    lesson_plans?: lesson_plansUncheckedCreateNestedManyWithoutSchoolsInput
    mistakes?: mistakesUncheckedCreateNestedManyWithoutSchoolsInput
    parents?: parentsUncheckedCreateNestedManyWithoutSchoolsInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedCreateNestedManyWithoutSchoolsInput
    pk_matches?: pk_matchesUncheckedCreateNestedManyWithoutSchoolsInput
    student_checkins?: student_checkinsUncheckedCreateNestedManyWithoutSchoolsInput
    students?: studentsUncheckedCreateNestedManyWithoutSchoolsInput
    task_library?: task_libraryUncheckedCreateNestedManyWithoutSchoolsInput
    task_records?: task_recordsUncheckedCreateNestedManyWithoutSchoolsInput
    teachers?: teachersUncheckedCreateNestedManyWithoutSchoolsInput
  }

  export type schoolsCreateOrConnectWithoutReward_configsInput = {
    where: schoolsWhereUniqueInput
    create: XOR<schoolsCreateWithoutReward_configsInput, schoolsUncheckedCreateWithoutReward_configsInput>
  }

  export type schoolsUpsertWithoutReward_configsInput = {
    update: XOR<schoolsUpdateWithoutReward_configsInput, schoolsUncheckedUpdateWithoutReward_configsInput>
    create: XOR<schoolsCreateWithoutReward_configsInput, schoolsUncheckedCreateWithoutReward_configsInput>
    where?: schoolsWhereInput
  }

  export type schoolsUpdateToOneWithWhereWithoutReward_configsInput = {
    where?: schoolsWhereInput
    data: XOR<schoolsUpdateWithoutReward_configsInput, schoolsUncheckedUpdateWithoutReward_configsInput>
  }

  export type schoolsUpdateWithoutReward_configsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutSchoolsNestedInput
    students?: studentsUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUpdateManyWithoutSchoolsNestedInput
  }

  export type schoolsUncheckedUpdateWithoutReward_configsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    settings?: NullableJsonNullValueInput | InputJsonValue
    educationalPhilosophy?: StringFieldUpdateOperationsInput | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badges?: badgesUncheckedUpdateManyWithoutSchoolsNestedInput
    challenges?: challengesUncheckedUpdateManyWithoutSchoolsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutSchoolsNestedInput
    habits?: habitsUncheckedUpdateManyWithoutSchoolsNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutSchoolsNestedInput
    parents?: parentsUncheckedUpdateManyWithoutSchoolsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsNestedInput
    pk_matches?: pk_matchesUncheckedUpdateManyWithoutSchoolsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutSchoolsNestedInput
    students?: studentsUncheckedUpdateManyWithoutSchoolsNestedInput
    task_library?: task_libraryUncheckedUpdateManyWithoutSchoolsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutSchoolsNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutSchoolsNestedInput
  }

  export type student_badgesCreateManyBadgesInput = {
    id?: string
    studentId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_badgesUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    students?: studentsUpdateOneRequiredWithoutStudent_badgesNestedInput
  }

  export type student_badgesUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_badgesUncheckedUpdateManyWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type challenge_participantsCreateManyChallengesInput = {
    id?: string
    studentId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type challenge_participantsUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutChallenge_participantsNestedInput
  }

  export type challenge_participantsUncheckedUpdateWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challenge_participantsUncheckedUpdateManyWithoutChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type habit_logsCreateManyHabitsInput = {
    id?: string
    schoolId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habit_logsUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    schools?: schoolsUpdateOneRequiredWithoutHabit_logsNestedInput
    students?: studentsUpdateOneRequiredWithoutHabit_logsNestedInput
  }

  export type habit_logsUncheckedUpdateWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habit_logsUncheckedUpdateManyWithoutHabitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type task_recordsCreateManyLesson_plansInput = {
    id?: string
    schoolId: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type task_recordsUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schools?: schoolsUpdateOneRequiredWithoutTask_recordsNestedInput
    students?: studentsUpdateOneRequiredWithoutTask_recordsNestedInput
  }

  export type task_recordsUncheckedUpdateWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type task_recordsUncheckedUpdateManyWithoutLesson_plansInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgesCreateManySchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    category: string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type challengesCreateManySchoolsInput = {
    id?: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    creatorId: string
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type habit_logsCreateManySchoolsInput = {
    id?: string
    habitId: string
    studentId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type habitsCreateManySchoolsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    expReward?: number
    pointsReward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type lesson_plansCreateManySchoolsInput = {
    id?: string
    teacherId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
  }

  export type mistakesCreateManySchoolsInput = {
    id?: string
    studentId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type parentsCreateManySchoolsInput = {
    id?: string
    phone: string
    password?: string
    name?: string | null
    identity?: string | null
    lastLoginAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type personalized_tutoring_plansCreateManySchoolsInput = {
    id?: string
    teacherId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateManySchoolsInput = {
    id?: string
    studentA: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reward_configsCreateManySchoolsInput = {
    id?: string
    module: string
    category?: string | null
    action: string
    expReward?: number
    pointsReward?: number
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type student_checkinsCreateManySchoolsInput = {
    id?: string
    studentId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type studentsCreateManySchoolsInput = {
    id?: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    teacherId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type task_libraryCreateManySchoolsInput = {
    id?: string
    category: string
    name: string
    description?: string | null
    defaultExp?: number
    type?: $Enums.TaskType
    difficulty?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
    educationalDomain?: string
    educationalSubcategory?: string
  }

  export type task_recordsCreateManySchoolsInput = {
    id?: string
    studentId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type teachersCreateManySchoolsInput = {
    id?: string
    username: string
    password: string
    name: string
    email?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    displayName?: string | null
    primaryClassName?: string | null
  }

  export type badgesUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student_badges?: student_badgesUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student_badges?: student_badgesUncheckedUpdateManyWithoutBadgesNestedInput
  }

  export type badgesUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    requirement?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type challengesUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUpdateManyWithoutChallengesNestedInput
    teachers?: teachersUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    creatorId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type habit_logsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    habits?: habitsUpdateOneRequiredWithoutHabit_logsNestedInput
    students?: studentsUpdateOneRequiredWithoutHabit_logsNestedInput
  }

  export type habit_logsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habit_logsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habitsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit_logs?: habit_logsUpdateManyWithoutHabitsNestedInput
  }

  export type habitsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    habit_logs?: habit_logsUncheckedUpdateManyWithoutHabitsNestedInput
  }

  export type habitsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lesson_plansUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    teachers?: teachersUpdateOneRequiredWithoutLesson_plansNestedInput
    task_records?: task_recordsUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    task_records?: task_recordsUncheckedUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type mistakesUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
    students?: studentsUpdateOneRequiredWithoutMistakesNestedInput
  }

  export type mistakesUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type mistakesUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type parentsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUpdateManyWithoutParentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutParentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type parentsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    identity?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
    teachers?: teachersUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
  }

  export type personalized_tutoring_plansUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerA?: studentsUpdateOneRequiredWithoutPk_matches_studentANestedInput
    playerB?: studentsUpdateOneRequiredWithoutPk_matches_studentBNestedInput
    winner?: studentsUpdateOneWithoutPk_matches_winnerNestedInput
  }

  export type pk_matchesUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reward_configsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_checkinsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutStudent_checkinsNestedInput
  }

  export type student_checkinsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_checkinsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    teachers?: teachersUpdateOneWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type task_libraryUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_libraryUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_libraryUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultExp?: IntFieldUpdateOperationsInput | number
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    educationalDomain?: StringFieldUpdateOperationsInput | string
    educationalSubcategory?: StringFieldUpdateOperationsInput | string
  }

  export type task_recordsUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson_plans?: lesson_plansUpdateOneWithoutTask_recordsNestedInput
    students?: studentsUpdateOneRequiredWithoutTask_recordsNestedInput
  }

  export type task_recordsUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type task_recordsUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teachersUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutTeachersNestedInput
    students?: studentsUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
    challenges?: challengesUncheckedUpdateManyWithoutTeachersNestedInput
    lesson_plans?: lesson_plansUncheckedUpdateManyWithoutTeachersNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersNestedInput
    students?: studentsUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateManyWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    primaryClassName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type campaignsCreateManyStudentsInput = {
    id?: string
    type: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type challenge_participantsCreateManyStudentsInput = {
    id?: string
    challengeId: string
    joinedAt?: Date | string
    status?: $Enums.ParticipantStatus
    result?: $Enums.ParticipantResult | null
    score?: number | null
    notes?: string | null
    completedAt?: Date | string | null
  }

  export type daily_summariesCreateManyStudentsInput = {
    id?: string
    parentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type habit_logsCreateManyStudentsInput = {
    id?: string
    schoolId: string
    habitId: string
    checkedAt?: Date | string
    streakDays?: number
    notes?: string | null
  }

  export type mistakesCreateManyStudentsInput = {
    id?: string
    schoolId: string
    imageUrl?: string | null
    ocrText?: string | null
    status?: $Enums.MistakeStatus
    category?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: string | null
    lastRetryAt?: Date | string | null
    lesson?: string | null
    questionNo?: number | null
    retryCount?: number
    subject?: string | null
    unit?: string | null
    workbookPage?: number | null
    wrongCount?: number
  }

  export type parent_student_bindingsCreateManyStudentsInput = {
    id?: string
    parentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type personalized_tutoring_plansCreateManyStudentsInput = {
    id?: string
    teacherId: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateManyPlayerAInput = {
    id?: string
    schoolId: string
    studentB: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateManyPlayerBInput = {
    id?: string
    schoolId: string
    studentA: string
    winnerId?: string | null
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pk_matchesCreateManyWinnerInput = {
    id?: string
    schoolId: string
    studentA: string
    studentB: string
    status?: $Enums.PKStatus
    topic: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type student_badgesCreateManyStudentsInput = {
    id?: string
    badgeId: string
    awardedBy?: string | null
    awardedAt?: Date | string
    reason?: string | null
  }

  export type student_checkinsCreateManyStudentsInput = {
    id?: string
    schoolId: string
    checkinDate: string
    checkedBy?: string | null
    createdAt?: Date | string
  }

  export type task_recordsCreateManyStudentsInput = {
    id?: string
    schoolId: string
    type: $Enums.TaskType
    title: string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.TaskStatus
    expAwarded?: number
    submittedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessonPlanId?: string | null
    task_category?: $Enums.TaskCategory
    is_current?: boolean
    attempts?: number
    subject?: string | null
    isOverridden?: boolean
    settledAt?: Date | string | null
  }

  export type campaignsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type campaignsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type challenge_participantsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    challenges?: challengesUpdateOneRequiredWithoutChallenge_participantsNestedInput
  }

  export type challenge_participantsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challenge_participantsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumParticipantStatusFieldUpdateOperationsInput | $Enums.ParticipantStatus
    result?: NullableEnumParticipantResultFieldUpdateOperationsInput | $Enums.ParticipantResult | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type daily_summariesUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: parentsUpdateOneRequiredWithoutDaily_summariesNestedInput
  }

  export type daily_summariesUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type daily_summariesUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type habit_logsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    habits?: habitsUpdateOneRequiredWithoutHabit_logsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutHabit_logsNestedInput
  }

  export type habit_logsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type habit_logsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    habitId?: StringFieldUpdateOperationsInput | string
    checkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    streakDays?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mistakesUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
    schools?: schoolsUpdateOneRequiredWithoutMistakesNestedInput
  }

  export type mistakesUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type mistakesUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    ocrText?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMistakeStatusFieldUpdateOperationsInput | $Enums.MistakeStatus
    category?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiAnalysis?: NullableJsonNullValueInput | InputJsonValue
    errorCause?: NullableStringFieldUpdateOperationsInput | string | null
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: NullableStringFieldUpdateOperationsInput | string | null
    questionNo?: NullableIntFieldUpdateOperationsInput | number | null
    retryCount?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    workbookPage?: NullableIntFieldUpdateOperationsInput | number | null
    wrongCount?: IntFieldUpdateOperationsInput | number
  }

  export type parent_student_bindingsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    parents?: parentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput
  }

  export type parent_student_bindingsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type parent_student_bindingsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personalized_tutoring_plansUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
    teachers?: teachersUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
  }

  export type personalized_tutoring_plansUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUpdateWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPk_matchesNestedInput
    playerB?: studentsUpdateOneRequiredWithoutPk_matches_studentBNestedInput
    winner?: studentsUpdateOneWithoutPk_matches_winnerNestedInput
  }

  export type pk_matchesUncheckedUpdateWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUncheckedUpdateManyWithoutPlayerAInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUpdateWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPk_matchesNestedInput
    playerA?: studentsUpdateOneRequiredWithoutPk_matches_studentANestedInput
    winner?: studentsUpdateOneWithoutPk_matches_winnerNestedInput
  }

  export type pk_matchesUncheckedUpdateWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUncheckedUpdateManyWithoutPlayerBInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPk_matchesNestedInput
    playerA?: studentsUpdateOneRequiredWithoutPk_matches_studentANestedInput
    playerB?: studentsUpdateOneRequiredWithoutPk_matches_studentBNestedInput
  }

  export type pk_matchesUncheckedUpdateWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pk_matchesUncheckedUpdateManyWithoutWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    studentA?: StringFieldUpdateOperationsInput | string
    studentB?: StringFieldUpdateOperationsInput | string
    status?: EnumPKStatusFieldUpdateOperationsInput | $Enums.PKStatus
    topic?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_badgesUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    badges?: badgesUpdateOneRequiredWithoutStudent_badgesNestedInput
  }

  export type student_badgesUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_badgesUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    awardedBy?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type student_checkinsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutStudent_checkinsNestedInput
  }

  export type student_checkinsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_checkinsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    checkinDate?: StringFieldUpdateOperationsInput | string
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type task_recordsUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson_plans?: lesson_plansUpdateOneWithoutTask_recordsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutTask_recordsNestedInput
  }

  export type task_recordsUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type task_recordsUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    expAwarded?: IntFieldUpdateOperationsInput | number
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    task_category?: EnumTaskCategoryFieldUpdateOperationsInput | $Enums.TaskCategory
    is_current?: BoolFieldUpdateOperationsInput | boolean
    attempts?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    isOverridden?: BoolFieldUpdateOperationsInput | boolean
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type challengesCreateManyTeachersInput = {
    id?: string
    schoolId: string
    title: string
    description?: string | null
    type?: $Enums.ChallengeType
    status?: $Enums.ChallengeStatus
    startDate?: Date | string
    endDate?: Date | string | null
    rewardPoints?: number
    rewardExp?: number
    maxParticipants?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type lesson_plansCreateManyTeachersInput = {
    id?: string
    schoolId: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    date: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    isGlobal?: boolean
  }

  export type personalized_tutoring_plansCreateManyTeachersInput = {
    id?: string
    schoolId: string
    title: string
    subject: string
    difficulty?: number
    scheduledDate: string
    scheduledTime: string
    duration: number
    actualStartTime?: Date | string | null
    actualEndTime?: Date | string | null
    studentId: string
    studentName: string
    studentClass: string
    knowledgePoints: JsonNullValueInput | InputJsonValue
    mainProblem: string
    detailedContent?: string | null
    teachingObjectives?: string | null
    preparationMaterials?: string | null
    tutoringMethods: JsonNullValueInput | InputJsonValue
    expReward?: number
    pointsReward?: number
    expAwarded?: boolean
    pointsAwarded?: boolean
    status?: string
    completionNotes?: string | null
    studentFeedback?: string | null
    parentFeedback?: string | null
    effectivenessRating?: number | null
    followUpRequired?: boolean
    followUpDate?: string | null
    followUpNotes?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: number
    completedSessions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type studentsCreateManyTeachersInput = {
    id?: string
    schoolId: string
    name: string
    className?: string | null
    level?: number
    points?: number
    exp?: number
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamId?: string | null
    currentLesson?: string | null
    currentLessonTitle?: string | null
    currentUnit?: string | null
    currentInviteCode?: string | null
    inviteCodeExpiresAt?: Date | string | null
    deletedAt?: Date | string | null
    grade?: string | null
    semester?: string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type challengesUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUpdateManyWithoutChallengesNestedInput
    schools?: schoolsUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutChallengesNestedInput
  }

  export type challengesUncheckedUpdateManyWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChallengeTypeFieldUpdateOperationsInput | $Enums.ChallengeType
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rewardPoints?: IntFieldUpdateOperationsInput | number
    rewardExp?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lesson_plansUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    schools?: schoolsUpdateOneRequiredWithoutLesson_plansNestedInput
    task_records?: task_recordsUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
    task_records?: task_recordsUncheckedUpdateManyWithoutLesson_plansNestedInput
  }

  export type lesson_plansUncheckedUpdateManyWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isGlobal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personalized_tutoring_plansUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schools?: schoolsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
    students?: studentsUpdateOneRequiredWithoutPersonalized_tutoring_plansNestedInput
  }

  export type personalized_tutoring_plansUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalized_tutoring_plansUncheckedUpdateManyWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    scheduledDate?: StringFieldUpdateOperationsInput | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    actualStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    studentClass?: StringFieldUpdateOperationsInput | string
    knowledgePoints?: JsonNullValueInput | InputJsonValue
    mainProblem?: StringFieldUpdateOperationsInput | string
    detailedContent?: NullableStringFieldUpdateOperationsInput | string | null
    teachingObjectives?: NullableStringFieldUpdateOperationsInput | string | null
    preparationMaterials?: NullableStringFieldUpdateOperationsInput | string | null
    tutoringMethods?: JsonNullValueInput | InputJsonValue
    expReward?: IntFieldUpdateOperationsInput | number
    pointsReward?: IntFieldUpdateOperationsInput | number
    expAwarded?: BoolFieldUpdateOperationsInput | boolean
    pointsAwarded?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    completionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    studentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    parentFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    effectivenessRating?: NullableIntFieldUpdateOperationsInput | number | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableStringFieldUpdateOperationsInput | string | null
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    totalSessions?: IntFieldUpdateOperationsInput | number
    completedSessions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUpdateManyWithoutStudentsNestedInput
    schools?: schoolsUpdateOneRequiredWithoutStudentsNestedInput
    task_records?: task_recordsUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
    campaigns?: campaignsUncheckedUpdateManyWithoutStudentsNestedInput
    challenge_participants?: challenge_participantsUncheckedUpdateManyWithoutStudentsNestedInput
    daily_summaries?: daily_summariesUncheckedUpdateManyWithoutStudentsNestedInput
    habit_logs?: habit_logsUncheckedUpdateManyWithoutStudentsNestedInput
    mistakes?: mistakesUncheckedUpdateManyWithoutStudentsNestedInput
    parent_student_bindings?: parent_student_bindingsUncheckedUpdateManyWithoutStudentsNestedInput
    personalized_tutoring_plans?: personalized_tutoring_plansUncheckedUpdateManyWithoutStudentsNestedInput
    pk_matches_studentA?: pk_matchesUncheckedUpdateManyWithoutPlayerANestedInput
    pk_matches_studentB?: pk_matchesUncheckedUpdateManyWithoutPlayerBNestedInput
    pk_matches_winner?: pk_matchesUncheckedUpdateManyWithoutWinnerNestedInput
    student_badges?: student_badgesUncheckedUpdateManyWithoutStudentsNestedInput
    student_checkins?: student_checkinsUncheckedUpdateManyWithoutStudentsNestedInput
    task_records?: task_recordsUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    className?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    exp?: IntFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    currentLesson?: NullableStringFieldUpdateOperationsInput | string | null
    currentLessonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    currentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    currentInviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableStringFieldUpdateOperationsInput | string | null
    currentProgress?: NullableJsonNullValueInput | InputJsonValue
  }

  export type daily_summariesCreateManyParentsInput = {
    id?: string
    studentId: string
    date: string
    parentLiked?: boolean
    parentComment?: string | null
    teacherRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type parent_student_bindingsCreateManyParentsInput = {
    id?: string
    studentId: string
    inviteCode: string
    bindingTime?: Date | string
    isActive?: boolean
  }

  export type daily_summariesUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: studentsUpdateOneRequiredWithoutDaily_summariesNestedInput
  }

  export type daily_summariesUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type daily_summariesUncheckedUpdateManyWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    parentLiked?: BoolFieldUpdateOperationsInput | boolean
    parentComment?: NullableStringFieldUpdateOperationsInput | string | null
    teacherRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type parent_student_bindingsUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    students?: studentsUpdateOneRequiredWithoutParent_student_bindingsNestedInput
  }

  export type parent_student_bindingsUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type parent_student_bindingsUncheckedUpdateManyWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    bindingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BadgesCountOutputTypeDefaultArgs instead
     */
    export type BadgesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengesCountOutputTypeDefaultArgs instead
     */
    export type ChallengesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HabitsCountOutputTypeDefaultArgs instead
     */
    export type HabitsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HabitsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Lesson_plansCountOutputTypeDefaultArgs instead
     */
    export type Lesson_plansCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Lesson_plansCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolsCountOutputTypeDefaultArgs instead
     */
    export type SchoolsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentsCountOutputTypeDefaultArgs instead
     */
    export type StudentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeachersCountOutputTypeDefaultArgs instead
     */
    export type TeachersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeachersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentsCountOutputTypeDefaultArgs instead
     */
    export type ParentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use badgesDefaultArgs instead
     */
    export type badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = badgesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use challenge_participantsDefaultArgs instead
     */
    export type challenge_participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = challenge_participantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use challengesDefaultArgs instead
     */
    export type challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = challengesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use habit_logsDefaultArgs instead
     */
    export type habit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = habit_logsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use habitsDefaultArgs instead
     */
    export type habitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = habitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use lesson_plansDefaultArgs instead
     */
    export type lesson_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = lesson_plansDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mistakesDefaultArgs instead
     */
    export type mistakesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mistakesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pk_matchesDefaultArgs instead
     */
    export type pk_matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pk_matchesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use schoolsDefaultArgs instead
     */
    export type schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = schoolsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_badgesDefaultArgs instead
     */
    export type student_badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_badgesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use studentsDefaultArgs instead
     */
    export type studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = studentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use student_checkinsDefaultArgs instead
     */
    export type student_checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = student_checkinsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use task_libraryDefaultArgs instead
     */
    export type task_libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = task_libraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use task_recordsDefaultArgs instead
     */
    export type task_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = task_recordsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use teachersDefaultArgs instead
     */
    export type teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = teachersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use personalized_tutoring_plansDefaultArgs instead
     */
    export type personalized_tutoring_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = personalized_tutoring_plansDefaultArgs<ExtArgs>
    /**
     * @deprecated Use parentsDefaultArgs instead
     */
    export type parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = parentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use parent_student_bindingsDefaultArgs instead
     */
    export type parent_student_bindingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = parent_student_bindingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use daily_summariesDefaultArgs instead
     */
    export type daily_summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = daily_summariesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use campaignsDefaultArgs instead
     */
    export type campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = campaignsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reward_configsDefaultArgs instead
     */
    export type reward_configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reward_configsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}